// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: osi_environment.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Osi3 {

  /// <summary>Holder for reflection information generated from osi_environment.proto</summary>
  public static partial class OsiEnvironmentReflection {

    #region Descriptor
    /// <summary>File descriptor for osi_environment.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static OsiEnvironmentReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChVvc2lfZW52aXJvbm1lbnQucHJvdG8SBG9zaTMaEG9zaV9jb21tb24ucHJv",
            "dG8imBEKF0Vudmlyb25tZW50YWxDb25kaXRpb25zEk8KFGFtYmllbnRfaWxs",
            "dW1pbmF0aW9uGAEgASgOMjEub3NpMy5FbnZpcm9ubWVudGFsQ29uZGl0aW9u",
            "cy5BbWJpZW50SWxsdW1pbmF0aW9uEjwKC3RpbWVfb2ZfZGF5GAIgASgLMicu",
            "b3NpMy5FbnZpcm9ubWVudGFsQ29uZGl0aW9ucy5UaW1lT2ZEYXkSFgoOdW5p",
            "eF90aW1lc3RhbXAYCCABKAMSHAoUYXRtb3NwaGVyaWNfcHJlc3N1cmUYAyAB",
            "KAESEwoLdGVtcGVyYXR1cmUYBCABKAESGQoRcmVsYXRpdmVfaHVtaWRpdHkY",
            "BSABKAESQgoNcHJlY2lwaXRhdGlvbhgGIAEoDjIrLm9zaTMuRW52aXJvbm1l",
            "bnRhbENvbmRpdGlvbnMuUHJlY2lwaXRhdGlvbhIuCgNmb2cYByABKA4yIS5v",
            "c2kzLkVudmlyb25tZW50YWxDb25kaXRpb25zLkZvZxIxChBzb3VyY2VfcmVm",
            "ZXJlbmNlGAkgAygLMhcub3NpMy5FeHRlcm5hbFJlZmVyZW5jZRI4CgZjbG91",
            "ZHMYCiABKAsyKC5vc2kzLkVudmlyb25tZW50YWxDb25kaXRpb25zLkNsb3Vk",
            "TGF5ZXISMAoEd2luZBgLIAEoCzIiLm9zaTMuRW52aXJvbm1lbnRhbENvbmRp",
            "dGlvbnMuV2luZBIuCgNzdW4YDCABKAsyIS5vc2kzLkVudmlyb25tZW50YWxD",
            "b25kaXRpb25zLlN1bhorCglUaW1lT2ZEYXkSHgoWc2Vjb25kc19zaW5jZV9t",
            "aWRuaWdodBgBIAEoDRrSBAoKQ2xvdWRMYXllchJdChZmcmFjdGlvbmFsX2Ns",
            "b3VkX2NvdmVyGAEgASgOMj0ub3NpMy5FbnZpcm9ubWVudGFsQ29uZGl0aW9u",
            "cy5DbG91ZExheWVyLkZyYWN0aW9uYWxDbG91ZENvdmVyIuQDChRGcmFjdGlv",
            "bmFsQ2xvdWRDb3ZlchIiCh5GUkFDVElPTkFMX0NMT1VEX0NPVkVSX1VOS05P",
            "V04QABIgChxGUkFDVElPTkFMX0NMT1VEX0NPVkVSX09USEVSEAESJQohRlJB",
            "Q1RJT05BTF9DTE9VRF9DT1ZFUl9aRVJPX09LVEFTEAISJAogRlJBQ1RJT05B",
            "TF9DTE9VRF9DT1ZFUl9PTkVfT0tUQVMQAxIkCiBGUkFDVElPTkFMX0NMT1VE",
            "X0NPVkVSX1RXT19PS1RBUxAEEiYKIkZSQUNUSU9OQUxfQ0xPVURfQ09WRVJf",
            "VEhSRUVfT0tUQVMQBRIlCiFGUkFDVElPTkFMX0NMT1VEX0NPVkVSX0ZPVVJf",
            "T0tUQVMQBhIlCiFGUkFDVElPTkFMX0NMT1VEX0NPVkVSX0ZJVkVfT0tUQVMQ",
            "BxIkCiBGUkFDVElPTkFMX0NMT1VEX0NPVkVSX1NJWF9PS1RBUxAIEiYKIkZS",
            "QUNUSU9OQUxfQ0xPVURfQ09WRVJfU0VWRU5fT0tUQVMQCRImCiJGUkFDVElP",
            "TkFMX0NMT1VEX0NPVkVSX0VJR0hUX09LVEFTEAoSJwojRlJBQ1RJT05BTF9D",
            "TE9VRF9DT1ZFUl9TS1lfT0JTQ1VSRUQQCxovCgRXaW5kEhgKEG9yaWdpbl9k",
            "aXJlY3Rpb24YASABKAESDQoFc3BlZWQYAiABKAEaPAoDU3VuEg8KB2F6aW11",
            "dGgYASABKAESEQoJZWxldmF0aW9uGAIgASgBEhEKCWludGVuc2l0eRgDIAEo",
            "ASKAAgoNUHJlY2lwaXRhdGlvbhIZChVQUkVDSVBJVEFUSU9OX1VOS05PV04Q",
            "ABIXChNQUkVDSVBJVEFUSU9OX09USEVSEAESFgoSUFJFQ0lQSVRBVElPTl9O",
            "T05FEAISHAoYUFJFQ0lQSVRBVElPTl9WRVJZX0xJR0hUEAMSFwoTUFJFQ0lQ",
            "SVRBVElPTl9MSUdIVBAEEhoKFlBSRUNJUElUQVRJT05fTU9ERVJBVEUQBRIX",
            "ChNQUkVDSVBJVEFUSU9OX0hFQVZZEAYSHAoYUFJFQ0lQSVRBVElPTl9WRVJZ",
            "X0hFQVZZEAcSGQoVUFJFQ0lQSVRBVElPTl9FWFRSRU1FEAgizQEKA0ZvZxIP",
            "CgtGT0dfVU5LTk9XThAAEg0KCUZPR19PVEhFUhABEhwKGEZPR19FWENFTExF",
            "TlRfVklTSUJJTElUWRACEhcKE0ZPR19HT09EX1ZJU0lCSUxJVFkQAxIbChdG",
            "T0dfTU9ERVJBVEVfVklTSUJJTElUWRAEEhcKE0ZPR19QT09SX1ZJU0lCSUxJ",
            "VFkQBRIMCghGT0dfTUlTVBAGEg0KCUZPR19MSUdIVBAHEg0KCUZPR19USElD",
            "SxAIEg0KCUZPR19ERU5TRRAJIoADChNBbWJpZW50SWxsdW1pbmF0aW9uEiAK",
            "HEFNQklFTlRfSUxMVU1JTkFUSU9OX1VOS05PV04QABIeChpBTUJJRU5UX0lM",
            "TFVNSU5BVElPTl9PVEhFUhABEh8KG0FNQklFTlRfSUxMVU1JTkFUSU9OX0xF",
            "VkVMMRACEh8KG0FNQklFTlRfSUxMVU1JTkFUSU9OX0xFVkVMMhADEh8KG0FN",
            "QklFTlRfSUxMVU1JTkFUSU9OX0xFVkVMMxAEEh8KG0FNQklFTlRfSUxMVU1J",
            "TkFUSU9OX0xFVkVMNBAFEh8KG0FNQklFTlRfSUxMVU1JTkFUSU9OX0xFVkVM",
            "NRAGEh8KG0FNQklFTlRfSUxMVU1JTkFUSU9OX0xFVkVMNhAHEh8KG0FNQklF",
            "TlRfSUxMVU1JTkFUSU9OX0xFVkVMNxAIEh8KG0FNQklFTlRfSUxMVU1JTkFU",
            "SU9OX0xFVkVMOBAJEh8KG0FNQklFTlRfSUxMVU1JTkFUSU9OX0xFVkVMORAK",
            "QgJIAWIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Osi3.OsiCommonReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Osi3.EnvironmentalConditions), global::Osi3.EnvironmentalConditions.Parser, new[]{ "AmbientIllumination", "TimeOfDay", "UnixTimestamp", "AtmosphericPressure", "Temperature", "RelativeHumidity", "Precipitation", "Fog", "SourceReference", "Clouds", "Wind", "Sun" }, null, new[]{ typeof(global::Osi3.EnvironmentalConditions.Types.Precipitation), typeof(global::Osi3.EnvironmentalConditions.Types.Fog), typeof(global::Osi3.EnvironmentalConditions.Types.AmbientIllumination) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Osi3.EnvironmentalConditions.Types.TimeOfDay), global::Osi3.EnvironmentalConditions.Types.TimeOfDay.Parser, new[]{ "SecondsSinceMidnight" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Osi3.EnvironmentalConditions.Types.CloudLayer), global::Osi3.EnvironmentalConditions.Types.CloudLayer.Parser, new[]{ "FractionalCloudCover" }, null, new[]{ typeof(global::Osi3.EnvironmentalConditions.Types.CloudLayer.Types.FractionalCloudCover) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Osi3.EnvironmentalConditions.Types.Wind), global::Osi3.EnvironmentalConditions.Types.Wind.Parser, new[]{ "OriginDirection", "Speed" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Osi3.EnvironmentalConditions.Types.Sun), global::Osi3.EnvironmentalConditions.Types.Sun.Parser, new[]{ "Azimuth", "Elevation", "Intensity" }, null, null, null, null)})
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  ///
  /// \brief The conditions of the environment.
  ///
  /// Definition of light, weather conditions and other environmental conditions.
  ///
  /// \note These conditions apply locally around the host vehicle.
  /// </summary>
  public sealed partial class EnvironmentalConditions : pb::IMessage<EnvironmentalConditions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<EnvironmentalConditions> _parser = new pb::MessageParser<EnvironmentalConditions>(() => new EnvironmentalConditions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<EnvironmentalConditions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Osi3.OsiEnvironmentReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EnvironmentalConditions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EnvironmentalConditions(EnvironmentalConditions other) : this() {
      ambientIllumination_ = other.ambientIllumination_;
      timeOfDay_ = other.timeOfDay_ != null ? other.timeOfDay_.Clone() : null;
      unixTimestamp_ = other.unixTimestamp_;
      atmosphericPressure_ = other.atmosphericPressure_;
      temperature_ = other.temperature_;
      relativeHumidity_ = other.relativeHumidity_;
      precipitation_ = other.precipitation_;
      fog_ = other.fog_;
      sourceReference_ = other.sourceReference_.Clone();
      clouds_ = other.clouds_ != null ? other.clouds_.Clone() : null;
      wind_ = other.wind_ != null ? other.wind_.Clone() : null;
      sun_ = other.sun_ != null ? other.sun_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EnvironmentalConditions Clone() {
      return new EnvironmentalConditions(this);
    }

    /// <summary>Field number for the "ambient_illumination" field.</summary>
    public const int AmbientIlluminationFieldNumber = 1;
    private global::Osi3.EnvironmentalConditions.Types.AmbientIllumination ambientIllumination_ = global::Osi3.EnvironmentalConditions.Types.AmbientIllumination.Unknown;
    /// <summary>
    /// The ambient illumination of the environment.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.EnvironmentalConditions.Types.AmbientIllumination AmbientIllumination {
      get { return ambientIllumination_; }
      set {
        ambientIllumination_ = value;
      }
    }

    /// <summary>Field number for the "time_of_day" field.</summary>
    public const int TimeOfDayFieldNumber = 2;
    private global::Osi3.EnvironmentalConditions.Types.TimeOfDay timeOfDay_;
    /// <summary>
    /// The time of day at the host vehicles location.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.EnvironmentalConditions.Types.TimeOfDay TimeOfDay {
      get { return timeOfDay_; }
      set {
        timeOfDay_ = value;
      }
    }

    /// <summary>Field number for the "unix_timestamp" field.</summary>
    public const int UnixTimestampFieldNumber = 8;
    private long unixTimestamp_;
    /// <summary>
    /// The unix timestamp describes the time and date at the host vehicle's
    /// location, referring to UTC.
    ///
    /// The Unix epoch (or Unix time or POSIX time or Unix timestamp) is
    /// the number of seconds that have elapsed since January 1, 1970
    /// (midnight UTC/GMT [1]), not counting leap seconds [2].
    /// Historically, the origin of UNIX system time was referred to as
    /// "00:00:00 GMT, January 1, 1970" [2]. Literally speaking the epoch
    /// is Unix time 0 (midnight 1/1/1970), but 'epoch' is often used as
    /// a synonym for 'Unix time'. Many Unix systems store epoch dates as
    /// a signed 32-bit integer, which might cause problems on January 19,
    /// 2038 (known as the Year 2038 problem or Y2038).
    ///
    /// \note You can convert the timestamp using the following [routines
    /// sorted by languages](https://www.epochconverter.com/#code).
    ///
    /// \par References:
    /// [1] ITU Radiocommunication Assembly. (2002). &lt;em>Recommondation  ITU-R  TF.460-6 Standard-frequency and time-signal emissions&lt;/em>. (Rec.  ITU-R  TF.460-6). Retrieved January 25, 2020, from http://www.itu.int/dms_pubrec/itu-r/rec/tf/R-REC-TF.460-6-200202-I!!PDF-E.pdf \n
    /// [2] The Open Group. (2018). &lt;em>POSIX.1-2017&lt;/em> The Open Group Base Specifications Issue 7, 2018 edition. IEEE Std 1003.1-2017 (Revision of IEEE Std 1003.1-2008). Retrieved January 25, 2020, from https://pubs.opengroup.org/onlinepubs/9699919799/xrat/contents.html
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long UnixTimestamp {
      get { return unixTimestamp_; }
      set {
        unixTimestamp_ = value;
      }
    }

    /// <summary>Field number for the "atmospheric_pressure" field.</summary>
    public const int AtmosphericPressureFieldNumber = 3;
    private double atmosphericPressure_;
    /// <summary>
    /// Atmospheric pressure in Pascal at z=0.0 in world frame (about 101325
    /// Pa).
    ///
    /// Unit: Pa
    ///
    /// \rules
    /// is_greater_than_or_equal_to: 80000
    /// is_less_than_or_equal_to: 120000
    /// \endrules
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double AtmosphericPressure {
      get { return atmosphericPressure_; }
      set {
        atmosphericPressure_ = value;
      }
    }

    /// <summary>Field number for the "temperature" field.</summary>
    public const int TemperatureFieldNumber = 4;
    private double temperature_;
    /// <summary>
    /// Temperature in Kelvin at z=0.0 in world frame.
    ///
    /// Unit: K
    ///
    /// \rules
    /// is_greater_than_or_equal_to: 170
    /// is_less_than_or_equal_to: 340
    /// \endrules
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double Temperature {
      get { return temperature_; }
      set {
        temperature_ = value;
      }
    }

    /// <summary>Field number for the "relative_humidity" field.</summary>
    public const int RelativeHumidityFieldNumber = 5;
    private double relativeHumidity_;
    /// <summary>
    /// Relative humidity in at z=0.0 in world frame.
    ///
    /// Note that physically more relevant measures, like absolute or specific
    /// humidity can be easily derived from relative_humidity, given that the
    /// temperature and atmospheric_pressure are known.
    ///
    /// Unit: %
    ///
    /// \rules
    /// is_greater_than_or_equal_to: 0
    /// is_less_than_or_equal_to: 100
    /// \endrules
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double RelativeHumidity {
      get { return relativeHumidity_; }
      set {
        relativeHumidity_ = value;
      }
    }

    /// <summary>Field number for the "precipitation" field.</summary>
    public const int PrecipitationFieldNumber = 6;
    private global::Osi3.EnvironmentalConditions.Types.Precipitation precipitation_ = global::Osi3.EnvironmentalConditions.Types.Precipitation.Unknown;
    /// <summary>
    /// Description of the precipitation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.EnvironmentalConditions.Types.Precipitation Precipitation {
      get { return precipitation_; }
      set {
        precipitation_ = value;
      }
    }

    /// <summary>Field number for the "fog" field.</summary>
    public const int FogFieldNumber = 7;
    private global::Osi3.EnvironmentalConditions.Types.Fog fog_ = global::Osi3.EnvironmentalConditions.Types.Fog.Unknown;
    /// <summary>
    /// Description of the fog.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.EnvironmentalConditions.Types.Fog Fog {
      get { return fog_; }
      set {
        fog_ = value;
      }
    }

    /// <summary>Field number for the "source_reference" field.</summary>
    public const int SourceReferenceFieldNumber = 9;
    private static readonly pb::FieldCodec<global::Osi3.ExternalReference> _repeated_sourceReference_codec
        = pb::FieldCodec.ForMessage(74, global::Osi3.ExternalReference.Parser);
    private readonly pbc::RepeatedField<global::Osi3.ExternalReference> sourceReference_ = new pbc::RepeatedField<global::Osi3.ExternalReference>();
    /// <summary>
    /// Optional external reference to the environmental condition sources.
    ///
    /// \note For OpenDRIVE and OpenSCENARIO there is no direct counterpart.
    ///
    /// \note For non-ASAM standards, it is implementation-specific how
    ///       source_reference is resolved.
    ///
    /// \note The value has to be repeated because one object may be derived
    ///       from more than one origin source, for example, from a scenario file
    ///       and from sensors.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Osi3.ExternalReference> SourceReference {
      get { return sourceReference_; }
    }

    /// <summary>Field number for the "clouds" field.</summary>
    public const int CloudsFieldNumber = 10;
    private global::Osi3.EnvironmentalConditions.Types.CloudLayer clouds_;
    /// <summary>
    /// Description of the clouds.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.EnvironmentalConditions.Types.CloudLayer Clouds {
      get { return clouds_; }
      set {
        clouds_ = value;
      }
    }

    /// <summary>Field number for the "wind" field.</summary>
    public const int WindFieldNumber = 11;
    private global::Osi3.EnvironmentalConditions.Types.Wind wind_;
    /// <summary>
    /// Description of the wind.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.EnvironmentalConditions.Types.Wind Wind {
      get { return wind_; }
      set {
        wind_ = value;
      }
    }

    /// <summary>Field number for the "sun" field.</summary>
    public const int SunFieldNumber = 12;
    private global::Osi3.EnvironmentalConditions.Types.Sun sun_;
    /// <summary>
    /// Description of the sun.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.EnvironmentalConditions.Types.Sun Sun {
      get { return sun_; }
      set {
        sun_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as EnvironmentalConditions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(EnvironmentalConditions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (AmbientIllumination != other.AmbientIllumination) return false;
      if (!object.Equals(TimeOfDay, other.TimeOfDay)) return false;
      if (UnixTimestamp != other.UnixTimestamp) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(AtmosphericPressure, other.AtmosphericPressure)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Temperature, other.Temperature)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(RelativeHumidity, other.RelativeHumidity)) return false;
      if (Precipitation != other.Precipitation) return false;
      if (Fog != other.Fog) return false;
      if(!sourceReference_.Equals(other.sourceReference_)) return false;
      if (!object.Equals(Clouds, other.Clouds)) return false;
      if (!object.Equals(Wind, other.Wind)) return false;
      if (!object.Equals(Sun, other.Sun)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (AmbientIllumination != global::Osi3.EnvironmentalConditions.Types.AmbientIllumination.Unknown) hash ^= AmbientIllumination.GetHashCode();
      if (timeOfDay_ != null) hash ^= TimeOfDay.GetHashCode();
      if (UnixTimestamp != 0L) hash ^= UnixTimestamp.GetHashCode();
      if (AtmosphericPressure != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(AtmosphericPressure);
      if (Temperature != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Temperature);
      if (RelativeHumidity != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(RelativeHumidity);
      if (Precipitation != global::Osi3.EnvironmentalConditions.Types.Precipitation.Unknown) hash ^= Precipitation.GetHashCode();
      if (Fog != global::Osi3.EnvironmentalConditions.Types.Fog.Unknown) hash ^= Fog.GetHashCode();
      hash ^= sourceReference_.GetHashCode();
      if (clouds_ != null) hash ^= Clouds.GetHashCode();
      if (wind_ != null) hash ^= Wind.GetHashCode();
      if (sun_ != null) hash ^= Sun.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (AmbientIllumination != global::Osi3.EnvironmentalConditions.Types.AmbientIllumination.Unknown) {
        output.WriteRawTag(8);
        output.WriteEnum((int) AmbientIllumination);
      }
      if (timeOfDay_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(TimeOfDay);
      }
      if (AtmosphericPressure != 0D) {
        output.WriteRawTag(25);
        output.WriteDouble(AtmosphericPressure);
      }
      if (Temperature != 0D) {
        output.WriteRawTag(33);
        output.WriteDouble(Temperature);
      }
      if (RelativeHumidity != 0D) {
        output.WriteRawTag(41);
        output.WriteDouble(RelativeHumidity);
      }
      if (Precipitation != global::Osi3.EnvironmentalConditions.Types.Precipitation.Unknown) {
        output.WriteRawTag(48);
        output.WriteEnum((int) Precipitation);
      }
      if (Fog != global::Osi3.EnvironmentalConditions.Types.Fog.Unknown) {
        output.WriteRawTag(56);
        output.WriteEnum((int) Fog);
      }
      if (UnixTimestamp != 0L) {
        output.WriteRawTag(64);
        output.WriteInt64(UnixTimestamp);
      }
      sourceReference_.WriteTo(output, _repeated_sourceReference_codec);
      if (clouds_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(Clouds);
      }
      if (wind_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(Wind);
      }
      if (sun_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(Sun);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (AmbientIllumination != global::Osi3.EnvironmentalConditions.Types.AmbientIllumination.Unknown) {
        output.WriteRawTag(8);
        output.WriteEnum((int) AmbientIllumination);
      }
      if (timeOfDay_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(TimeOfDay);
      }
      if (AtmosphericPressure != 0D) {
        output.WriteRawTag(25);
        output.WriteDouble(AtmosphericPressure);
      }
      if (Temperature != 0D) {
        output.WriteRawTag(33);
        output.WriteDouble(Temperature);
      }
      if (RelativeHumidity != 0D) {
        output.WriteRawTag(41);
        output.WriteDouble(RelativeHumidity);
      }
      if (Precipitation != global::Osi3.EnvironmentalConditions.Types.Precipitation.Unknown) {
        output.WriteRawTag(48);
        output.WriteEnum((int) Precipitation);
      }
      if (Fog != global::Osi3.EnvironmentalConditions.Types.Fog.Unknown) {
        output.WriteRawTag(56);
        output.WriteEnum((int) Fog);
      }
      if (UnixTimestamp != 0L) {
        output.WriteRawTag(64);
        output.WriteInt64(UnixTimestamp);
      }
      sourceReference_.WriteTo(ref output, _repeated_sourceReference_codec);
      if (clouds_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(Clouds);
      }
      if (wind_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(Wind);
      }
      if (sun_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(Sun);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (AmbientIllumination != global::Osi3.EnvironmentalConditions.Types.AmbientIllumination.Unknown) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) AmbientIllumination);
      }
      if (timeOfDay_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TimeOfDay);
      }
      if (UnixTimestamp != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(UnixTimestamp);
      }
      if (AtmosphericPressure != 0D) {
        size += 1 + 8;
      }
      if (Temperature != 0D) {
        size += 1 + 8;
      }
      if (RelativeHumidity != 0D) {
        size += 1 + 8;
      }
      if (Precipitation != global::Osi3.EnvironmentalConditions.Types.Precipitation.Unknown) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Precipitation);
      }
      if (Fog != global::Osi3.EnvironmentalConditions.Types.Fog.Unknown) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Fog);
      }
      size += sourceReference_.CalculateSize(_repeated_sourceReference_codec);
      if (clouds_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Clouds);
      }
      if (wind_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Wind);
      }
      if (sun_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Sun);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(EnvironmentalConditions other) {
      if (other == null) {
        return;
      }
      if (other.AmbientIllumination != global::Osi3.EnvironmentalConditions.Types.AmbientIllumination.Unknown) {
        AmbientIllumination = other.AmbientIllumination;
      }
      if (other.timeOfDay_ != null) {
        if (timeOfDay_ == null) {
          TimeOfDay = new global::Osi3.EnvironmentalConditions.Types.TimeOfDay();
        }
        TimeOfDay.MergeFrom(other.TimeOfDay);
      }
      if (other.UnixTimestamp != 0L) {
        UnixTimestamp = other.UnixTimestamp;
      }
      if (other.AtmosphericPressure != 0D) {
        AtmosphericPressure = other.AtmosphericPressure;
      }
      if (other.Temperature != 0D) {
        Temperature = other.Temperature;
      }
      if (other.RelativeHumidity != 0D) {
        RelativeHumidity = other.RelativeHumidity;
      }
      if (other.Precipitation != global::Osi3.EnvironmentalConditions.Types.Precipitation.Unknown) {
        Precipitation = other.Precipitation;
      }
      if (other.Fog != global::Osi3.EnvironmentalConditions.Types.Fog.Unknown) {
        Fog = other.Fog;
      }
      sourceReference_.Add(other.sourceReference_);
      if (other.clouds_ != null) {
        if (clouds_ == null) {
          Clouds = new global::Osi3.EnvironmentalConditions.Types.CloudLayer();
        }
        Clouds.MergeFrom(other.Clouds);
      }
      if (other.wind_ != null) {
        if (wind_ == null) {
          Wind = new global::Osi3.EnvironmentalConditions.Types.Wind();
        }
        Wind.MergeFrom(other.Wind);
      }
      if (other.sun_ != null) {
        if (sun_ == null) {
          Sun = new global::Osi3.EnvironmentalConditions.Types.Sun();
        }
        Sun.MergeFrom(other.Sun);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            AmbientIllumination = (global::Osi3.EnvironmentalConditions.Types.AmbientIllumination) input.ReadEnum();
            break;
          }
          case 18: {
            if (timeOfDay_ == null) {
              TimeOfDay = new global::Osi3.EnvironmentalConditions.Types.TimeOfDay();
            }
            input.ReadMessage(TimeOfDay);
            break;
          }
          case 25: {
            AtmosphericPressure = input.ReadDouble();
            break;
          }
          case 33: {
            Temperature = input.ReadDouble();
            break;
          }
          case 41: {
            RelativeHumidity = input.ReadDouble();
            break;
          }
          case 48: {
            Precipitation = (global::Osi3.EnvironmentalConditions.Types.Precipitation) input.ReadEnum();
            break;
          }
          case 56: {
            Fog = (global::Osi3.EnvironmentalConditions.Types.Fog) input.ReadEnum();
            break;
          }
          case 64: {
            UnixTimestamp = input.ReadInt64();
            break;
          }
          case 74: {
            sourceReference_.AddEntriesFrom(input, _repeated_sourceReference_codec);
            break;
          }
          case 82: {
            if (clouds_ == null) {
              Clouds = new global::Osi3.EnvironmentalConditions.Types.CloudLayer();
            }
            input.ReadMessage(Clouds);
            break;
          }
          case 90: {
            if (wind_ == null) {
              Wind = new global::Osi3.EnvironmentalConditions.Types.Wind();
            }
            input.ReadMessage(Wind);
            break;
          }
          case 98: {
            if (sun_ == null) {
              Sun = new global::Osi3.EnvironmentalConditions.Types.Sun();
            }
            input.ReadMessage(Sun);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            AmbientIllumination = (global::Osi3.EnvironmentalConditions.Types.AmbientIllumination) input.ReadEnum();
            break;
          }
          case 18: {
            if (timeOfDay_ == null) {
              TimeOfDay = new global::Osi3.EnvironmentalConditions.Types.TimeOfDay();
            }
            input.ReadMessage(TimeOfDay);
            break;
          }
          case 25: {
            AtmosphericPressure = input.ReadDouble();
            break;
          }
          case 33: {
            Temperature = input.ReadDouble();
            break;
          }
          case 41: {
            RelativeHumidity = input.ReadDouble();
            break;
          }
          case 48: {
            Precipitation = (global::Osi3.EnvironmentalConditions.Types.Precipitation) input.ReadEnum();
            break;
          }
          case 56: {
            Fog = (global::Osi3.EnvironmentalConditions.Types.Fog) input.ReadEnum();
            break;
          }
          case 64: {
            UnixTimestamp = input.ReadInt64();
            break;
          }
          case 74: {
            sourceReference_.AddEntriesFrom(ref input, _repeated_sourceReference_codec);
            break;
          }
          case 82: {
            if (clouds_ == null) {
              Clouds = new global::Osi3.EnvironmentalConditions.Types.CloudLayer();
            }
            input.ReadMessage(Clouds);
            break;
          }
          case 90: {
            if (wind_ == null) {
              Wind = new global::Osi3.EnvironmentalConditions.Types.Wind();
            }
            input.ReadMessage(Wind);
            break;
          }
          case 98: {
            if (sun_ == null) {
              Sun = new global::Osi3.EnvironmentalConditions.Types.Sun();
            }
            input.ReadMessage(Sun);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the EnvironmentalConditions message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Definition of discretized precipitation states according to [1].
      /// (I = Intensity of precipitation in mm per hour mm/h)
      ///
      /// \par Reference:
      /// [1] Paulat, M., Frei, C., Hagen, M. &amp; Wernli, H. (2008). A gridded dataset of hourly precipitation in Germany: Its construction, climatology and application. &lt;em>Meteorologische Zeitschrift&lt;/em>. Vol. 17, No. 6. pp. 719-732. Berlin, Stuttgart, Germany. https://doi.org/10.1127/0941-2948/2008/0332
      /// </summary>
      public enum Precipitation {
        /// <summary>
        /// Intensity of precipitation is unknown (must not be used in ground
        /// truth).
        /// </summary>
        [pbr::OriginalName("PRECIPITATION_UNKNOWN")] Unknown = 0,
        /// <summary>
        /// Other (unspecified but known) intensity of precipitation.
        /// </summary>
        [pbr::OriginalName("PRECIPITATION_OTHER")] Other = 1,
        /// <summary>
        /// No precipitation, when I in [0,0.1[ mm/h
        /// </summary>
        [pbr::OriginalName("PRECIPITATION_NONE")] None = 2,
        /// <summary>
        /// Very light intensity of precipitation, when I in [0.1,0.5[ mm/h
        /// </summary>
        [pbr::OriginalName("PRECIPITATION_VERY_LIGHT")] VeryLight = 3,
        /// <summary>
        /// Light intensity of precipitation, when I in [0.5,1.9[ mm/h
        /// </summary>
        [pbr::OriginalName("PRECIPITATION_LIGHT")] Light = 4,
        /// <summary>
        /// Moderate intensity of precipitation, when I in [1.9,8.1[ mm/h
        /// </summary>
        [pbr::OriginalName("PRECIPITATION_MODERATE")] Moderate = 5,
        /// <summary>
        /// Heavy intensity of precipitation, when I in [8.1,34[ mm/h
        /// </summary>
        [pbr::OriginalName("PRECIPITATION_HEAVY")] Heavy = 6,
        /// <summary>
        /// Very heavy intensity of precipitation, when I in [34,149[ mm/h
        /// </summary>
        [pbr::OriginalName("PRECIPITATION_VERY_HEAVY")] VeryHeavy = 7,
        /// <summary>
        /// Extreme intensity of precipitation, when I in [149,infinity[ mm/h
        /// </summary>
        [pbr::OriginalName("PRECIPITATION_EXTREME")] Extreme = 8,
      }

      /// <summary>
      /// Definition of discretized fog states according to [1].
      /// The bandwidth of thick and dense fog was adjusted to fit the German StVO
      /// regarding rear fog lights [2, 3].
      /// (V = Visibility in m)
      ///
      /// Visibility is defined as the length of the atmosphere over which a beam
      /// of light travels before its luminous flux is reduced to 5% of its
      /// original value (definition used by the Meteorological Office [4]).
      /// This is approximately equivalent to visibility measured in terms of the
      /// contrast of a distant object against its background.
      ///
      /// \par References:
      /// [1] Shepard, F. D. (1996). &lt;em>Reduced visibility due to fog on the highway.&lt;/em> Transportation Research Board, National Research Council (Ed.). National Academy Press. Washington, D.C., USA. ISBN 0-309-06006-0. \n
      /// [2] Strassenverkehrs-Ordnung (StVO) as of dated  March 06, 2013 (BGBl. I S. 367), lastly changed by article 4a of the order from June 06, 2019 (BGBl. I S. 756). \n
      /// [3] stvo.de. (2013, April 01). &lt;em>StVO Par. 17 Beleuchtung&lt;/em>. Retrieved January 25, 2020, from https://www.stvo.de/strassenverkehrsordnung/101-17-beleuchtung \n
      /// [4] Meteorological Office UK. (2020). &lt;em>Homepage of the Meteorological Office - How we measure visibility&lt;/em>. Retrieved January 25, 2020, from http://www.metoffice.gov.uk/guide/weather/observations-guide/how-we-measure-visibility
      /// </summary>
      public enum Fog {
        /// <summary>
        /// Visibility is unknown (must not be used in ground truth).
        /// </summary>
        [pbr::OriginalName("FOG_UNKNOWN")] Unknown = 0,
        /// <summary>
        /// Other (unspecified but known) fog intensity.
        /// </summary>
        [pbr::OriginalName("FOG_OTHER")] Other = 1,
        /// <summary>
        /// Excellent visibility, when V in [40000,infinity[ m
        /// </summary>
        [pbr::OriginalName("FOG_EXCELLENT_VISIBILITY")] ExcellentVisibility = 2,
        /// <summary>
        /// Good visibility, when V in [10000,40000[ m
        /// </summary>
        [pbr::OriginalName("FOG_GOOD_VISIBILITY")] GoodVisibility = 3,
        /// <summary>
        /// Moderate visibility, when V in [4000,10000[ m
        /// </summary>
        [pbr::OriginalName("FOG_MODERATE_VISIBILITY")] ModerateVisibility = 4,
        /// <summary>
        /// Poor visibility, when V in [2000,4000[ m
        /// </summary>
        [pbr::OriginalName("FOG_POOR_VISIBILITY")] PoorVisibility = 5,
        /// <summary>
        /// Mist, when V in [1000,2000[ m
        /// </summary>
        [pbr::OriginalName("FOG_MIST")] Mist = 6,
        /// <summary>
        /// Fog, when V in [200,1000[ m
        /// </summary>
        [pbr::OriginalName("FOG_LIGHT")] Light = 7,
        /// <summary>
        /// Thick fog, when V in [50,200[ m
        /// </summary>
        [pbr::OriginalName("FOG_THICK")] Thick = 8,
        /// <summary>
        /// Dense fog, when V in [0,50[ m
        /// (allowed to use rear fog light according to [3])
        /// </summary>
        [pbr::OriginalName("FOG_DENSE")] Dense = 9,
      }

      /// <summary>
      /// Definition of discretized ambient illumination states:
      /// Ambient light is any light in the vehicle's environment that is not
      /// emitted by the vehicle itself. It can include sun/moon light, light from
      /// other cars, street lights etc.
      ///
      /// lx ("lux") is the SI unit of luminance or illumination of an area of exact
      /// one square meter, which is equal to one lumen per square meter 1 lx =
      /// 1 lm/m^2 [1].
      /// lm ("lumen") is the SI derived unit of luminous flux and a measure of
      /// the total quantity of visible light emitted by a source. The lumen is
      /// defined in relation to cd ("candela") as 1 lm = 1 cd sr, where sr
      /// denotes steradian, the unit of solid angle used in 3D geometry analogous
      /// to the radian [1].
      ///
      /// Categorization is done based on natural day/night time illuminance levels
      /// [2] and standards for required lighting levels on roads [2, 3, 4, 5].
      ///
      /// \par References:
      /// [1] DIN Deutsches Institut fuer Normung e. V. (1982). &lt;em>DIN 5031-3 Strahlungsphysik im optischen Bereich und Lichttechnik - Groessen, Formelzeichen und Einheiten der Lichttechnik&lt;/em>. (DIN 5031-3:1982-03). Berlin, Germany. \n
      /// [2] National Optical Astronomy Observatory. (2015, December 02). &lt;em>Recommended Light Levels&lt;/em>. Retrieved January 25, 2020, from https://www.noao.edu/education/QLTkit/ACTIVITY_Documents/Safety/LightLevels_outdoor+indoor.pdf \n
      /// [3] Wang, Y. &amp; Zou, Y., (2016, March). &lt;em>Study on Illumination for State Highways&lt;/em>. Washington State Department of Transportation. Retrieved January 25, 2020, from http://www.wsdot.wa.gov/research/reports/fullreports/847.1.pdf \n
      /// [4] Laperriere, A. (2011, May). &lt;em>LED street lighting in the municipality of Saint-Gedeon-de-Beauce within the framework of advanced lighting technologies&lt;/em>. Retrieved January 25, 2020, from http://sslnet.ca/wp-content/uploads/2011/10/LTE-RT-2011-0076-Anglais.pdf \n
      /// [5] Crabb, G. I., Beaumont, R. &amp; Webster, D. (2008, October 17). &lt;em>Review of the class and quality of street lighting&lt;/em>. Transport Research Laboratory. Retrieved January 25, 2020, from http://courtneystrong.com/wp-content/uploads/2017/07/css-sl1-class-and-quality-of-street-lighting.pdf
      /// </summary>
      public enum AmbientIllumination {
        /// <summary>
        /// Ambient illumination is unknown (must not be used in ground truth).
        /// </summary>
        [pbr::OriginalName("AMBIENT_ILLUMINATION_UNKNOWN")] Unknown = 0,
        /// <summary>
        /// Other (unspecified but known) ambient illumination.
        /// </summary>
        [pbr::OriginalName("AMBIENT_ILLUMINATION_OTHER")] Other = 1,
        /// <summary>
        /// Level 1 illumination in ]0.001, 0.01[ lx. \n
        /// E.g. Night with no artificial light.
        ///
        /// \note Use \c #AMBIENT_ILLUMINATION_LEVEL1 if illumination is less
        /// than 0.001 lx.
        /// </summary>
        [pbr::OriginalName("AMBIENT_ILLUMINATION_LEVEL1")] Level1 = 2,
        /// <summary>
        /// Level 2 illumination in [0.01, 1[ lx. \n
        /// E.g. Night full moon / Deep twilight.
        /// </summary>
        [pbr::OriginalName("AMBIENT_ILLUMINATION_LEVEL2")] Level2 = 3,
        /// <summary>
        /// Level 3 illumination in [1, 3[ lx. \n
        /// E.g. Deep to average twilight / Minimum lighting on local low
        /// pedestrian conflict roads.
        /// </summary>
        [pbr::OriginalName("AMBIENT_ILLUMINATION_LEVEL3")] Level3 = 4,
        /// <summary>
        /// Level 4 illumination in [3, 10[ lx. \n
        /// E.g. Average to full twilight / Minimum lighting on collector roads /
        /// Minimum lighting on major and expressway roads with low to average
        /// pedestrian conflict.
        /// </summary>
        [pbr::OriginalName("AMBIENT_ILLUMINATION_LEVEL4")] Level4 = 5,
        /// <summary>
        /// Level 5 illumination in [10, 20[ lx. \n
        /// E.g. Minimum lighting on major and expressway roads with high
        /// pedestrian conflict.
        /// </summary>
        [pbr::OriginalName("AMBIENT_ILLUMINATION_LEVEL5")] Level5 = 6,
        /// <summary>
        /// Level 6 illumination in [20, 400[ lx. \n
        /// E.g. Roads with more lighting / Very dark overcast day to sunrise or
        /// sunset on a clear day.
        /// </summary>
        [pbr::OriginalName("AMBIENT_ILLUMINATION_LEVEL6")] Level6 = 7,
        /// <summary>
        /// Level 7 illumination in [400, 1000[ lx. \n
        /// E.g. Sunrise or sunset on a clear day / Overcast day.
        /// </summary>
        [pbr::OriginalName("AMBIENT_ILLUMINATION_LEVEL7")] Level7 = 8,
        /// <summary>
        /// Level 8 illumination in [1000, 10000[ lx. \n
        /// E.g. Average to full daylight.
        /// </summary>
        [pbr::OriginalName("AMBIENT_ILLUMINATION_LEVEL8")] Level8 = 9,
        /// <summary>
        /// Level 9 illumination in [10000, 120000[ lx. \n
        /// E.g. Full daylight to intense sunlight.
        ///
        /// \note Use \c #AMBIENT_ILLUMINATION_LEVEL9 if illumination is more
        /// than 120000 lx
        /// </summary>
        [pbr::OriginalName("AMBIENT_ILLUMINATION_LEVEL9")] Level9 = 10,
      }

      /// <summary>
      ///
      /// \brief The time of day at a specified location.
      ///
      /// \note In general the global position of the parent frame should be
      /// obtainable in order to derive the local time.
      /// This information can be calculated from the \c #unix_timestamp in
      /// combination with \c #osi3::GroundTruth::proj_string and the position of
      /// the corresponding \c #osi3::BaseStationary or \c #osi3::BaseMoving .
      /// </summary>
      public sealed partial class TimeOfDay : pb::IMessage<TimeOfDay>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<TimeOfDay> _parser = new pb::MessageParser<TimeOfDay>(() => new TimeOfDay());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<TimeOfDay> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Osi3.EnvironmentalConditions.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TimeOfDay() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TimeOfDay(TimeOfDay other) : this() {
          secondsSinceMidnight_ = other.secondsSinceMidnight_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TimeOfDay Clone() {
          return new TimeOfDay(this);
        }

        /// <summary>Field number for the "seconds_since_midnight" field.</summary>
        public const int SecondsSinceMidnightFieldNumber = 1;
        private uint secondsSinceMidnight_;
        /// <summary>
        /// The number of seconds in s that have passed since midnight local time.
        /// Used e.g. for determining the current state of the circadian rhythm
        /// of a driver.
        ///
        /// \note No changes of daylight saving time or time zones are
        /// considered.
        ///
        /// \rules
        /// is_greater_than_or_equal_to: 0
        /// is_less_than: 86400
        /// \endrules
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public uint SecondsSinceMidnight {
          get { return secondsSinceMidnight_; }
          set {
            secondsSinceMidnight_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as TimeOfDay);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(TimeOfDay other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (SecondsSinceMidnight != other.SecondsSinceMidnight) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (SecondsSinceMidnight != 0) hash ^= SecondsSinceMidnight.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (SecondsSinceMidnight != 0) {
            output.WriteRawTag(8);
            output.WriteUInt32(SecondsSinceMidnight);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (SecondsSinceMidnight != 0) {
            output.WriteRawTag(8);
            output.WriteUInt32(SecondsSinceMidnight);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (SecondsSinceMidnight != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SecondsSinceMidnight);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(TimeOfDay other) {
          if (other == null) {
            return;
          }
          if (other.SecondsSinceMidnight != 0) {
            SecondsSinceMidnight = other.SecondsSinceMidnight;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                SecondsSinceMidnight = input.ReadUInt32();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                SecondsSinceMidnight = input.ReadUInt32();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      ///
      /// \brief Description of a cloud layer.
      /// </summary>
      public sealed partial class CloudLayer : pb::IMessage<CloudLayer>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<CloudLayer> _parser = new pb::MessageParser<CloudLayer>(() => new CloudLayer());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<CloudLayer> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Osi3.EnvironmentalConditions.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CloudLayer() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CloudLayer(CloudLayer other) : this() {
          fractionalCloudCover_ = other.fractionalCloudCover_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CloudLayer Clone() {
          return new CloudLayer(this);
        }

        /// <summary>Field number for the "fractional_cloud_cover" field.</summary>
        public const int FractionalCloudCoverFieldNumber = 1;
        private global::Osi3.EnvironmentalConditions.Types.CloudLayer.Types.FractionalCloudCover fractionalCloudCover_ = global::Osi3.EnvironmentalConditions.Types.CloudLayer.Types.FractionalCloudCover.Unknown;
        /// <summary>
        /// Properties of a cloud layer given by fractional cloud cover levels.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Osi3.EnvironmentalConditions.Types.CloudLayer.Types.FractionalCloudCover FractionalCloudCover {
          get { return fractionalCloudCover_; }
          set {
            fractionalCloudCover_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as CloudLayer);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(CloudLayer other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (FractionalCloudCover != other.FractionalCloudCover) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (FractionalCloudCover != global::Osi3.EnvironmentalConditions.Types.CloudLayer.Types.FractionalCloudCover.Unknown) hash ^= FractionalCloudCover.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (FractionalCloudCover != global::Osi3.EnvironmentalConditions.Types.CloudLayer.Types.FractionalCloudCover.Unknown) {
            output.WriteRawTag(8);
            output.WriteEnum((int) FractionalCloudCover);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (FractionalCloudCover != global::Osi3.EnvironmentalConditions.Types.CloudLayer.Types.FractionalCloudCover.Unknown) {
            output.WriteRawTag(8);
            output.WriteEnum((int) FractionalCloudCover);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (FractionalCloudCover != global::Osi3.EnvironmentalConditions.Types.CloudLayer.Types.FractionalCloudCover.Unknown) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) FractionalCloudCover);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(CloudLayer other) {
          if (other == null) {
            return;
          }
          if (other.FractionalCloudCover != global::Osi3.EnvironmentalConditions.Types.CloudLayer.Types.FractionalCloudCover.Unknown) {
            FractionalCloudCover = other.FractionalCloudCover;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                FractionalCloudCover = (global::Osi3.EnvironmentalConditions.Types.CloudLayer.Types.FractionalCloudCover) input.ReadEnum();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                FractionalCloudCover = (global::Osi3.EnvironmentalConditions.Types.CloudLayer.Types.FractionalCloudCover) input.ReadEnum();
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the CloudLayer message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          /// <summary>
          /// Defines the fractional cloud cover [1] given by observation of total cloud amount in eights (oktas) of the sky.
          ///
          /// For visual alignment please see reference [2].
          ///
          /// The total degree of coverage indicates how much of the sky is covered with clouds altogether.
          /// 0 oktas means that there are no traces of clouds in the sky,
          /// 8 oktas means that the sky is completely covered with clouds and no sky blue can be recognized.
          ///
          /// \par References:
          /// [1] CIE engl. International Commission on Illumination. (2020). &lt;em>CIE S017:2020 ILV: Intl. Lighitng Vocabulary, 2nd edn.&lt;/em>. Retrieved March 8, 2022, from https://cie.co.at/eilvterm/17-29-116 \n
          /// [2] UBC The University of British Columbia. (2018). &lt;em>ATSC 113 Weather for Sailing, Flying &amp; Snow Sports&lt;/em>. Retrieved March 8, 2022, from https://www.eoas.ubc.ca/courses/atsc113/flying/met_concepts/01-met_concepts/01c-cloud_coverage/index.html
          /// </summary>
          public enum FractionalCloudCover {
            /// <summary>
            /// Fractional cloud cover level is unknown (must not be used in ground truth).
            /// </summary>
            [pbr::OriginalName("FRACTIONAL_CLOUD_COVER_UNKNOWN")] Unknown = 0,
            /// <summary>
            /// Other (unspecified but known) fractional cloud cover level.
            /// </summary>
            [pbr::OriginalName("FRACTIONAL_CLOUD_COVER_OTHER")] Other = 1,
            /// <summary>
            /// 0/8 of the sky is covered with clouds.
            /// </summary>
            [pbr::OriginalName("FRACTIONAL_CLOUD_COVER_ZERO_OKTAS")] ZeroOktas = 2,
            /// <summary>
            /// 1/8 of the sky is covered with clouds.
            /// </summary>
            [pbr::OriginalName("FRACTIONAL_CLOUD_COVER_ONE_OKTAS")] OneOktas = 3,
            /// <summary>
            /// 2/8 of the sky is covered with clouds.
            /// </summary>
            [pbr::OriginalName("FRACTIONAL_CLOUD_COVER_TWO_OKTAS")] TwoOktas = 4,
            /// <summary>
            /// 3/8 of the sky is covered with clouds.
            /// </summary>
            [pbr::OriginalName("FRACTIONAL_CLOUD_COVER_THREE_OKTAS")] ThreeOktas = 5,
            /// <summary>
            /// 4/8 of the sky is covered with clouds.
            /// </summary>
            [pbr::OriginalName("FRACTIONAL_CLOUD_COVER_FOUR_OKTAS")] FourOktas = 6,
            /// <summary>
            /// 5/8 of the sky is covered with clouds.
            /// </summary>
            [pbr::OriginalName("FRACTIONAL_CLOUD_COVER_FIVE_OKTAS")] FiveOktas = 7,
            /// <summary>
            /// 6/8 of the sky is covered with clouds.
            /// </summary>
            [pbr::OriginalName("FRACTIONAL_CLOUD_COVER_SIX_OKTAS")] SixOktas = 8,
            /// <summary>
            /// 7/8 of the sky is covered with clouds.
            /// </summary>
            [pbr::OriginalName("FRACTIONAL_CLOUD_COVER_SEVEN_OKTAS")] SevenOktas = 9,
            /// <summary>
            /// 8/8 of the sky is covered with clouds.
            /// </summary>
            [pbr::OriginalName("FRACTIONAL_CLOUD_COVER_EIGHT_OKTAS")] EightOktas = 10,
            /// <summary>
            /// Sky obscured, describes situations where the sky is not perceivable, e.g. in dense fog.
            /// </summary>
            [pbr::OriginalName("FRACTIONAL_CLOUD_COVER_SKY_OBSCURED")] SkyObscured = 11,
          }

        }
        #endregion

      }

      /// <summary>
      ///
      /// \brief Defines wind properties.
      /// </summary>
      public sealed partial class Wind : pb::IMessage<Wind>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Wind> _parser = new pb::MessageParser<Wind>(() => new Wind());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Wind> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Osi3.EnvironmentalConditions.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Wind() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Wind(Wind other) : this() {
          originDirection_ = other.originDirection_;
          speed_ = other.speed_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Wind Clone() {
          return new Wind(this);
        }

        /// <summary>Field number for the "origin_direction" field.</summary>
        public const int OriginDirectionFieldNumber = 1;
        private double originDirection_;
        /// <summary>
        /// The origin direction of the wind (not the target direction) in the ground/xy-plane of the
        /// world coordinate system. Corresponds to the heading/yaw angle, counted counterclockwise.
        /// 0 pointing north. If north is not explicitly defined via \c #osi3::GroundTruth::proj_string,
        /// then north is pointing in y-axis direction. The default orientation (x, y, z) is easting, northing, up [1].
        ///
        /// \note 0: north; +pi/2: west; pi: south, 3/2 pi: east.
        ///
        /// Unit: rad
        ///
        /// The preferred angular range is [0, 2pi].
        ///
        /// \par References:
        /// [1] PROJ contributors. (2019). &lt;em>PROJ coordinate transformation software library&lt;/em>. Open Source Geospatial Foundation. Retrieved January 25, 2019, from https://proj.org/usage/projections.html
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public double OriginDirection {
          get { return originDirection_; }
          set {
            originDirection_ = value;
          }
        }

        /// <summary>Field number for the "speed" field.</summary>
        public const int SpeedFieldNumber = 2;
        private double speed_;
        /// <summary>
        /// The wind speed.
        ///
        /// Unit: m/s
        ///
        /// \rules
        /// is_greater_than_or_equal_to: 0
        /// \endrules
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public double Speed {
          get { return speed_; }
          set {
            speed_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Wind);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Wind other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(OriginDirection, other.OriginDirection)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Speed, other.Speed)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (OriginDirection != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(OriginDirection);
          if (Speed != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Speed);
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (OriginDirection != 0D) {
            output.WriteRawTag(9);
            output.WriteDouble(OriginDirection);
          }
          if (Speed != 0D) {
            output.WriteRawTag(17);
            output.WriteDouble(Speed);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (OriginDirection != 0D) {
            output.WriteRawTag(9);
            output.WriteDouble(OriginDirection);
          }
          if (Speed != 0D) {
            output.WriteRawTag(17);
            output.WriteDouble(Speed);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (OriginDirection != 0D) {
            size += 1 + 8;
          }
          if (Speed != 0D) {
            size += 1 + 8;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Wind other) {
          if (other == null) {
            return;
          }
          if (other.OriginDirection != 0D) {
            OriginDirection = other.OriginDirection;
          }
          if (other.Speed != 0D) {
            Speed = other.Speed;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 9: {
                OriginDirection = input.ReadDouble();
                break;
              }
              case 17: {
                Speed = input.ReadDouble();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 9: {
                OriginDirection = input.ReadDouble();
                break;
              }
              case 17: {
                Speed = input.ReadDouble();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      ///
      /// \brief Properties of the sun.
      /// </summary>
      public sealed partial class Sun : pb::IMessage<Sun>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Sun> _parser = new pb::MessageParser<Sun>(() => new Sun());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Sun> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Osi3.EnvironmentalConditions.Descriptor.NestedTypes[3]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Sun() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Sun(Sun other) : this() {
          azimuth_ = other.azimuth_;
          elevation_ = other.elevation_;
          intensity_ = other.intensity_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Sun Clone() {
          return new Sun(this);
        }

        /// <summary>Field number for the "azimuth" field.</summary>
        public const int AzimuthFieldNumber = 1;
        private double azimuth_;
        /// <summary>
        /// Azimuth of the sun, counted counterclockwise.
        /// 0 pointing north. If north is not explicitly defined via \c #osi3::GroundTruth::proj_string,
        /// then north is pointing in y-axis direction. The default orientation (x, y, z) is easting, northing, up [1].
        /// The point of observation is defined to be the global coordinate system's origin.
        ///
        /// \note 0: north; +pi/2: west; pi: south, 3/2 pi: east.
        ///
        /// Unit: rad
        ///
        /// The preferred angular range is [0, 2pi].
        ///
        /// \par References:
        /// [1] PROJ contributors. (2019). &lt;em>PROJ coordinate transformation software library&lt;/em>. Open Source Geospatial Foundation. Retrieved January 25, 2019, from https://proj.org/usage/projections.html
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public double Azimuth {
          get { return azimuth_; }
          set {
            azimuth_ = value;
          }
        }

        /// <summary>Field number for the "elevation" field.</summary>
        public const int ElevationFieldNumber = 2;
        private double elevation_;
        /// <summary>
        /// Solar elevation angle.
        /// The elevation angle is positive when the sun is above the xy-plane, negative when
        /// the sun is below the xy-plane.
        /// The point of observation is defined to be the global coordinate system's origin.
        ///
        /// \note 0: xy-plane; +pi/2: zenith; -pi/2: nadir.
        ///
        /// Unit: rad
        ///
        /// The preferred angular range is [-pi/2, +pi/2].
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public double Elevation {
          get { return elevation_; }
          set {
            elevation_ = value;
          }
        }

        /// <summary>Field number for the "intensity" field.</summary>
        public const int IntensityFieldNumber = 3;
        private double intensity_;
        /// <summary>
        /// Illuminance of the sun, direct sunlight is around 100000 lx.
        ///
        /// Unit: lx
        ///
        /// \rules
        /// is_greater_than_or_equal_to: 0
        /// \endrules
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public double Intensity {
          get { return intensity_; }
          set {
            intensity_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Sun);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Sun other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Azimuth, other.Azimuth)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Elevation, other.Elevation)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Intensity, other.Intensity)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Azimuth != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Azimuth);
          if (Elevation != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Elevation);
          if (Intensity != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Intensity);
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Azimuth != 0D) {
            output.WriteRawTag(9);
            output.WriteDouble(Azimuth);
          }
          if (Elevation != 0D) {
            output.WriteRawTag(17);
            output.WriteDouble(Elevation);
          }
          if (Intensity != 0D) {
            output.WriteRawTag(25);
            output.WriteDouble(Intensity);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Azimuth != 0D) {
            output.WriteRawTag(9);
            output.WriteDouble(Azimuth);
          }
          if (Elevation != 0D) {
            output.WriteRawTag(17);
            output.WriteDouble(Elevation);
          }
          if (Intensity != 0D) {
            output.WriteRawTag(25);
            output.WriteDouble(Intensity);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Azimuth != 0D) {
            size += 1 + 8;
          }
          if (Elevation != 0D) {
            size += 1 + 8;
          }
          if (Intensity != 0D) {
            size += 1 + 8;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Sun other) {
          if (other == null) {
            return;
          }
          if (other.Azimuth != 0D) {
            Azimuth = other.Azimuth;
          }
          if (other.Elevation != 0D) {
            Elevation = other.Elevation;
          }
          if (other.Intensity != 0D) {
            Intensity = other.Intensity;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 9: {
                Azimuth = input.ReadDouble();
                break;
              }
              case 17: {
                Elevation = input.ReadDouble();
                break;
              }
              case 25: {
                Intensity = input.ReadDouble();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 9: {
                Azimuth = input.ReadDouble();
                break;
              }
              case 17: {
                Elevation = input.ReadDouble();
                break;
              }
              case 25: {
                Intensity = input.ReadDouble();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
