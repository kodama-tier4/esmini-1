// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: osi_lane.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Osi3 {

  /// <summary>Holder for reflection information generated from osi_lane.proto</summary>
  public static partial class OsiLaneReflection {

    #region Descriptor
    /// <summary>File descriptor for osi_lane.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static OsiLaneReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Cg5vc2lfbGFuZS5wcm90bxIEb3NpMxoQb3NpX2NvbW1vbi5wcm90byKqCwoE",
            "TGFuZRIcCgJpZBgBIAEoCzIQLm9zaTMuSWRlbnRpZmllchIxCg5jbGFzc2lm",
            "aWNhdGlvbhgCIAEoCzIZLm9zaTMuTGFuZS5DbGFzc2lmaWNhdGlvbhIxChBz",
            "b3VyY2VfcmVmZXJlbmNlGAMgAygLMhcub3NpMy5FeHRlcm5hbFJlZmVyZW5j",
            "ZRqdCgoOQ2xhc3NpZmljYXRpb24SLAoEdHlwZRgBIAEoDjIeLm9zaTMuTGFu",
            "ZS5DbGFzc2lmaWNhdGlvbi5UeXBlEhwKFGlzX2hvc3RfdmVoaWNsZV9sYW5l",
            "GAIgASgIEiIKCmNlbnRlcmxpbmUYAyADKAsyDi5vc2kzLlZlY3RvcjNkEicK",
            "H2NlbnRlcmxpbmVfaXNfZHJpdmluZ19kaXJlY3Rpb24YBCABKAgSLwoVbGVm",
            "dF9hZGphY2VudF9sYW5lX2lkGAUgAygLMhAub3NpMy5JZGVudGlmaWVyEjAK",
            "FnJpZ2h0X2FkamFjZW50X2xhbmVfaWQYBiADKAsyEC5vc2kzLklkZW50aWZp",
            "ZXISOwoMbGFuZV9wYWlyaW5nGAcgAygLMiUub3NpMy5MYW5lLkNsYXNzaWZp",
            "Y2F0aW9uLkxhbmVQYWlyaW5nEjAKFnJpZ2h0X2xhbmVfYm91bmRhcnlfaWQY",
            "CCADKAsyEC5vc2kzLklkZW50aWZpZXISLwoVbGVmdF9sYW5lX2JvdW5kYXJ5",
            "X2lkGAkgAygLMhAub3NpMy5JZGVudGlmaWVyEi8KFWZyZWVfbGFuZV9ib3Vu",
            "ZGFyeV9pZBgKIAMoCzIQLm9zaTMuSWRlbnRpZmllchI/Cg5yb2FkX2NvbmRp",
            "dGlvbhgLIAEoCzInLm9zaTMuTGFuZS5DbGFzc2lmaWNhdGlvbi5Sb2FkQ29u",
            "ZGl0aW9uEjIKB3N1YnR5cGUYDCABKA4yIS5vc2kzLkxhbmUuQ2xhc3NpZmlj",
            "YXRpb24uU3VidHlwZRqxAQoNUm9hZENvbmRpdGlvbhIbChNzdXJmYWNlX3Rl",
            "bXBlcmF0dXJlGAEgASgBEhoKEnN1cmZhY2Vfd2F0ZXJfZmlsbRgCIAEoARIe",
            "ChZzdXJmYWNlX2ZyZWV6aW5nX3BvaW50GAMgASgBEhMKC3N1cmZhY2VfaWNl",
            "GAQgASgBEhkKEXN1cmZhY2Vfcm91Z2huZXNzGAUgASgBEhcKD3N1cmZhY2Vf",
            "dGV4dHVyZRgGIAEoARpoCgtMYW5lUGFpcmluZxIsChJhbnRlY2Vzc29yX2xh",
            "bmVfaWQYASABKAsyEC5vc2kzLklkZW50aWZpZXISKwoRc3VjY2Vzc29yX2xh",
            "bmVfaWQYAiABKAsyEC5vc2kzLklkZW50aWZpZXIiZgoEVHlwZRIQCgxUWVBF",
            "X1VOS05PV04QABIOCgpUWVBFX09USEVSEAESEAoMVFlQRV9EUklWSU5HEAIS",
            "EwoPVFlQRV9OT05EUklWSU5HEAMSFQoRVFlQRV9JTlRFUlNFQ1RJT04QBCLC",
            "AgoHU3VidHlwZRITCg9TVUJUWVBFX1VOS05PV04QABIRCg1TVUJUWVBFX09U",
            "SEVSEAESEgoOU1VCVFlQRV9OT1JNQUwQAhISCg5TVUJUWVBFX0JJS0lORxAD",
            "EhQKEFNVQlRZUEVfU0lERVdBTEsQBBITCg9TVUJUWVBFX1BBUktJTkcQBRIQ",
            "CgxTVUJUWVBFX1NUT1AQBhIWChJTVUJUWVBFX1JFU1RSSUNURUQQBxISCg5T",
            "VUJUWVBFX0JPUkRFUhAIEhQKEFNVQlRZUEVfU0hPVUxERVIQCRIQCgxTVUJU",
            "WVBFX0VYSVQQChIRCg1TVUJUWVBFX0VOVFJZEAsSEgoOU1VCVFlQRV9PTlJB",
            "TVAQDBITCg9TVUJUWVBFX09GRlJBTVAQDRIaChZTVUJUWVBFX0NPTk5FQ1RJ",
            "TkdSQU1QEA4ipAkKDExhbmVCb3VuZGFyeRIcCgJpZBgBIAEoCzIQLm9zaTMu",
            "SWRlbnRpZmllchI3Cg1ib3VuZGFyeV9saW5lGAIgAygLMiAub3NpMy5MYW5l",
            "Qm91bmRhcnkuQm91bmRhcnlQb2ludBI5Cg5jbGFzc2lmaWNhdGlvbhgDIAEo",
            "CzIhLm9zaTMuTGFuZUJvdW5kYXJ5LkNsYXNzaWZpY2F0aW9uEjEKEHNvdXJj",
            "ZV9yZWZlcmVuY2UYBCADKAsyFy5vc2kzLkV4dGVybmFsUmVmZXJlbmNlEjEK",
            "EWNvbG9yX2Rlc2NyaXB0aW9uGAUgASgLMhYub3NpMy5Db2xvckRlc2NyaXB0",
            "aW9uGu4BCg1Cb3VuZGFyeVBvaW50EiAKCHBvc2l0aW9uGAEgASgLMg4ub3Np",
            "My5WZWN0b3IzZBINCgV3aWR0aBgCIAEoARIOCgZoZWlnaHQYAyABKAESMwoE",
            "ZGFzaBgEIAEoDjIlLm9zaTMuTGFuZUJvdW5kYXJ5LkJvdW5kYXJ5UG9pbnQu",
            "RGFzaCJnCgREYXNoEhAKDERBU0hfVU5LTk9XThAAEg4KCkRBU0hfT1RIRVIQ",
            "ARIOCgpEQVNIX1NUQVJUEAISEQoNREFTSF9DT05USU5VRRADEgwKCERBU0hf",
            "RU5EEAQSDAoIREFTSF9HQVAQBRqqBQoOQ2xhc3NpZmljYXRpb24SNAoEdHlw",
            "ZRgBIAEoDjImLm9zaTMuTGFuZUJvdW5kYXJ5LkNsYXNzaWZpY2F0aW9uLlR5",
            "cGUSNgoFY29sb3IYAiABKA4yJy5vc2kzLkxhbmVCb3VuZGFyeS5DbGFzc2lm",
            "aWNhdGlvbi5Db2xvchIvChVsaW1pdGluZ19zdHJ1Y3R1cmVfaWQYAyADKAsy",
            "EC5vc2kzLklkZW50aWZpZXIiwwIKBFR5cGUSEAoMVFlQRV9VTktOT1dOEAAS",
            "DgoKVFlQRV9PVEhFUhABEhAKDFRZUEVfTk9fTElORRACEhMKD1RZUEVfU09M",
            "SURfTElORRADEhQKEFRZUEVfREFTSEVEX0xJTkUQBBITCg9UWVBFX0JPVFRT",
            "X0RPVFMQBRISCg5UWVBFX1JPQURfRURHRRAGEhIKDlRZUEVfU05PV19FREdF",
            "EAcSEwoPVFlQRV9HUkFTU19FREdFEAgSFAoQVFlQRV9HUkFWRUxfRURHRRAJ",
            "EhIKDlRZUEVfU09JTF9FREdFEAoSEwoPVFlQRV9HVUFSRF9SQUlMEAsSDQoJ",
            "VFlQRV9DVVJCEAwSEgoOVFlQRV9TVFJVQ1RVUkUQDRIQCgxUWVBFX0JBUlJJ",
            "RVIQDhIWChJUWVBFX1NPVU5EX0JBUlJJRVIQDyKyAQoFQ29sb3ISEQoNQ09M",
            "T1JfVU5LTk9XThAAEg8KC0NPTE9SX09USEVSEAESDgoKQ09MT1JfTk9ORRAC",
            "Eg8KC0NPTE9SX1dISVRFEAMSEAoMQ09MT1JfWUVMTE9XEAQSDQoJQ09MT1Jf",
            "UkVEEAUSDgoKQ09MT1JfQkxVRRAGEg8KC0NPTE9SX0dSRUVOEAcSEAoMQ09M",
            "T1JfVklPTEVUEAgSEAoMQ09MT1JfT1JBTkdFEAlCAkgBYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Osi3.OsiCommonReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Osi3.Lane), global::Osi3.Lane.Parser, new[]{ "Id", "Classification", "SourceReference" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Osi3.Lane.Types.Classification), global::Osi3.Lane.Types.Classification.Parser, new[]{ "Type", "IsHostVehicleLane", "Centerline", "CenterlineIsDrivingDirection", "LeftAdjacentLaneId", "RightAdjacentLaneId", "LanePairing", "RightLaneBoundaryId", "LeftLaneBoundaryId", "FreeLaneBoundaryId", "RoadCondition", "Subtype" }, null, new[]{ typeof(global::Osi3.Lane.Types.Classification.Types.Type), typeof(global::Osi3.Lane.Types.Classification.Types.Subtype) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Osi3.Lane.Types.Classification.Types.RoadCondition), global::Osi3.Lane.Types.Classification.Types.RoadCondition.Parser, new[]{ "SurfaceTemperature", "SurfaceWaterFilm", "SurfaceFreezingPoint", "SurfaceIce", "SurfaceRoughness", "SurfaceTexture" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Osi3.Lane.Types.Classification.Types.LanePairing), global::Osi3.Lane.Types.Classification.Types.LanePairing.Parser, new[]{ "AntecessorLaneId", "SuccessorLaneId" }, null, null, null, null)})}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Osi3.LaneBoundary), global::Osi3.LaneBoundary.Parser, new[]{ "Id", "BoundaryLine", "Classification", "SourceReference", "ColorDescription" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Osi3.LaneBoundary.Types.BoundaryPoint), global::Osi3.LaneBoundary.Types.BoundaryPoint.Parser, new[]{ "Position", "Width", "Height", "Dash" }, null, new[]{ typeof(global::Osi3.LaneBoundary.Types.BoundaryPoint.Types.Dash) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Osi3.LaneBoundary.Types.Classification), global::Osi3.LaneBoundary.Types.Classification.Parser, new[]{ "Type", "Color", "LimitingStructureId" }, null, new[]{ typeof(global::Osi3.LaneBoundary.Types.Classification.Types.Type), typeof(global::Osi3.LaneBoundary.Types.Classification.Types.Color) }, null, null)})
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  ///
  /// \brief A lane in the road network.
  ///
  /// A lane is part of a road and mainly characterized by its center line. It also
  /// knows about any adjacent lanes, antecessor and successor lanes.
  /// The following images will be referred to by later comments. The lane
  /// l4 in image HighwayExit is used  as reference if not mentioned otherwise.
  ///
  /// &lt;table border=0>
  /// &lt;tr>
  /// &lt;td>
  /// \image html OSI_Highway_Exit.svg "" width=550px
  /// &lt;td>
  /// \image html OSI_LaneIntersection.svg "" width=550px
  /// &lt;tr>
  /// &lt;td>
  /// \image html OSI_Highway_Exit.jpg "HighwayExit" width=650px
  /// &lt;td>
  /// \image html OSI_LaneIntersection.jpg "Intersection" width=650px
  /// &lt;/table>
  ///
  /// \note In the examples, the symbols l1, l2, ... and lb1, lb2, ...
  /// stand for the lane ids and lane boundary ids respectively, i.e. for
  /// integers (uint64). The symbols cl1, cl2, ... represent the
  /// osi3::Lane::Classification::centerline elements of the lanes with
  /// the respective ids.
  /// </summary>
  public sealed partial class Lane : pb::IMessage<Lane>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Lane> _parser = new pb::MessageParser<Lane>(() => new Lane());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Lane> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Osi3.OsiLaneReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Lane() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Lane(Lane other) : this() {
      id_ = other.id_ != null ? other.id_.Clone() : null;
      classification_ = other.classification_ != null ? other.classification_.Clone() : null;
      sourceReference_ = other.sourceReference_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Lane Clone() {
      return new Lane(this);
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private global::Osi3.Identifier id_;
    /// <summary>
    /// The ID of the lane.
    /// Example: l4 (see reference picture HighwayExit).
    ///
    /// \note Note ID is global unique.
    ///
    /// \rules
    /// is_globally_unique
    /// \endrules
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.Identifier Id {
      get { return id_; }
      set {
        id_ = value;
      }
    }

    /// <summary>Field number for the "classification" field.</summary>
    public const int ClassificationFieldNumber = 2;
    private global::Osi3.Lane.Types.Classification classification_;
    /// <summary>
    /// The classification of the lane.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.Lane.Types.Classification Classification {
      get { return classification_; }
      set {
        classification_ = value;
      }
    }

    /// <summary>Field number for the "source_reference" field.</summary>
    public const int SourceReferenceFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Osi3.ExternalReference> _repeated_sourceReference_codec
        = pb::FieldCodec.ForMessage(26, global::Osi3.ExternalReference.Parser);
    private readonly pbc::RepeatedField<global::Osi3.ExternalReference> sourceReference_ = new pbc::RepeatedField<global::Osi3.ExternalReference>();
    /// <summary>
    /// Optional external reference to the lane source.
    ///
    /// The external reference points to the source of the lane, if it is derived
    /// from one or more objects or external references.
    ///
    /// For example, to reference a lane defined in an OpenDRIVE map
    /// the items should be set as follows:
    /// * reference = URI to map, can remain empty if identical with definiton
    ///               in \c GroundTruth::map_reference
    /// * type = "net.asam.opendrive"
    /// * identifier[0] = id of t_road
    /// * identifier[1] = s of t_road_lanes_laneSection
    /// * identifier[2] = id of t_road_lanes_laneSection_left_lane,
    ///                         t_road_lanes_laneSection_right_lane
    ///
    /// \note For non-ASAM Standards, it is implementation-specific how
    ///       source_reference is resolved.
    ///
    /// \note The value has to be repeated, because one lane segment may be
    ///       derived from more than one origin segment. Multiple sources
    ///       may be added as reference as well, for example, a map and sensors.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Osi3.ExternalReference> SourceReference {
      get { return sourceReference_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Lane);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Lane other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Id, other.Id)) return false;
      if (!object.Equals(Classification, other.Classification)) return false;
      if(!sourceReference_.Equals(other.sourceReference_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (id_ != null) hash ^= Id.GetHashCode();
      if (classification_ != null) hash ^= Classification.GetHashCode();
      hash ^= sourceReference_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (id_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Id);
      }
      if (classification_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Classification);
      }
      sourceReference_.WriteTo(output, _repeated_sourceReference_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (id_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Id);
      }
      if (classification_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Classification);
      }
      sourceReference_.WriteTo(ref output, _repeated_sourceReference_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (id_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Id);
      }
      if (classification_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Classification);
      }
      size += sourceReference_.CalculateSize(_repeated_sourceReference_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Lane other) {
      if (other == null) {
        return;
      }
      if (other.id_ != null) {
        if (id_ == null) {
          Id = new global::Osi3.Identifier();
        }
        Id.MergeFrom(other.Id);
      }
      if (other.classification_ != null) {
        if (classification_ == null) {
          Classification = new global::Osi3.Lane.Types.Classification();
        }
        Classification.MergeFrom(other.Classification);
      }
      sourceReference_.Add(other.sourceReference_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (id_ == null) {
              Id = new global::Osi3.Identifier();
            }
            input.ReadMessage(Id);
            break;
          }
          case 18: {
            if (classification_ == null) {
              Classification = new global::Osi3.Lane.Types.Classification();
            }
            input.ReadMessage(Classification);
            break;
          }
          case 26: {
            sourceReference_.AddEntriesFrom(input, _repeated_sourceReference_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (id_ == null) {
              Id = new global::Osi3.Identifier();
            }
            input.ReadMessage(Id);
            break;
          }
          case 18: {
            if (classification_ == null) {
              Classification = new global::Osi3.Lane.Types.Classification();
            }
            input.ReadMessage(Classification);
            break;
          }
          case 26: {
            sourceReference_.AddEntriesFrom(ref input, _repeated_sourceReference_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the Lane message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      ///
      /// \brief \c Classification of a lane.
      ///
      /// &lt;table border = 0>
      /// &lt;tr>
      /// &lt;td>
      /// \anchor HighwayExit
      /// \image html OSI_LaneClassification.jpg "HighwayExit" width=800px
      /// &lt;/td>
      /// &lt;td>
      /// &lt;table border=0>
      /// &lt;tr>
      /// &lt;td>
      /// &lt;b>
      /// \c Classification for lane l4 in image HighwayExit:
      /// &lt;/b>
      /// &lt;tr>
      /// &lt;td>
      /// \c #type = \c #TYPE_DRIVING
      /// &lt;tr>
      /// &lt;td>
      /// \c #centerline = (cl4_1, cl4_2, cl4_3, cl4_4, cl4_5)
      /// &lt;tr>
      /// &lt;td>
      /// \c #centerline_is_driving_direction = \c true
      /// &lt;tr>
      /// &lt;td>
      /// \c #is_host_vehicle_lane = \c true
      /// &lt;tr>
      /// &lt;td>
      /// \c #left_adjacent_lane_id = l3
      /// &lt;tr>
      /// &lt;td>
      /// \c #right_adjacent_lane_id  = (l5,l6)
      /// &lt;tr>
      /// &lt;td>
      /// \c #left_lane_boundary_id = lb5
      /// &lt;tr>
      /// &lt;td>
      /// \c #right_lane_boundary_id = (lb9, lb6)
      /// &lt;/table>
      /// &lt;/td>
      /// &lt;/tr>
      /// &lt;tr>
      /// &lt;td>
      /// \anchor Intersection
      /// \image html OSI_LaneIntersection.jpg "Intersection" width=800px
      /// &lt;/td>
      /// &lt;td>
      /// &lt;table border=0>
      /// &lt;tr>
      /// &lt;td>
      /// &lt;b>
      /// \c Classification for lane l7 in image Intersection:
      /// &lt;/b>
      /// &lt;/td>
      /// &lt;/tr>
      /// &lt;tr>
      /// &lt;td>
      /// \c #type = \c #TYPE_INTERSECTION
      /// &lt;/td>
      /// &lt;/tr>
      /// &lt;tr>
      /// &lt;td>
      /// \c #is_host_vehicle_lane = \c false
      /// &lt;/td>
      /// &lt;/tr>
      /// &lt;tr>
      /// &lt;td>
      /// \c #free_lane_boundary_id = lb11
      /// &lt;/td>
      /// &lt;/tr>
      /// &lt;tr>
      /// &lt;td>
      /// &lt;border = 0>
      /// &lt;tr>
      /// &lt;td>
      /// \c #lane_pairing = (
      /// &lt;td>
      /// (l2,l1), (l2,l3), (l2,l5),
      /// &lt;tr>
      /// &lt;td>
      /// &lt;td>
      /// (l4,l1), (l4,l3), (l4,l5),
      /// &lt;tr>
      /// &lt;td>
      /// &lt;td>
      /// (l6,l1), (l6,l3), (l6,l5) )
      /// &lt;/table>
      /// &lt;/td>
      /// &lt;/tr>
      /// &lt;/table>
      /// &lt;/td>
      /// &lt;/tr>
      /// &lt;/table>
      ///
      /// \note In the examples, the symbols l1, l2, ... and lb1, lb2, ...
      /// stand for the lane ids and lane boundary ids respectively, i.e. for
      /// integers (uint64). The symbols cl1, cl2, ... represent the
      /// osi3::Lane::Classification::centerline elements of the lanes with
      /// the respective ids. The symbols cl1_1, cl1_2, ... stand for
      /// \c #osi3::Vector3d elements.
      /// </summary>
      public sealed partial class Classification : pb::IMessage<Classification>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Classification> _parser = new pb::MessageParser<Classification>(() => new Classification());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Classification> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Osi3.Lane.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Classification() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Classification(Classification other) : this() {
          type_ = other.type_;
          isHostVehicleLane_ = other.isHostVehicleLane_;
          centerline_ = other.centerline_.Clone();
          centerlineIsDrivingDirection_ = other.centerlineIsDrivingDirection_;
          leftAdjacentLaneId_ = other.leftAdjacentLaneId_.Clone();
          rightAdjacentLaneId_ = other.rightAdjacentLaneId_.Clone();
          lanePairing_ = other.lanePairing_.Clone();
          rightLaneBoundaryId_ = other.rightLaneBoundaryId_.Clone();
          leftLaneBoundaryId_ = other.leftLaneBoundaryId_.Clone();
          freeLaneBoundaryId_ = other.freeLaneBoundaryId_.Clone();
          roadCondition_ = other.roadCondition_ != null ? other.roadCondition_.Clone() : null;
          subtype_ = other.subtype_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Classification Clone() {
          return new Classification(this);
        }

        /// <summary>Field number for the "type" field.</summary>
        public const int TypeFieldNumber = 1;
        private global::Osi3.Lane.Types.Classification.Types.Type type_ = global::Osi3.Lane.Types.Classification.Types.Type.Unknown;
        /// <summary>
        /// The type of the lane.
        ///
        /// Example: For l4 in image \ref HighwayExit the \c #type is \c
        /// #TYPE_DRIVING.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Osi3.Lane.Types.Classification.Types.Type Type {
          get { return type_; }
          set {
            type_ = value;
          }
        }

        /// <summary>Field number for the "is_host_vehicle_lane" field.</summary>
        public const int IsHostVehicleLaneFieldNumber = 2;
        private bool isHostVehicleLane_;
        /// <summary>
        /// Indicates that the host vehicle travels on this particular lane.
        /// The host vehicle may travel on more than one lane at once. This does
        /// also apply for the \c CanditateLane in the \c DetectedLane .
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool IsHostVehicleLane {
          get { return isHostVehicleLane_; }
          set {
            isHostVehicleLane_ = value;
          }
        }

        /// <summary>Field number for the "centerline" field.</summary>
        public const int CenterlineFieldNumber = 3;
        private static readonly pb::FieldCodec<global::Osi3.Vector3d> _repeated_centerline_codec
            = pb::FieldCodec.ForMessage(26, global::Osi3.Vector3d.Parser);
        private readonly pbc::RepeatedField<global::Osi3.Vector3d> centerline_ = new pbc::RepeatedField<global::Osi3.Vector3d>();
        /// <summary>
        /// The lane's center line (as a list of segments).
        ///
        /// The centerline describes the middle of the lane.
        ///
        /// \image html OSI_LaneCenterline.svg "Centerline" width=500px
        ///
        /// Example: In image \ref HighwayExit,
        /// the centerline of lane l4 (black line) is given by
        /// (cl4_1, cl4_2, cl4_3, cl4_4, cl4_5).
        ///
        /// \image html OSI_LaneBoundaries_And_CenterLine.svg "Centerline" width=500px
        ///
        /// \note 
        /// cl: center line
        /// lb: lane boundary
        ///
        /// \attention The points desribing the center line must be set in the 
        /// same ordering (ascending or descending) as the points desribing the 
        /// lane boundaries. Example: If the points are deducted from a map format, 
        /// the order of points is recommended to be in line with the road coordinate 
        /// (e.g. s-coordinate in OpenDRIVE). 
        ///
        /// \attention The points describing the center line might be set at
        /// arbitrary distances. When the points are pairwise linearly connected,
        /// the lateral distance to the real ideal line (as used by the
        /// simulation environment internally) must not exceed 5cm. As shown in
        /// the following image:
        ///
        /// \image html line_approximation_error.svg "Approximation error"
        /// Approximation error green line.
        ///
        /// \note The center line is the line that a typical vehicle follows more
        /// or less (depending on the situation, a little more to the left or
        /// right of the center line). The intended direction of travel on the
        /// lane is given by the direction defined by the sequence of points
        /// forming the \c #centerline w.r.t. \c
        /// #centerline_is_driving_direction.
        ///
        /// \note The \c #centerline is defined only for \c #type =
        /// \c #TYPE_DRIVING and if exactly one or no \c #lane_pairing pair
        /// exists.
        ///
        /// \note Intersections and non-driving lanes do not have a center line.
        /// A vehicle must calculate this individually and depending on the
        /// situation.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Osi3.Vector3d> Centerline {
          get { return centerline_; }
        }

        /// <summary>Field number for the "centerline_is_driving_direction" field.</summary>
        public const int CenterlineIsDrivingDirectionFieldNumber = 4;
        private bool centerlineIsDrivingDirection_;
        /// <summary>
        /// Definition of the intended driving direction.
        ///
        /// Defined and used for driving lanes.
        /// \c true means driving direction is according to ascending storage
        /// order of center line points. \c false means driving direction is
        /// according to descending storage order of center line points.
        ///
        /// Example: \c #centerline_is_driving_direction = \c true for lane l4
        /// and \c #centerline_is_driving_direction = \c false for lane l2 in
        /// image \ref HighwayExit .
        ///
        /// \note The \c #centerline_is_driving_direction is defined for \c #type
        /// = \c #TYPE_DRIVING .
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool CenterlineIsDrivingDirection {
          get { return centerlineIsDrivingDirection_; }
          set {
            centerlineIsDrivingDirection_ = value;
          }
        }

        /// <summary>Field number for the "left_adjacent_lane_id" field.</summary>
        public const int LeftAdjacentLaneIdFieldNumber = 5;
        private static readonly pb::FieldCodec<global::Osi3.Identifier> _repeated_leftAdjacentLaneId_codec
            = pb::FieldCodec.ForMessage(42, global::Osi3.Identifier.Parser);
        private readonly pbc::RepeatedField<global::Osi3.Identifier> leftAdjacentLaneId_ = new pbc::RepeatedField<global::Osi3.Identifier>();
        /// <summary>
        /// List of IDs of all lane segments that are directly adjacent to the
        /// lane on the left side (w.r.t. ascending order of centerline points
        /// and lane boundary points). Note that lengths of lane segments are 
        /// not synchronized and therefore there are multiple adjacent segments 
        /// if there is a split/merge point in the adjacent lane.
        ///
        /// Example: The lane l3 is the only left adjacent lane for lane l4
        /// in image \ref HighwayExit.
        ///
        /// \note The \c #left_adjacent_lane_id is undefined for \c #type =
        /// \c #TYPE_INTERSECTION .
        ///
        /// \note OSI uses singular instead of plural for repeated field names.
        ///
        /// \rules
        /// check_if this.type is_different_to 4 else do_check is_set
        /// \endrules
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Osi3.Identifier> LeftAdjacentLaneId {
          get { return leftAdjacentLaneId_; }
        }

        /// <summary>Field number for the "right_adjacent_lane_id" field.</summary>
        public const int RightAdjacentLaneIdFieldNumber = 6;
        private static readonly pb::FieldCodec<global::Osi3.Identifier> _repeated_rightAdjacentLaneId_codec
            = pb::FieldCodec.ForMessage(50, global::Osi3.Identifier.Parser);
        private readonly pbc::RepeatedField<global::Osi3.Identifier> rightAdjacentLaneId_ = new pbc::RepeatedField<global::Osi3.Identifier>();
        /// <summary>
        /// List of IDs of all lane segments that are directly adjacent to the
        /// lane on the right side (w.r.t. ascending order of centerline points
        /// and lane boundary points). Note that lengths of lane segments are 
        /// not synchronized and therefore there are multiple adjacent segments 
        /// if there is a split/merge point in the adjacent lane.
        ///
        /// Example: \c #right_adjacent_lane_id = (l5, l6)
        /// for lane l4 in image \ref HighwayExit.
        ///
        /// \note The \c #right_adjacent_lane_id is undefined for \c #type =
        /// \c #TYPE_INTERSECTION .
        ///
        /// \note OSI uses singular instead of plural for repeated field names.
        ///
        /// \rules
        /// check_if this.type is_different_to 4 else do_check is_set
        /// \endrules
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Osi3.Identifier> RightAdjacentLaneId {
          get { return rightAdjacentLaneId_; }
        }

        /// <summary>Field number for the "lane_pairing" field.</summary>
        public const int LanePairingFieldNumber = 7;
        private static readonly pb::FieldCodec<global::Osi3.Lane.Types.Classification.Types.LanePairing> _repeated_lanePairing_codec
            = pb::FieldCodec.ForMessage(58, global::Osi3.Lane.Types.Classification.Types.LanePairing.Parser);
        private readonly pbc::RepeatedField<global::Osi3.Lane.Types.Classification.Types.LanePairing> lanePairing_ = new pbc::RepeatedField<global::Osi3.Lane.Types.Classification.Types.LanePairing>();
        /// <summary>
        /// The antecessor/successor lane pairings of this lane. There can be
        /// multiple pairings with the same antecessor and different successor
        /// lanes and vice versa. The antecessor lanes end in the same point that
        /// this lane starts from. The successor lanes start in the same point
        /// that this lane ends in.
        ///
        /// Example: See image \ref Intersection.
        ///
        /// \note OSI uses singular instead of plural for repeated field names.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Osi3.Lane.Types.Classification.Types.LanePairing> LanePairing {
          get { return lanePairing_; }
        }

        /// <summary>Field number for the "right_lane_boundary_id" field.</summary>
        public const int RightLaneBoundaryIdFieldNumber = 8;
        private static readonly pb::FieldCodec<global::Osi3.Identifier> _repeated_rightLaneBoundaryId_codec
            = pb::FieldCodec.ForMessage(66, global::Osi3.Identifier.Parser);
        private readonly pbc::RepeatedField<global::Osi3.Identifier> rightLaneBoundaryId_ = new pbc::RepeatedField<global::Osi3.Identifier>();
        /// <summary>
        /// The right adjacent lane boundaries \c #right_lane_boundary_id may
        /// only be shared with/as the left adjacent lane boundaries \c
        /// #left_lane_boundary_id of the nearest right adjacent lane \c
        /// #right_adjacent_lane_id.
        ///
        /// Example: \c #right_lane_boundary_id =
        /// (lb9, lb6) for reference lane l4 in image \ref HighwayExit.
        ///
        /// \note Empty for intersections.
        ///
        /// \note The \c #right_lane_boundary_id is undefined for \c #type =
        /// \c #TYPE_INTERSECTION .
        ///
        /// \note OSI uses singular instead of plural for repeated field names.
        ///
        /// \note The boundary between adjacent lanes at different heights
        ///       (e.g. a curb between a driving lane and a sidewalk)
        ///       should not be shared, but modeled as two separate lane
        ///       boundaries with individual ids. One for the upper, the
        ///       other one for the lower lane.
        ///
        /// \rules
        /// check_if this.type is_different_to 4 else do_check is_set
        /// \endrules
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Osi3.Identifier> RightLaneBoundaryId {
          get { return rightLaneBoundaryId_; }
        }

        /// <summary>Field number for the "left_lane_boundary_id" field.</summary>
        public const int LeftLaneBoundaryIdFieldNumber = 9;
        private static readonly pb::FieldCodec<global::Osi3.Identifier> _repeated_leftLaneBoundaryId_codec
            = pb::FieldCodec.ForMessage(74, global::Osi3.Identifier.Parser);
        private readonly pbc::RepeatedField<global::Osi3.Identifier> leftLaneBoundaryId_ = new pbc::RepeatedField<global::Osi3.Identifier>();
        /// <summary>
        /// The left adjacent lane boundaries \c #left_lane_boundary_id may only
        /// be shared with/as the right adjacent lane boundaries \c
        /// #right_lane_boundary_id of the nearest left adjacent lane \c
        /// #left_adjacent_lane_id.
        ///
        /// Example: \c #left_lane_boundary_id = lb5 for lane l4 in image \ref
        /// HighwayExit.
        ///
        /// \note Empty for intersections.
        ///
        /// \note The \c #left_lane_boundary_id is undefined for \c #type =
        /// \c #TYPE_INTERSECTION .
        ///
        /// \note OSI uses singular instead of plural for repeated field names.
        ///
        /// \note The boundary between adjacent lanes at different heights
        ///       (e.g. a curb between a driving lane and a sidewalk)
        ///       should not be shared, but modeled as two separate lane
        ///       boundaries with individual ids. One for the upper, the
        ///       other one for the lower lane.
        ///
        /// \rules
        /// check_if this.type is_different_to 4 else do_check is_set
        /// \endrules
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Osi3.Identifier> LeftLaneBoundaryId {
          get { return leftLaneBoundaryId_; }
        }

        /// <summary>Field number for the "free_lane_boundary_id" field.</summary>
        public const int FreeLaneBoundaryIdFieldNumber = 10;
        private static readonly pb::FieldCodec<global::Osi3.Identifier> _repeated_freeLaneBoundaryId_codec
            = pb::FieldCodec.ForMessage(82, global::Osi3.Identifier.Parser);
        private readonly pbc::RepeatedField<global::Osi3.Identifier> freeLaneBoundaryId_ = new pbc::RepeatedField<global::Osi3.Identifier>();
        /// <summary>
        /// The free boundaries which have no/unknown assignment to left/right.
        ///
        /// Example: \c #free_lane_boundary_id = lb11 for lane l7 in image \ref
        /// Intersection.
        ///
        /// \note \c Lane with \c #type = \c #TYPE_INTERSECTION use only free
        /// lane boundaries.
        ///
        /// \note OSI uses singular instead of plural for repeated field names.
        ///
        /// \rules
        /// check_if this.type is_different_to 4 else do_check is_set
        /// \endrules
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Osi3.Identifier> FreeLaneBoundaryId {
          get { return freeLaneBoundaryId_; }
        }

        /// <summary>Field number for the "road_condition" field.</summary>
        public const int RoadConditionFieldNumber = 11;
        private global::Osi3.Lane.Types.Classification.Types.RoadCondition roadCondition_;
        /// <summary>
        /// The condition of the lane, e.g. influenced by weather.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Osi3.Lane.Types.Classification.Types.RoadCondition RoadCondition {
          get { return roadCondition_; }
          set {
            roadCondition_ = value;
          }
        }

        /// <summary>Field number for the "subtype" field.</summary>
        public const int SubtypeFieldNumber = 12;
        private global::Osi3.Lane.Types.Classification.Types.Subtype subtype_ = global::Osi3.Lane.Types.Classification.Types.Subtype.Unknown;
        /// <summary>
        /// The subtype of the lane. 
        /// 
        /// This subtype specifies a lane more concretely.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Osi3.Lane.Types.Classification.Types.Subtype Subtype {
          get { return subtype_; }
          set {
            subtype_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Classification);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Classification other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Type != other.Type) return false;
          if (IsHostVehicleLane != other.IsHostVehicleLane) return false;
          if(!centerline_.Equals(other.centerline_)) return false;
          if (CenterlineIsDrivingDirection != other.CenterlineIsDrivingDirection) return false;
          if(!leftAdjacentLaneId_.Equals(other.leftAdjacentLaneId_)) return false;
          if(!rightAdjacentLaneId_.Equals(other.rightAdjacentLaneId_)) return false;
          if(!lanePairing_.Equals(other.lanePairing_)) return false;
          if(!rightLaneBoundaryId_.Equals(other.rightLaneBoundaryId_)) return false;
          if(!leftLaneBoundaryId_.Equals(other.leftLaneBoundaryId_)) return false;
          if(!freeLaneBoundaryId_.Equals(other.freeLaneBoundaryId_)) return false;
          if (!object.Equals(RoadCondition, other.RoadCondition)) return false;
          if (Subtype != other.Subtype) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Type != global::Osi3.Lane.Types.Classification.Types.Type.Unknown) hash ^= Type.GetHashCode();
          if (IsHostVehicleLane != false) hash ^= IsHostVehicleLane.GetHashCode();
          hash ^= centerline_.GetHashCode();
          if (CenterlineIsDrivingDirection != false) hash ^= CenterlineIsDrivingDirection.GetHashCode();
          hash ^= leftAdjacentLaneId_.GetHashCode();
          hash ^= rightAdjacentLaneId_.GetHashCode();
          hash ^= lanePairing_.GetHashCode();
          hash ^= rightLaneBoundaryId_.GetHashCode();
          hash ^= leftLaneBoundaryId_.GetHashCode();
          hash ^= freeLaneBoundaryId_.GetHashCode();
          if (roadCondition_ != null) hash ^= RoadCondition.GetHashCode();
          if (Subtype != global::Osi3.Lane.Types.Classification.Types.Subtype.Unknown) hash ^= Subtype.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Type != global::Osi3.Lane.Types.Classification.Types.Type.Unknown) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Type);
          }
          if (IsHostVehicleLane != false) {
            output.WriteRawTag(16);
            output.WriteBool(IsHostVehicleLane);
          }
          centerline_.WriteTo(output, _repeated_centerline_codec);
          if (CenterlineIsDrivingDirection != false) {
            output.WriteRawTag(32);
            output.WriteBool(CenterlineIsDrivingDirection);
          }
          leftAdjacentLaneId_.WriteTo(output, _repeated_leftAdjacentLaneId_codec);
          rightAdjacentLaneId_.WriteTo(output, _repeated_rightAdjacentLaneId_codec);
          lanePairing_.WriteTo(output, _repeated_lanePairing_codec);
          rightLaneBoundaryId_.WriteTo(output, _repeated_rightLaneBoundaryId_codec);
          leftLaneBoundaryId_.WriteTo(output, _repeated_leftLaneBoundaryId_codec);
          freeLaneBoundaryId_.WriteTo(output, _repeated_freeLaneBoundaryId_codec);
          if (roadCondition_ != null) {
            output.WriteRawTag(90);
            output.WriteMessage(RoadCondition);
          }
          if (Subtype != global::Osi3.Lane.Types.Classification.Types.Subtype.Unknown) {
            output.WriteRawTag(96);
            output.WriteEnum((int) Subtype);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Type != global::Osi3.Lane.Types.Classification.Types.Type.Unknown) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Type);
          }
          if (IsHostVehicleLane != false) {
            output.WriteRawTag(16);
            output.WriteBool(IsHostVehicleLane);
          }
          centerline_.WriteTo(ref output, _repeated_centerline_codec);
          if (CenterlineIsDrivingDirection != false) {
            output.WriteRawTag(32);
            output.WriteBool(CenterlineIsDrivingDirection);
          }
          leftAdjacentLaneId_.WriteTo(ref output, _repeated_leftAdjacentLaneId_codec);
          rightAdjacentLaneId_.WriteTo(ref output, _repeated_rightAdjacentLaneId_codec);
          lanePairing_.WriteTo(ref output, _repeated_lanePairing_codec);
          rightLaneBoundaryId_.WriteTo(ref output, _repeated_rightLaneBoundaryId_codec);
          leftLaneBoundaryId_.WriteTo(ref output, _repeated_leftLaneBoundaryId_codec);
          freeLaneBoundaryId_.WriteTo(ref output, _repeated_freeLaneBoundaryId_codec);
          if (roadCondition_ != null) {
            output.WriteRawTag(90);
            output.WriteMessage(RoadCondition);
          }
          if (Subtype != global::Osi3.Lane.Types.Classification.Types.Subtype.Unknown) {
            output.WriteRawTag(96);
            output.WriteEnum((int) Subtype);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Type != global::Osi3.Lane.Types.Classification.Types.Type.Unknown) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
          }
          if (IsHostVehicleLane != false) {
            size += 1 + 1;
          }
          size += centerline_.CalculateSize(_repeated_centerline_codec);
          if (CenterlineIsDrivingDirection != false) {
            size += 1 + 1;
          }
          size += leftAdjacentLaneId_.CalculateSize(_repeated_leftAdjacentLaneId_codec);
          size += rightAdjacentLaneId_.CalculateSize(_repeated_rightAdjacentLaneId_codec);
          size += lanePairing_.CalculateSize(_repeated_lanePairing_codec);
          size += rightLaneBoundaryId_.CalculateSize(_repeated_rightLaneBoundaryId_codec);
          size += leftLaneBoundaryId_.CalculateSize(_repeated_leftLaneBoundaryId_codec);
          size += freeLaneBoundaryId_.CalculateSize(_repeated_freeLaneBoundaryId_codec);
          if (roadCondition_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(RoadCondition);
          }
          if (Subtype != global::Osi3.Lane.Types.Classification.Types.Subtype.Unknown) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Subtype);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Classification other) {
          if (other == null) {
            return;
          }
          if (other.Type != global::Osi3.Lane.Types.Classification.Types.Type.Unknown) {
            Type = other.Type;
          }
          if (other.IsHostVehicleLane != false) {
            IsHostVehicleLane = other.IsHostVehicleLane;
          }
          centerline_.Add(other.centerline_);
          if (other.CenterlineIsDrivingDirection != false) {
            CenterlineIsDrivingDirection = other.CenterlineIsDrivingDirection;
          }
          leftAdjacentLaneId_.Add(other.leftAdjacentLaneId_);
          rightAdjacentLaneId_.Add(other.rightAdjacentLaneId_);
          lanePairing_.Add(other.lanePairing_);
          rightLaneBoundaryId_.Add(other.rightLaneBoundaryId_);
          leftLaneBoundaryId_.Add(other.leftLaneBoundaryId_);
          freeLaneBoundaryId_.Add(other.freeLaneBoundaryId_);
          if (other.roadCondition_ != null) {
            if (roadCondition_ == null) {
              RoadCondition = new global::Osi3.Lane.Types.Classification.Types.RoadCondition();
            }
            RoadCondition.MergeFrom(other.RoadCondition);
          }
          if (other.Subtype != global::Osi3.Lane.Types.Classification.Types.Subtype.Unknown) {
            Subtype = other.Subtype;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Type = (global::Osi3.Lane.Types.Classification.Types.Type) input.ReadEnum();
                break;
              }
              case 16: {
                IsHostVehicleLane = input.ReadBool();
                break;
              }
              case 26: {
                centerline_.AddEntriesFrom(input, _repeated_centerline_codec);
                break;
              }
              case 32: {
                CenterlineIsDrivingDirection = input.ReadBool();
                break;
              }
              case 42: {
                leftAdjacentLaneId_.AddEntriesFrom(input, _repeated_leftAdjacentLaneId_codec);
                break;
              }
              case 50: {
                rightAdjacentLaneId_.AddEntriesFrom(input, _repeated_rightAdjacentLaneId_codec);
                break;
              }
              case 58: {
                lanePairing_.AddEntriesFrom(input, _repeated_lanePairing_codec);
                break;
              }
              case 66: {
                rightLaneBoundaryId_.AddEntriesFrom(input, _repeated_rightLaneBoundaryId_codec);
                break;
              }
              case 74: {
                leftLaneBoundaryId_.AddEntriesFrom(input, _repeated_leftLaneBoundaryId_codec);
                break;
              }
              case 82: {
                freeLaneBoundaryId_.AddEntriesFrom(input, _repeated_freeLaneBoundaryId_codec);
                break;
              }
              case 90: {
                if (roadCondition_ == null) {
                  RoadCondition = new global::Osi3.Lane.Types.Classification.Types.RoadCondition();
                }
                input.ReadMessage(RoadCondition);
                break;
              }
              case 96: {
                Subtype = (global::Osi3.Lane.Types.Classification.Types.Subtype) input.ReadEnum();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                Type = (global::Osi3.Lane.Types.Classification.Types.Type) input.ReadEnum();
                break;
              }
              case 16: {
                IsHostVehicleLane = input.ReadBool();
                break;
              }
              case 26: {
                centerline_.AddEntriesFrom(ref input, _repeated_centerline_codec);
                break;
              }
              case 32: {
                CenterlineIsDrivingDirection = input.ReadBool();
                break;
              }
              case 42: {
                leftAdjacentLaneId_.AddEntriesFrom(ref input, _repeated_leftAdjacentLaneId_codec);
                break;
              }
              case 50: {
                rightAdjacentLaneId_.AddEntriesFrom(ref input, _repeated_rightAdjacentLaneId_codec);
                break;
              }
              case 58: {
                lanePairing_.AddEntriesFrom(ref input, _repeated_lanePairing_codec);
                break;
              }
              case 66: {
                rightLaneBoundaryId_.AddEntriesFrom(ref input, _repeated_rightLaneBoundaryId_codec);
                break;
              }
              case 74: {
                leftLaneBoundaryId_.AddEntriesFrom(ref input, _repeated_leftLaneBoundaryId_codec);
                break;
              }
              case 82: {
                freeLaneBoundaryId_.AddEntriesFrom(ref input, _repeated_freeLaneBoundaryId_codec);
                break;
              }
              case 90: {
                if (roadCondition_ == null) {
                  RoadCondition = new global::Osi3.Lane.Types.Classification.Types.RoadCondition();
                }
                input.ReadMessage(RoadCondition);
                break;
              }
              case 96: {
                Subtype = (global::Osi3.Lane.Types.Classification.Types.Subtype) input.ReadEnum();
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the Classification message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          /// <summary>
          /// Definition of available lane types.
          /// </summary>
          public enum Type {
            /// <summary>
            /// Lane of unknown type (must not be used in ground truth).
            /// </summary>
            [pbr::OriginalName("TYPE_UNKNOWN")] Unknown = 0,
            /// <summary>
            /// Any other type of lane.
            /// </summary>
            [pbr::OriginalName("TYPE_OTHER")] Other = 1,
            /// <summary>
            /// A normal lane.
            /// Example: Lanes with IDs l1, l2, l3, l4 and l6 in image \ref
            /// HighwayExit.
            /// </summary>
            [pbr::OriginalName("TYPE_DRIVING")] Driving = 2,
            /// <summary>
            /// A road where driving is normally not permitted.
            /// Example: Lane with ID l5 in image \ref HighwayExit.
            /// </summary>
            [pbr::OriginalName("TYPE_NONDRIVING")] Nondriving = 3,
            /// <summary>
            /// An intersection as a lane.
            /// Example: Lane with ID l7 in image \ref Intersection.
            ///
            /// \image html OSI_X-Junction.svg "" width=600px
            /// </summary>
            [pbr::OriginalName("TYPE_INTERSECTION")] Intersection = 4,
          }

          /// <summary>
          /// Definition of available lane subtypes, aligned with OpenDRIVE.
          ///        
          /// </summary>
          public enum Subtype {
            /// <summary>
            /// Lane of unknown subtype. Do not use in ground truth.
            /// </summary>
            [pbr::OriginalName("SUBTYPE_UNKNOWN")] Unknown = 0,
            /// <summary>
            /// Any other subtype of lane.
            /// </summary>
            [pbr::OriginalName("SUBTYPE_OTHER")] Other = 1,
            /// <summary>
            /// A normal driving lane.
            /// Example: Lanes with IDs l1, l2, l3 and l4 in image \ref
            /// HighwayExit.
            ///
            /// Since it is intended to be used for normal automotive
            /// driving, it should be used in combination with TYPE_DRIVING.
            /// </summary>
            [pbr::OriginalName("SUBTYPE_NORMAL")] Normal = 2,
            /// <summary>
            /// A lane that is designated for bicylists.
            ///
            /// Since it is not intended to be used for normal automotive
            /// driving, it should be used in combination with TYPE_NONDRIVING.
            /// </summary>
            [pbr::OriginalName("SUBTYPE_BIKING")] Biking = 3,
            /// <summary>
            /// A lane that is designated for pedestrians (sidewalk).
            ///
            /// Since it is not intended to be used for normal automotive
            /// driving, it should be used in combination with TYPE_NONDRIVING.
            /// </summary>
            [pbr::OriginalName("SUBTYPE_SIDEWALK")] Sidewalk = 4,
            /// <summary>
            /// A lane with parking spaces.
            ///
            /// Since it is not intended to be used for normal automotive
            /// driving, it should be used in combination with TYPE_NONDRIVING.
            /// </summary>
            [pbr::OriginalName("SUBTYPE_PARKING")] Parking = 5,
            /// <summary>
            /// A hard shoulder on motorways for emergency stops.
            /// Example: Lane l5 in image \ref
            /// HighwayExit.
            ///
            /// Since it is not intended to be used for normal automotive
            /// driving, it should be used in combination with TYPE_NONDRIVING.
            /// </summary>
            [pbr::OriginalName("SUBTYPE_STOP")] Stop = 6,
            /// <summary>
            /// A lane on which cars should not drive.
            ///
            /// Since it is not intended to be used for normal automotive
            /// driving, it should be used in combination with TYPE_NONDRIVING.
            /// </summary>
            [pbr::OriginalName("SUBTYPE_RESTRICTED")] Restricted = 7,
            /// <summary>
            /// A hard border on the edge of a road.
            ///
            /// Since it is not intended to be used for normal automotive
            /// driving, it should be used in combination with TYPE_NONDRIVING.
            /// </summary>
            [pbr::OriginalName("SUBTYPE_BORDER")] Border = 8,
            /// <summary>
            /// A soft border on the edge of a road.
            ///
            /// Since it is not intended to be used for normal automotive
            /// driving, it should be used in combination with TYPE_NONDRIVING.
            /// </summary>
            [pbr::OriginalName("SUBTYPE_SHOULDER")] Shoulder = 9,
            /// <summary>
            /// A deceleration lane in parallel to the main road.
            /// Example: Lane l6 in image \ref
            /// HighwayExit.
            ///
            /// Since it is intended to be used for normal automotive
            /// driving, it should be used in combination with TYPE_DRIVING.
            /// </summary>
            [pbr::OriginalName("SUBTYPE_EXIT")] Exit = 10,
            /// <summary>
            /// An acceleration lane in parallel to the main road.
            ///
            /// Since it is intended to be used for normal automotive
            /// driving, it should be used in combination with TYPE_DRIVING.
            /// </summary>
            [pbr::OriginalName("SUBTYPE_ENTRY")] Entry = 11,
            /// <summary>
            /// A ramp from rural or urban roads joining a motorway.
            ///
            /// Since it is intended to be used for normal automotive
            /// driving, it should be used in combination with TYPE_DRIVING.
            /// </summary>
            [pbr::OriginalName("SUBTYPE_ONRAMP")] Onramp = 12,
            /// <summary>
            /// A ramp leading off a motorway onto rural or urban roads.
            ///
            /// Since it is intended to be used for normal automotive
            /// driving, it should be used in combination with TYPE_DRIVING.
            /// </summary>
            [pbr::OriginalName("SUBTYPE_OFFRAMP")] Offramp = 13,
            /// <summary>
            /// A ramp that connect two motorways.
            ///
            /// Since it is intended to be used for normal automotive
            /// driving, it should be used in combination with TYPE_DRIVING.
            /// </summary>
            [pbr::OriginalName("SUBTYPE_CONNECTINGRAMP")] Connectingramp = 14,
          }

          /// <summary>
          ///
          /// \brief The condition of the road surface.
          /// </summary>
          public sealed partial class RoadCondition : pb::IMessage<RoadCondition>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<RoadCondition> _parser = new pb::MessageParser<RoadCondition>(() => new RoadCondition());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<RoadCondition> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Osi3.Lane.Types.Classification.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public RoadCondition() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public RoadCondition(RoadCondition other) : this() {
              surfaceTemperature_ = other.surfaceTemperature_;
              surfaceWaterFilm_ = other.surfaceWaterFilm_;
              surfaceFreezingPoint_ = other.surfaceFreezingPoint_;
              surfaceIce_ = other.surfaceIce_;
              surfaceRoughness_ = other.surfaceRoughness_;
              surfaceTexture_ = other.surfaceTexture_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public RoadCondition Clone() {
              return new RoadCondition(this);
            }

            /// <summary>Field number for the "surface_temperature" field.</summary>
            public const int SurfaceTemperatureFieldNumber = 1;
            private double surfaceTemperature_;
            /// <summary>
            /// The temperature of the roads surface in Kelvin.
            ///
            /// Unit: K
            ///
            /// \rules
            /// is_greater_than_or_equal_to: 0
            /// \endrules
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public double SurfaceTemperature {
              get { return surfaceTemperature_; }
              set {
                surfaceTemperature_ = value;
              }
            }

            /// <summary>Field number for the "surface_water_film" field.</summary>
            public const int SurfaceWaterFilmFieldNumber = 2;
            private double surfaceWaterFilm_;
            /// <summary>
            /// The height of the water film on top of the surface in mm.
            ///
            /// Unit: mm
            ///
            /// \rules
            /// is_greater_than_or_equal_to: 0
            /// \endrules
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public double SurfaceWaterFilm {
              get { return surfaceWaterFilm_; }
              set {
                surfaceWaterFilm_ = value;
              }
            }

            /// <summary>Field number for the "surface_freezing_point" field.</summary>
            public const int SurfaceFreezingPointFieldNumber = 3;
            private double surfaceFreezingPoint_;
            /// <summary>
            /// The temperature where the water on top of the surface would start
            /// to freeze or dew in Kelvin.
            ///
            /// Unit: K
            ///
            /// \rules
            /// is_greater_than_or_equal_to: 0
            /// \endrules
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public double SurfaceFreezingPoint {
              get { return surfaceFreezingPoint_; }
              set {
                surfaceFreezingPoint_ = value;
              }
            }

            /// <summary>Field number for the "surface_ice" field.</summary>
            public const int SurfaceIceFieldNumber = 4;
            private double surfaceIce_;
            /// <summary>
            /// The percentage of ice covering the road.
            ///
            /// Unit: %
            ///
            /// \rules
            /// is_greater_than_or_equal_to: 0
            /// \endrules
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public double SurfaceIce {
              get { return surfaceIce_; }
              set {
                surfaceIce_ = value;
              }
            }

            /// <summary>Field number for the "surface_roughness" field.</summary>
            public const int SurfaceRoughnessFieldNumber = 5;
            private double surfaceRoughness_;
            /// <summary>
            /// The coefficient representing the roughness or unevenness of the
            /// road. International Roughness Index (IRI) [1] values range from 0
            /// = smooth ground (equivalent to driving on a plate of glass) up to
            /// >
            /// 20 mm/m (a very rough road).
            ///
            /// Estimated value ranges (IRI):
            /// 0.0 mm/m absolutely perfect evenness
            /// 0.3 -  1.8 mm/m airport runways and superhighways
            /// 1.4 -  3.4 mm/m new pavements
            /// 2.2 -  5.7 mm/m older pavements
            /// 3.2 -  9.8 mm/m maintained unpaved roads
            /// 4.0 - 11.0 mm/m damaged pavements
            /// 8.0 - >
            /// 20 mm/m rough unpaved roads
            ///
            /// Speed of normal use (IRI):
            /// 30 km/h - 20   mm/m
            /// 50 km/h - 14.5 mm/m
            /// 60 km/h - 10.0 mm/m
            /// 80 km/h -  8.5 mm/m
            /// 100 km/h -  3.4 mm/m
            ///
            /// Road conditions (IRI);
            /// 15 mm/m erosion gulleys and deep depressions
            /// 11 mm/m frequent shallow depressions, some deep
            /// 9 mm/m frequent minor depressions
            /// 5 mm/m surface imperfections
            ///
            /// Unit: mm/m
            ///
            /// \par Reference:
            /// [1] Sayers, M. W. &amp; Karamihas, S. M. (1998). &lt;em>Little Book of Profiling&lt;/em>. University of Michigan Transportation Research Institute. Retrieved January 25, 2020, from http://www.umtri.umich.edu/content/LittleBook98R.pdf pp. 45 ff.
            ///
            /// \rules
            /// is_greater_than_or_equal_to: 0
            /// \endrules
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public double SurfaceRoughness {
              get { return surfaceRoughness_; }
              set {
                surfaceRoughness_ = value;
              }
            }

            /// <summary>Field number for the "surface_texture" field.</summary>
            public const int SurfaceTextureFieldNumber = 6;
            private double surfaceTexture_;
            /// <summary>
            /// The surface texture or fine roughness
            ///
            /// Whereas the IRI-based roughness or unevenness measure only takes
            /// into account road wavelengths around 0.5 m - 100 m, the surface
            /// texture or fine roughness [1] measures only wavelengths below
            /// 0.5 m. It is given as the standard height deviation of fine
            /// roughness
            ///
            /// Unit: m
            ///
            /// \par Reference:
            /// [1] Schneider, R. (1998). &lt;em>Modellierung der Wellenausbreitung fuer ein bildgebendes Kfz-Radar&lt;/em>. PhD thesis. Karlsruhe, Germany. Universitaet Karlsruhe, Fak. f. Elektrotechnik.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public double SurfaceTexture {
              get { return surfaceTexture_; }
              set {
                surfaceTexture_ = value;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as RoadCondition);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(RoadCondition other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(SurfaceTemperature, other.SurfaceTemperature)) return false;
              if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(SurfaceWaterFilm, other.SurfaceWaterFilm)) return false;
              if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(SurfaceFreezingPoint, other.SurfaceFreezingPoint)) return false;
              if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(SurfaceIce, other.SurfaceIce)) return false;
              if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(SurfaceRoughness, other.SurfaceRoughness)) return false;
              if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(SurfaceTexture, other.SurfaceTexture)) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (SurfaceTemperature != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(SurfaceTemperature);
              if (SurfaceWaterFilm != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(SurfaceWaterFilm);
              if (SurfaceFreezingPoint != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(SurfaceFreezingPoint);
              if (SurfaceIce != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(SurfaceIce);
              if (SurfaceRoughness != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(SurfaceRoughness);
              if (SurfaceTexture != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(SurfaceTexture);
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (SurfaceTemperature != 0D) {
                output.WriteRawTag(9);
                output.WriteDouble(SurfaceTemperature);
              }
              if (SurfaceWaterFilm != 0D) {
                output.WriteRawTag(17);
                output.WriteDouble(SurfaceWaterFilm);
              }
              if (SurfaceFreezingPoint != 0D) {
                output.WriteRawTag(25);
                output.WriteDouble(SurfaceFreezingPoint);
              }
              if (SurfaceIce != 0D) {
                output.WriteRawTag(33);
                output.WriteDouble(SurfaceIce);
              }
              if (SurfaceRoughness != 0D) {
                output.WriteRawTag(41);
                output.WriteDouble(SurfaceRoughness);
              }
              if (SurfaceTexture != 0D) {
                output.WriteRawTag(49);
                output.WriteDouble(SurfaceTexture);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (SurfaceTemperature != 0D) {
                output.WriteRawTag(9);
                output.WriteDouble(SurfaceTemperature);
              }
              if (SurfaceWaterFilm != 0D) {
                output.WriteRawTag(17);
                output.WriteDouble(SurfaceWaterFilm);
              }
              if (SurfaceFreezingPoint != 0D) {
                output.WriteRawTag(25);
                output.WriteDouble(SurfaceFreezingPoint);
              }
              if (SurfaceIce != 0D) {
                output.WriteRawTag(33);
                output.WriteDouble(SurfaceIce);
              }
              if (SurfaceRoughness != 0D) {
                output.WriteRawTag(41);
                output.WriteDouble(SurfaceRoughness);
              }
              if (SurfaceTexture != 0D) {
                output.WriteRawTag(49);
                output.WriteDouble(SurfaceTexture);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (SurfaceTemperature != 0D) {
                size += 1 + 8;
              }
              if (SurfaceWaterFilm != 0D) {
                size += 1 + 8;
              }
              if (SurfaceFreezingPoint != 0D) {
                size += 1 + 8;
              }
              if (SurfaceIce != 0D) {
                size += 1 + 8;
              }
              if (SurfaceRoughness != 0D) {
                size += 1 + 8;
              }
              if (SurfaceTexture != 0D) {
                size += 1 + 8;
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(RoadCondition other) {
              if (other == null) {
                return;
              }
              if (other.SurfaceTemperature != 0D) {
                SurfaceTemperature = other.SurfaceTemperature;
              }
              if (other.SurfaceWaterFilm != 0D) {
                SurfaceWaterFilm = other.SurfaceWaterFilm;
              }
              if (other.SurfaceFreezingPoint != 0D) {
                SurfaceFreezingPoint = other.SurfaceFreezingPoint;
              }
              if (other.SurfaceIce != 0D) {
                SurfaceIce = other.SurfaceIce;
              }
              if (other.SurfaceRoughness != 0D) {
                SurfaceRoughness = other.SurfaceRoughness;
              }
              if (other.SurfaceTexture != 0D) {
                SurfaceTexture = other.SurfaceTexture;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 9: {
                    SurfaceTemperature = input.ReadDouble();
                    break;
                  }
                  case 17: {
                    SurfaceWaterFilm = input.ReadDouble();
                    break;
                  }
                  case 25: {
                    SurfaceFreezingPoint = input.ReadDouble();
                    break;
                  }
                  case 33: {
                    SurfaceIce = input.ReadDouble();
                    break;
                  }
                  case 41: {
                    SurfaceRoughness = input.ReadDouble();
                    break;
                  }
                  case 49: {
                    SurfaceTexture = input.ReadDouble();
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 9: {
                    SurfaceTemperature = input.ReadDouble();
                    break;
                  }
                  case 17: {
                    SurfaceWaterFilm = input.ReadDouble();
                    break;
                  }
                  case 25: {
                    SurfaceFreezingPoint = input.ReadDouble();
                    break;
                  }
                  case 33: {
                    SurfaceIce = input.ReadDouble();
                    break;
                  }
                  case 41: {
                    SurfaceRoughness = input.ReadDouble();
                    break;
                  }
                  case 49: {
                    SurfaceTexture = input.ReadDouble();
                    break;
                  }
                }
              }
            }
            #endif

          }

          /// <summary>
          /// \brief The lane ID pairings of antecessor and successor lanes.
          ///
          /// &lt;table border = 0>
          /// &lt;tr>
          /// &lt;td>
          /// \image html OSI_LaneIntersection.svg "" width=600px
          /// &lt;/td>
          /// &lt;td>
          /// &lt;table border=0>
          /// &lt;tr>
          /// &lt;td>
          /// &lt;b>
          /// \c LanePairing for lane l7:
          /// &lt;/b>
          /// &lt;/td>
          /// &lt;/tr>
          /// &lt;tr>
          /// &lt;td>
          /// &lt;table border = 0>
          /// &lt;tr>
          /// &lt;td>
          /// (l2,l1), (l2,l3), (l2,l5),
          /// &lt;tr>
          /// &lt;td>
          /// (l4,l1), (l4,l3), (l4,l5),
          /// &lt;tr>
          /// &lt;td>
          /// (l6,l1), (l6,l3), (l6,l5)
          /// &lt;/table>
          /// &lt;/td>
          /// &lt;/tr>
          /// &lt;/table>
          /// &lt;/td>
          /// &lt;/tr>
          /// &lt;/table>
          ///
          /// \note In the example, the symbols l1, l2, ... stand for the
          /// respective lane ids, i.e. for integers (uint64). The symbols cl1,
          /// cl2, ... represent the osi3::Lane::Classification::centerline
          /// elements of the lanes with the respective ids.
          /// </summary>
          public sealed partial class LanePairing : pb::IMessage<LanePairing>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<LanePairing> _parser = new pb::MessageParser<LanePairing>(() => new LanePairing());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<LanePairing> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Osi3.Lane.Types.Classification.Descriptor.NestedTypes[1]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public LanePairing() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public LanePairing(LanePairing other) : this() {
              antecessorLaneId_ = other.antecessorLaneId_ != null ? other.antecessorLaneId_.Clone() : null;
              successorLaneId_ = other.successorLaneId_ != null ? other.successorLaneId_.Clone() : null;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public LanePairing Clone() {
              return new LanePairing(this);
            }

            /// <summary>Field number for the "antecessor_lane_id" field.</summary>
            public const int AntecessorLaneIdFieldNumber = 1;
            private global::Osi3.Identifier antecessorLaneId_;
            /// <summary>
            /// The antecessor lane ID.
            ///
            /// \rules
            /// refers_to: Lane
            /// \endrules
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public global::Osi3.Identifier AntecessorLaneId {
              get { return antecessorLaneId_; }
              set {
                antecessorLaneId_ = value;
              }
            }

            /// <summary>Field number for the "successor_lane_id" field.</summary>
            public const int SuccessorLaneIdFieldNumber = 2;
            private global::Osi3.Identifier successorLaneId_;
            /// <summary>
            /// The successor lane ID.
            ///
            /// \rules
            /// refers_to: Lane
            /// \endrules
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public global::Osi3.Identifier SuccessorLaneId {
              get { return successorLaneId_; }
              set {
                successorLaneId_ = value;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as LanePairing);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(LanePairing other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (!object.Equals(AntecessorLaneId, other.AntecessorLaneId)) return false;
              if (!object.Equals(SuccessorLaneId, other.SuccessorLaneId)) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (antecessorLaneId_ != null) hash ^= AntecessorLaneId.GetHashCode();
              if (successorLaneId_ != null) hash ^= SuccessorLaneId.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (antecessorLaneId_ != null) {
                output.WriteRawTag(10);
                output.WriteMessage(AntecessorLaneId);
              }
              if (successorLaneId_ != null) {
                output.WriteRawTag(18);
                output.WriteMessage(SuccessorLaneId);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (antecessorLaneId_ != null) {
                output.WriteRawTag(10);
                output.WriteMessage(AntecessorLaneId);
              }
              if (successorLaneId_ != null) {
                output.WriteRawTag(18);
                output.WriteMessage(SuccessorLaneId);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (antecessorLaneId_ != null) {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(AntecessorLaneId);
              }
              if (successorLaneId_ != null) {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(SuccessorLaneId);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(LanePairing other) {
              if (other == null) {
                return;
              }
              if (other.antecessorLaneId_ != null) {
                if (antecessorLaneId_ == null) {
                  AntecessorLaneId = new global::Osi3.Identifier();
                }
                AntecessorLaneId.MergeFrom(other.AntecessorLaneId);
              }
              if (other.successorLaneId_ != null) {
                if (successorLaneId_ == null) {
                  SuccessorLaneId = new global::Osi3.Identifier();
                }
                SuccessorLaneId.MergeFrom(other.SuccessorLaneId);
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    if (antecessorLaneId_ == null) {
                      AntecessorLaneId = new global::Osi3.Identifier();
                    }
                    input.ReadMessage(AntecessorLaneId);
                    break;
                  }
                  case 18: {
                    if (successorLaneId_ == null) {
                      SuccessorLaneId = new global::Osi3.Identifier();
                    }
                    input.ReadMessage(SuccessorLaneId);
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 10: {
                    if (antecessorLaneId_ == null) {
                      AntecessorLaneId = new global::Osi3.Identifier();
                    }
                    input.ReadMessage(AntecessorLaneId);
                    break;
                  }
                  case 18: {
                    if (successorLaneId_ == null) {
                      SuccessorLaneId = new global::Osi3.Identifier();
                    }
                    input.ReadMessage(SuccessorLaneId);
                    break;
                  }
                }
              }
            }
            #endif

          }

        }
        #endregion

      }

    }
    #endregion

  }

  /// <summary>
  ///
  /// \brief A lane boundary defining the border of a lane.
  ///
  /// The left and right lane boundary define the width of the lane. Additionally,
  /// free markings can be defined, e.g. at construction sites. Free markings
  /// across multiple lanes may be defined multiple times for all affected lanes.
  ///
  /// \image html OSI_LaneBoundary.svg "LaneBoundary" width=800px
  ///
  /// \note In the example, the symbols l1, l2, ... and lb1, lb2, ...
  /// stand for the lane ids and lane boundary ids respectively, i.e. for
  /// integers (uint64). The symbols bp2_{i+1}, bp2_{i}, bp2_{i-1} stand
  /// for \c #osi3::LaneBoundary::BoundaryPoint elements.
  /// </summary>
  public sealed partial class LaneBoundary : pb::IMessage<LaneBoundary>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<LaneBoundary> _parser = new pb::MessageParser<LaneBoundary>(() => new LaneBoundary());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<LaneBoundary> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Osi3.OsiLaneReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LaneBoundary() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LaneBoundary(LaneBoundary other) : this() {
      id_ = other.id_ != null ? other.id_.Clone() : null;
      boundaryLine_ = other.boundaryLine_.Clone();
      classification_ = other.classification_ != null ? other.classification_.Clone() : null;
      sourceReference_ = other.sourceReference_.Clone();
      colorDescription_ = other.colorDescription_ != null ? other.colorDescription_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LaneBoundary Clone() {
      return new LaneBoundary(this);
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private global::Osi3.Identifier id_;
    /// <summary>
    /// The ID of the lane boundary.
    ///
    /// \rules
    /// is_globally_unique
    /// \endrules
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.Identifier Id {
      get { return id_; }
      set {
        id_ = value;
      }
    }

    /// <summary>Field number for the "boundary_line" field.</summary>
    public const int BoundaryLineFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Osi3.LaneBoundary.Types.BoundaryPoint> _repeated_boundaryLine_codec
        = pb::FieldCodec.ForMessage(18, global::Osi3.LaneBoundary.Types.BoundaryPoint.Parser);
    private readonly pbc::RepeatedField<global::Osi3.LaneBoundary.Types.BoundaryPoint> boundaryLine_ = new pbc::RepeatedField<global::Osi3.LaneBoundary.Types.BoundaryPoint>();
    /// <summary>
    /// \note For dashed lines, one \c BoundaryPoint has to be at the start and
    /// another at the end of each dashed line segment. The first
    /// \c BoundaryPoint defines the beginning of the first dashed lane marking.
    /// The last \c BoundaryPoint defines the end of the last dashed lane
    /// marking.
    /// \note For Botts' dots lines, one \c BoundaryPoint position has to define
    /// each Botts' dot.
    ///
    /// \attention For \c BoundaryPoint the same rule for the approximation
    /// error applies as for \c Lane::Classification::centerline.
    ///
    /// \rules
    /// first_element width is_equal_to 0.13
    /// first_element height is_equal_to 0.14
    /// last_element width is_equal_to 0.13
    /// last_element height is_equal_to 0.13
    /// \endrules
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Osi3.LaneBoundary.Types.BoundaryPoint> BoundaryLine {
      get { return boundaryLine_; }
    }

    /// <summary>Field number for the "classification" field.</summary>
    public const int ClassificationFieldNumber = 3;
    private global::Osi3.LaneBoundary.Types.Classification classification_;
    /// <summary>
    /// The classification of the lane boundary.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.LaneBoundary.Types.Classification Classification {
      get { return classification_; }
      set {
        classification_ = value;
      }
    }

    /// <summary>Field number for the "source_reference" field.</summary>
    public const int SourceReferenceFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Osi3.ExternalReference> _repeated_sourceReference_codec
        = pb::FieldCodec.ForMessage(34, global::Osi3.ExternalReference.Parser);
    private readonly pbc::RepeatedField<global::Osi3.ExternalReference> sourceReference_ = new pbc::RepeatedField<global::Osi3.ExternalReference>();
    /// <summary>
    /// Optional external reference to the lane boundary source.
    ///
    /// \note For OpenDRIVE, there is no direct possibility to reference the
    ///       RoadMark, as there is no unique identifier in this sub-object.
    ///
    /// \note For non-ASAM Standards, it is implementation-specific how
    ///       source_reference is resolved.
    ///
    /// \note The value has to be repeated because one object may be derived
    ///       from more than one origin source, for example, from a scenario file
    ///       and from sensors.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Osi3.ExternalReference> SourceReference {
      get { return sourceReference_; }
    }

    /// <summary>Field number for the "color_description" field.</summary>
    public const int ColorDescriptionFieldNumber = 5;
    private global::Osi3.ColorDescription colorDescription_;
    /// <summary>
    /// The visual color of the material of the lane boundary.
    ///
    /// \note This does not represent the semantic classification but the visual
    /// appearance. For semantic classification of the lane boundary use the color
    /// field in \c Classification.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.ColorDescription ColorDescription {
      get { return colorDescription_; }
      set {
        colorDescription_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as LaneBoundary);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(LaneBoundary other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Id, other.Id)) return false;
      if(!boundaryLine_.Equals(other.boundaryLine_)) return false;
      if (!object.Equals(Classification, other.Classification)) return false;
      if(!sourceReference_.Equals(other.sourceReference_)) return false;
      if (!object.Equals(ColorDescription, other.ColorDescription)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (id_ != null) hash ^= Id.GetHashCode();
      hash ^= boundaryLine_.GetHashCode();
      if (classification_ != null) hash ^= Classification.GetHashCode();
      hash ^= sourceReference_.GetHashCode();
      if (colorDescription_ != null) hash ^= ColorDescription.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (id_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Id);
      }
      boundaryLine_.WriteTo(output, _repeated_boundaryLine_codec);
      if (classification_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Classification);
      }
      sourceReference_.WriteTo(output, _repeated_sourceReference_codec);
      if (colorDescription_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(ColorDescription);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (id_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Id);
      }
      boundaryLine_.WriteTo(ref output, _repeated_boundaryLine_codec);
      if (classification_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Classification);
      }
      sourceReference_.WriteTo(ref output, _repeated_sourceReference_codec);
      if (colorDescription_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(ColorDescription);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (id_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Id);
      }
      size += boundaryLine_.CalculateSize(_repeated_boundaryLine_codec);
      if (classification_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Classification);
      }
      size += sourceReference_.CalculateSize(_repeated_sourceReference_codec);
      if (colorDescription_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ColorDescription);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(LaneBoundary other) {
      if (other == null) {
        return;
      }
      if (other.id_ != null) {
        if (id_ == null) {
          Id = new global::Osi3.Identifier();
        }
        Id.MergeFrom(other.Id);
      }
      boundaryLine_.Add(other.boundaryLine_);
      if (other.classification_ != null) {
        if (classification_ == null) {
          Classification = new global::Osi3.LaneBoundary.Types.Classification();
        }
        Classification.MergeFrom(other.Classification);
      }
      sourceReference_.Add(other.sourceReference_);
      if (other.colorDescription_ != null) {
        if (colorDescription_ == null) {
          ColorDescription = new global::Osi3.ColorDescription();
        }
        ColorDescription.MergeFrom(other.ColorDescription);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (id_ == null) {
              Id = new global::Osi3.Identifier();
            }
            input.ReadMessage(Id);
            break;
          }
          case 18: {
            boundaryLine_.AddEntriesFrom(input, _repeated_boundaryLine_codec);
            break;
          }
          case 26: {
            if (classification_ == null) {
              Classification = new global::Osi3.LaneBoundary.Types.Classification();
            }
            input.ReadMessage(Classification);
            break;
          }
          case 34: {
            sourceReference_.AddEntriesFrom(input, _repeated_sourceReference_codec);
            break;
          }
          case 42: {
            if (colorDescription_ == null) {
              ColorDescription = new global::Osi3.ColorDescription();
            }
            input.ReadMessage(ColorDescription);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (id_ == null) {
              Id = new global::Osi3.Identifier();
            }
            input.ReadMessage(Id);
            break;
          }
          case 18: {
            boundaryLine_.AddEntriesFrom(ref input, _repeated_boundaryLine_codec);
            break;
          }
          case 26: {
            if (classification_ == null) {
              Classification = new global::Osi3.LaneBoundary.Types.Classification();
            }
            input.ReadMessage(Classification);
            break;
          }
          case 34: {
            sourceReference_.AddEntriesFrom(ref input, _repeated_sourceReference_codec);
            break;
          }
          case 42: {
            if (colorDescription_ == null) {
              ColorDescription = new global::Osi3.ColorDescription();
            }
            input.ReadMessage(ColorDescription);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the LaneBoundary message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      ///
      /// \brief A single point of a lane boundary.
      ///
      /// \image html OSI_LaneBoundaries_And_CenterLine.svg "" width=800px
      ///
      /// \note 
      /// cl: center line
      /// lb: lane boundary
      ///
      /// \image html OSI_LaneBoundary.svg "" width=800px
      ///
      /// The lane boundary point bp2_{i} is one of the points of lane boundary
      /// lb2.
      ///
      /// \note In the example, the symbols l1, l2, ... and lb1, lb2, ...
      /// stand for the lane ids and lane boundary ids respectively, i.e. for
      /// integers (uint64). The symbols bp2_{i+1}, bp2_{i}, bp2_{i-1} stand
      /// for \c #osi3::LaneBoundary::BoundaryPoint elements.
      /// </summary>
      public sealed partial class BoundaryPoint : pb::IMessage<BoundaryPoint>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<BoundaryPoint> _parser = new pb::MessageParser<BoundaryPoint>(() => new BoundaryPoint());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<BoundaryPoint> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Osi3.LaneBoundary.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public BoundaryPoint() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public BoundaryPoint(BoundaryPoint other) : this() {
          position_ = other.position_ != null ? other.position_.Clone() : null;
          width_ = other.width_;
          height_ = other.height_;
          dash_ = other.dash_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public BoundaryPoint Clone() {
          return new BoundaryPoint(this);
        }

        /// <summary>Field number for the "position" field.</summary>
        public const int PositionFieldNumber = 1;
        private global::Osi3.Vector3d position_;
        /// <summary>
        /// The position of the \c BoundaryPoint.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Osi3.Vector3d Position {
          get { return position_; }
          set {
            position_ = value;
          }
        }

        /// <summary>Field number for the "width" field.</summary>
        public const int WidthFieldNumber = 2;
        private double width_;
        /// <summary>
        /// The overall width of the lane boundary at the position of the
        /// \c BoundaryPoint .
        /// Used for lines forming lane markings.
        ///
        /// \image html OSI_LaneBoundaryWidth.svg "" width=600px
        ///
        /// \note Field need not be set if it is defined previous.
        /// See \c LaneBoundary.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public double Width {
          get { return width_; }
          set {
            width_ = value;
          }
        }

        /// <summary>Field number for the "height" field.</summary>
        public const int HeightFieldNumber = 3;
        private double height_;
        /// <summary>
        /// The overall height of the lane boundary at the position of the
        /// \c BoundaryPoint .
        /// Used for guard rails, curbstone, or similar.
        ///
        /// \image html OSI_LaneBoundaryHeight.svg "" width=600px
        ///
        /// \note Field need not be set if it is previously defined.
        ///
        /// \note The boundary point height should not be used to model the boundary 
        ///       between two adjacent lanes at different heights as a single, shared 
        ///       boundary.
        ///       Boundaries between adjacent lanes at different heights should be 
        ///       modeled as two separate lane boundaries.
        ///
        /// See \c LaneBoundary .
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public double Height {
          get { return height_; }
          set {
            height_ = value;
          }
        }

        /// <summary>Field number for the "dash" field.</summary>
        public const int DashFieldNumber = 4;
        private global::Osi3.LaneBoundary.Types.BoundaryPoint.Types.Dash dash_ = global::Osi3.LaneBoundary.Types.BoundaryPoint.Types.Dash.Unknown;
        /// <summary>
        /// Alternation of dashes in case of a dashed lane boundary. In
        /// context, this field gives information about the location of
        /// dashes on the boundary line.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Osi3.LaneBoundary.Types.BoundaryPoint.Types.Dash Dash {
          get { return dash_; }
          set {
            dash_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as BoundaryPoint);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(BoundaryPoint other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(Position, other.Position)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Width, other.Width)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Height, other.Height)) return false;
          if (Dash != other.Dash) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (position_ != null) hash ^= Position.GetHashCode();
          if (Width != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Width);
          if (Height != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Height);
          if (Dash != global::Osi3.LaneBoundary.Types.BoundaryPoint.Types.Dash.Unknown) hash ^= Dash.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (position_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(Position);
          }
          if (Width != 0D) {
            output.WriteRawTag(17);
            output.WriteDouble(Width);
          }
          if (Height != 0D) {
            output.WriteRawTag(25);
            output.WriteDouble(Height);
          }
          if (Dash != global::Osi3.LaneBoundary.Types.BoundaryPoint.Types.Dash.Unknown) {
            output.WriteRawTag(32);
            output.WriteEnum((int) Dash);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (position_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(Position);
          }
          if (Width != 0D) {
            output.WriteRawTag(17);
            output.WriteDouble(Width);
          }
          if (Height != 0D) {
            output.WriteRawTag(25);
            output.WriteDouble(Height);
          }
          if (Dash != global::Osi3.LaneBoundary.Types.BoundaryPoint.Types.Dash.Unknown) {
            output.WriteRawTag(32);
            output.WriteEnum((int) Dash);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (position_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Position);
          }
          if (Width != 0D) {
            size += 1 + 8;
          }
          if (Height != 0D) {
            size += 1 + 8;
          }
          if (Dash != global::Osi3.LaneBoundary.Types.BoundaryPoint.Types.Dash.Unknown) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Dash);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(BoundaryPoint other) {
          if (other == null) {
            return;
          }
          if (other.position_ != null) {
            if (position_ == null) {
              Position = new global::Osi3.Vector3d();
            }
            Position.MergeFrom(other.Position);
          }
          if (other.Width != 0D) {
            Width = other.Width;
          }
          if (other.Height != 0D) {
            Height = other.Height;
          }
          if (other.Dash != global::Osi3.LaneBoundary.Types.BoundaryPoint.Types.Dash.Unknown) {
            Dash = other.Dash;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (position_ == null) {
                  Position = new global::Osi3.Vector3d();
                }
                input.ReadMessage(Position);
                break;
              }
              case 17: {
                Width = input.ReadDouble();
                break;
              }
              case 25: {
                Height = input.ReadDouble();
                break;
              }
              case 32: {
                Dash = (global::Osi3.LaneBoundary.Types.BoundaryPoint.Types.Dash) input.ReadEnum();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                if (position_ == null) {
                  Position = new global::Osi3.Vector3d();
                }
                input.ReadMessage(Position);
                break;
              }
              case 17: {
                Width = input.ReadDouble();
                break;
              }
              case 25: {
                Height = input.ReadDouble();
                break;
              }
              case 32: {
                Dash = (global::Osi3.LaneBoundary.Types.BoundaryPoint.Types.Dash) input.ReadEnum();
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the BoundaryPoint message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          /// <summary>
          /// This enum describes the alternation of dashes in case of a
          /// dashed lane boundary.
          ///
          /// \note The enum descriptions adhere to the definition direction
          /// of the lane boundary points. This means that start or end of a
          /// dash are understood with respect to the direction in which the
          /// points of the boundary line are defined.
          /// </summary>
          public enum Dash {
            /// <summary>
            /// The current state of the dash alternation is not known (must
            /// not be used in ground truth). 
            /// </summary>
            [pbr::OriginalName("DASH_UNKNOWN")] Unknown = 0,
            /// <summary>
            /// Other (unspecified but known) type of dash alternation state. 
            /// </summary>
            [pbr::OriginalName("DASH_OTHER")] Other = 1,
            /// <summary>
            /// The current \c BoundaryPoint indicates the start of a dash.
            /// </summary>
            [pbr::OriginalName("DASH_START")] Start = 2,
            /// <summary>
            /// The current \c BoundaryPoint is located on a dash of a dashed
            /// line. This enables a dash to continue across multiple points.
            /// </summary>
            [pbr::OriginalName("DASH_CONTINUE")] Continue = 3,
            /// <summary>
            /// The current \c BoundaryPoint indicates the end of a dash.
            /// </summary>
            [pbr::OriginalName("DASH_END")] End = 4,
            /// <summary>
            /// The current \c BoundaryPoint is located in the gap between
            /// two dashes. When used to describe a first/last point of a lane 
            /// boundary, it indicates that the lane boundary starts/ends in
            /// a gap.
            /// </summary>
            [pbr::OriginalName("DASH_GAP")] Gap = 5,
          }

        }
        #endregion

      }

      /// <summary>
      ///
      /// \brief \c Classification of a lane boundary.
      ///
      /// &lt;table border = 0>
      /// &lt;tr>
      /// &lt;td>
      /// &lt;table border=0>
      /// &lt;tr>
      /// &lt;td>
      /// &lt;b>
      /// Image Intersection
      /// &lt;/b>
      /// &lt;tr>
      /// &lt;td>
      /// &lt;tr>
      /// &lt;td>
      /// \c Classification for lane boundaries lb2 and lb9:
      /// &lt;/td>
      /// &lt;/tr>
      /// &lt;tr>
      /// &lt;td>
      /// &lt;table border = 0>
      /// &lt;tr>
      /// &lt;td>
      /// \c #type = #TYPE_DASHED_LINE
      /// &lt;tr>
      /// &lt;td>
      /// \c #color = #COLOR_WHITE
      /// &lt;tr>
      /// &lt;/table>
      /// &lt;/td>
      /// &lt;/tr>
      /// &lt;tr>
      /// &lt;td>
      /// \c Classification for lane boundaries lb1, lb3, lb4, lb7, lb8, lb10,
      /// lb11, lb12 and lb14:
      /// &lt;/td>
      /// &lt;/tr>
      /// &lt;tr>
      /// &lt;td>
      /// &lt;table border = 0>
      /// &lt;tr>
      /// &lt;td>
      /// \c #type = #TYPE_SOLID_LINE
      /// &lt;tr>
      /// &lt;td>
      /// \c #color = #COLOR_WHITE
      /// &lt;tr>
      /// &lt;/table>
      /// &lt;/td>
      /// &lt;/tr>
      /// &lt;tr>
      /// &lt;td>
      /// \c Classification for lane boundaries lb5, lb6 and lb13:
      /// &lt;/td>
      /// &lt;/tr>
      /// &lt;tr>
      /// &lt;td>
      /// &lt;table border = 0>
      /// &lt;tr>
      /// &lt;td>
      /// \c #type = #TYPE_CURB
      /// &lt;/table>
      /// &lt;/td>
      /// &lt;/tr>
      /// &lt;/table>
      /// &lt;/td>
      /// &lt;td>
      /// &lt;table border=0>
      /// &lt;tr>
      /// &lt;td>
      /// \image html OSI_LaneIntersection.svg "" width=500px
      /// &lt;/td>
      /// &lt;tr>
      /// &lt;td>
      /// \image html OSI_LaneBoundaryClassification.jpg "" width=600px
      /// &lt;/td>
      /// &lt;/table>
      /// &lt;/td>
      /// &lt;/tr>
      /// &lt;/table>
      ///
      /// \note In the example, the symbols l1, l2, ... and lb1, lb2, ...
      /// stand for the lane ids and lane boundary ids respectively, i.e. for
      /// integers (uint64). The symbols cl1, cl2, ... represent the
      /// osi3::Lane::Classification::centerline elements of the lanes with
      /// the respective ids.
      /// </summary>
      public sealed partial class Classification : pb::IMessage<Classification>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Classification> _parser = new pb::MessageParser<Classification>(() => new Classification());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Classification> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Osi3.LaneBoundary.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Classification() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Classification(Classification other) : this() {
          type_ = other.type_;
          color_ = other.color_;
          limitingStructureId_ = other.limitingStructureId_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Classification Clone() {
          return new Classification(this);
        }

        /// <summary>Field number for the "type" field.</summary>
        public const int TypeFieldNumber = 1;
        private global::Osi3.LaneBoundary.Types.Classification.Types.Type type_ = global::Osi3.LaneBoundary.Types.Classification.Types.Type.Unknown;
        /// <summary>
        /// The type of the lane boundary.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Osi3.LaneBoundary.Types.Classification.Types.Type Type {
          get { return type_; }
          set {
            type_ = value;
          }
        }

        /// <summary>Field number for the "color" field.</summary>
        public const int ColorFieldNumber = 2;
        private global::Osi3.LaneBoundary.Types.Classification.Types.Color color_ = global::Osi3.LaneBoundary.Types.Classification.Types.Color.Unknown;
        /// <summary>
        /// The semantic color of the lane boundary in case of lane markings.
        ///
        /// \note The color types represent the semantic classification of
        /// lane markings only. They do not represent an actual visual appearance.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Osi3.LaneBoundary.Types.Classification.Types.Color Color {
          get { return color_; }
          set {
            color_ = value;
          }
        }

        /// <summary>Field number for the "limiting_structure_id" field.</summary>
        public const int LimitingStructureIdFieldNumber = 3;
        private static readonly pb::FieldCodec<global::Osi3.Identifier> _repeated_limitingStructureId_codec
            = pb::FieldCodec.ForMessage(26, global::Osi3.Identifier.Parser);
        private readonly pbc::RepeatedField<global::Osi3.Identifier> limitingStructureId_ = new pbc::RepeatedField<global::Osi3.Identifier>();
        /// <summary>
        /// The ids of \c StationaryObject which limit the corresponding lane.
        /// This field must be set if the \c #type is set to
        /// \c #TYPE_STRUCTURE
        ///
        /// \rules
        /// refers_to: StationaryObject
        /// \endrules
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Osi3.Identifier> LimitingStructureId {
          get { return limitingStructureId_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Classification);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Classification other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Type != other.Type) return false;
          if (Color != other.Color) return false;
          if(!limitingStructureId_.Equals(other.limitingStructureId_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Type != global::Osi3.LaneBoundary.Types.Classification.Types.Type.Unknown) hash ^= Type.GetHashCode();
          if (Color != global::Osi3.LaneBoundary.Types.Classification.Types.Color.Unknown) hash ^= Color.GetHashCode();
          hash ^= limitingStructureId_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Type != global::Osi3.LaneBoundary.Types.Classification.Types.Type.Unknown) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Type);
          }
          if (Color != global::Osi3.LaneBoundary.Types.Classification.Types.Color.Unknown) {
            output.WriteRawTag(16);
            output.WriteEnum((int) Color);
          }
          limitingStructureId_.WriteTo(output, _repeated_limitingStructureId_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Type != global::Osi3.LaneBoundary.Types.Classification.Types.Type.Unknown) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Type);
          }
          if (Color != global::Osi3.LaneBoundary.Types.Classification.Types.Color.Unknown) {
            output.WriteRawTag(16);
            output.WriteEnum((int) Color);
          }
          limitingStructureId_.WriteTo(ref output, _repeated_limitingStructureId_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Type != global::Osi3.LaneBoundary.Types.Classification.Types.Type.Unknown) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
          }
          if (Color != global::Osi3.LaneBoundary.Types.Classification.Types.Color.Unknown) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Color);
          }
          size += limitingStructureId_.CalculateSize(_repeated_limitingStructureId_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Classification other) {
          if (other == null) {
            return;
          }
          if (other.Type != global::Osi3.LaneBoundary.Types.Classification.Types.Type.Unknown) {
            Type = other.Type;
          }
          if (other.Color != global::Osi3.LaneBoundary.Types.Classification.Types.Color.Unknown) {
            Color = other.Color;
          }
          limitingStructureId_.Add(other.limitingStructureId_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Type = (global::Osi3.LaneBoundary.Types.Classification.Types.Type) input.ReadEnum();
                break;
              }
              case 16: {
                Color = (global::Osi3.LaneBoundary.Types.Classification.Types.Color) input.ReadEnum();
                break;
              }
              case 26: {
                limitingStructureId_.AddEntriesFrom(input, _repeated_limitingStructureId_codec);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                Type = (global::Osi3.LaneBoundary.Types.Classification.Types.Type) input.ReadEnum();
                break;
              }
              case 16: {
                Color = (global::Osi3.LaneBoundary.Types.Classification.Types.Color) input.ReadEnum();
                break;
              }
              case 26: {
                limitingStructureId_.AddEntriesFrom(ref input, _repeated_limitingStructureId_codec);
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the Classification message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          /// <summary>
          /// The lane boundary type.
          /// There is no special representation for double lines, e.g. solid /
          /// solid or dashed / solid. In such cases, each lane will define its own
          /// side of the lane boundary.
          /// </summary>
          public enum Type {
            /// <summary>
            /// The type of lane boundary is unknown. Value must not be used in
            /// ground truth.
            /// </summary>
            [pbr::OriginalName("TYPE_UNKNOWN")] Unknown = 0,
            /// <summary>
            /// Unspecified but known type of lane boundary.
            /// Consider proposing an additional type if using TYPE_OTHER.
            /// </summary>
            [pbr::OriginalName("TYPE_OTHER")] Other = 1,
            /// <summary>
            /// An invisible lane boundary.
            /// </summary>
            [pbr::OriginalName("TYPE_NO_LINE")] NoLine = 2,
            /// <summary>
            /// A solid line at the lane boundary.
            /// </summary>
            [pbr::OriginalName("TYPE_SOLID_LINE")] SolidLine = 3,
            /// <summary>
            /// A dashed line at the lane boundary.
            /// </summary>
            [pbr::OriginalName("TYPE_DASHED_LINE")] DashedLine = 4,
            /// <summary>
            /// A lane boundary consisting of Botts' dots (multiple Botts dots).
            /// </summary>
            [pbr::OriginalName("TYPE_BOTTS_DOTS")] BottsDots = 5,
            /// <summary>
            /// A lane boundary formed by the road's edge.
            /// The road edge is the end of the (paved) road surface.
            /// </summary>
            [pbr::OriginalName("TYPE_ROAD_EDGE")] RoadEdge = 6,
            /// <summary>
            /// A lane boundary formed by a snow edge that may be on the road
            /// surface.
            /// </summary>
            [pbr::OriginalName("TYPE_SNOW_EDGE")] SnowEdge = 7,
            /// <summary>
            /// A lane boundary covered by grass.
            /// </summary>
            [pbr::OriginalName("TYPE_GRASS_EDGE")] GrassEdge = 8,
            /// <summary>
            /// A lane boundary covered by gravel.
            /// </summary>
            [pbr::OriginalName("TYPE_GRAVEL_EDGE")] GravelEdge = 9,
            /// <summary>
            /// A lane boundary covered by soil.
            /// </summary>
            [pbr::OriginalName("TYPE_SOIL_EDGE")] SoilEdge = 10,
            /// <summary>
            /// A guard rail.
            /// </summary>
            [pbr::OriginalName("TYPE_GUARD_RAIL")] GuardRail = 11,
            /// <summary>
            /// A curb.
            /// </summary>
            [pbr::OriginalName("TYPE_CURB")] Curb = 12,
            /// <summary>
            /// A structure (e.g. building or tunnel wall).
            /// </summary>
            [pbr::OriginalName("TYPE_STRUCTURE")] Structure = 13,
            /// <summary>
            /// A barrier to guide vehicles and to prevent them from entering other lanes (e.g. a concrete barrier on a highway).
            /// </summary>
            [pbr::OriginalName("TYPE_BARRIER")] Barrier = 14,
            /// <summary>
            /// A sound barrier.
            /// </summary>
            [pbr::OriginalName("TYPE_SOUND_BARRIER")] SoundBarrier = 15,
          }

          /// <summary>
          /// The semantic color of the lane boundary in case of a lane markings.
          /// Lane markings that alternate in color must be represented by
          /// individual \c LaneBoundary segments.
          ///
          /// \note The color types represent the semantic color classification of
          /// lane markings only. They do not represent an actual visual appearance.
          /// </summary>
          public enum Color {
            /// <summary>
            /// Color of marking is unknown. Value must not be used in ground
            /// truth.
            /// </summary>
            [pbr::OriginalName("COLOR_UNKNOWN")] Unknown = 0,
            /// <summary>
            /// Other (unspecified but known) color.
            /// </summary>
            [pbr::OriginalName("COLOR_OTHER")] Other = 1,
            /// <summary>
            /// Marking without color. Used to represent logical boundaries
            /// without actual physical markings at the respective position.
            /// Value may be used in ground truth only.
            /// </summary>
            [pbr::OriginalName("COLOR_NONE")] None = 2,
            /// <summary>
            /// Marking with white color.
            /// </summary>
            [pbr::OriginalName("COLOR_WHITE")] White = 3,
            /// <summary>
            /// Marking with yellow / orange-yellow color.
            /// </summary>
            [pbr::OriginalName("COLOR_YELLOW")] Yellow = 4,
            /// <summary>
            /// Marking with red color
            /// </summary>
            [pbr::OriginalName("COLOR_RED")] Red = 5,
            /// <summary>
            /// Marking with blue color.
            /// </summary>
            [pbr::OriginalName("COLOR_BLUE")] Blue = 6,
            /// <summary>
            /// Marking with green color;
            /// </summary>
            [pbr::OriginalName("COLOR_GREEN")] Green = 7,
            /// <summary>
            /// Marking with violet color.
            /// </summary>
            [pbr::OriginalName("COLOR_VIOLET")] Violet = 8,
            /// <summary>
            /// Marking with orange color.
            /// </summary>
            [pbr::OriginalName("COLOR_ORANGE")] Orange = 9,
          }

        }
        #endregion

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
