// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: osi_groundtruth.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Osi3 {

  /// <summary>Holder for reflection information generated from osi_groundtruth.proto</summary>
  public static partial class OsiGroundtruthReflection {

    #region Descriptor
    /// <summary>File descriptor for osi_groundtruth.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static OsiGroundtruthReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChVvc2lfZ3JvdW5kdHJ1dGgucHJvdG8SBG9zaTMaEW9zaV92ZXJzaW9uLnBy",
            "b3RvGhBvc2lfY29tbW9uLnByb3RvGhVvc2lfZW52aXJvbm1lbnQucHJvdG8a",
            "FW9zaV90cmFmZmljc2lnbi5wcm90bxoWb3NpX3RyYWZmaWNsaWdodC5wcm90",
            "bxoVb3NpX3JvYWRtYXJraW5nLnByb3RvGg5vc2lfbGFuZS5wcm90bxoVb3Np",
            "X2xvZ2ljYWxsYW5lLnByb3RvGhdvc2lfcmVmZXJlbmNlbGluZS5wcm90bxoQ",
            "b3NpX29iamVjdC5wcm90bxoSb3NpX29jY3VwYW50LnByb3RvIvMFCgtHcm91",
            "bmRUcnV0aBInCgd2ZXJzaW9uGAEgASgLMhYub3NpMy5JbnRlcmZhY2VWZXJz",
            "aW9uEiIKCXRpbWVzdGFtcBgCIAEoCzIPLm9zaTMuVGltZXN0YW1wEikKD2hv",
            "c3RfdmVoaWNsZV9pZBgDIAEoCzIQLm9zaTMuSWRlbnRpZmllchIxChFzdGF0",
            "aW9uYXJ5X29iamVjdBgEIAMoCzIWLm9zaTMuU3RhdGlvbmFyeU9iamVjdBIp",
            "Cg1tb3Zpbmdfb2JqZWN0GAUgAygLMhIub3NpMy5Nb3ZpbmdPYmplY3QSJwoM",
            "dHJhZmZpY19zaWduGAYgAygLMhEub3NpMy5UcmFmZmljU2lnbhIpCg10cmFm",
            "ZmljX2xpZ2h0GAcgAygLMhIub3NpMy5UcmFmZmljTGlnaHQSJwoMcm9hZF9t",
            "YXJraW5nGAggAygLMhEub3NpMy5Sb2FkTWFya2luZxIpCg1sYW5lX2JvdW5k",
            "YXJ5GAkgAygLMhIub3NpMy5MYW5lQm91bmRhcnkSGAoEbGFuZRgKIAMoCzIK",
            "Lm9zaTMuTGFuZRIgCghvY2N1cGFudBgLIAMoCzIOLm9zaTMuT2NjdXBhbnQS",
            "PwoYZW52aXJvbm1lbnRhbF9jb25kaXRpb25zGAwgASgLMh0ub3NpMy5FbnZp",
            "cm9ubWVudGFsQ29uZGl0aW9ucxIUCgxjb3VudHJ5X2NvZGUYDSABKA0SEwoL",
            "cHJval9zdHJpbmcYDiABKAkSFQoNbWFwX3JlZmVyZW5jZRgPIAEoCRIXCg9t",
            "b2RlbF9yZWZlcmVuY2UYECABKAkSKwoOcmVmZXJlbmNlX2xpbmUYESADKAsy",
            "Ey5vc2kzLlJlZmVyZW5jZUxpbmUSOAoVbG9naWNhbF9sYW5lX2JvdW5kYXJ5",
            "GBIgAygLMhkub3NpMy5Mb2dpY2FsTGFuZUJvdW5kYXJ5EicKDGxvZ2ljYWxf",
            "bGFuZRgTIAMoCzIRLm9zaTMuTG9naWNhbExhbmVCAkgBYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Osi3.OsiVersionReflection.Descriptor, global::Osi3.OsiCommonReflection.Descriptor, global::Osi3.OsiEnvironmentReflection.Descriptor, global::Osi3.OsiTrafficsignReflection.Descriptor, global::Osi3.OsiTrafficlightReflection.Descriptor, global::Osi3.OsiRoadmarkingReflection.Descriptor, global::Osi3.OsiLaneReflection.Descriptor, global::Osi3.OsiLogicallaneReflection.Descriptor, global::Osi3.OsiReferencelineReflection.Descriptor, global::Osi3.OsiObjectReflection.Descriptor, global::Osi3.OsiOccupantReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Osi3.GroundTruth), global::Osi3.GroundTruth.Parser, new[]{ "Version", "Timestamp", "HostVehicleId", "StationaryObject", "MovingObject", "TrafficSign", "TrafficLight", "RoadMarking", "LaneBoundary", "Lane", "Occupant", "EnvironmentalConditions", "CountryCode", "ProjString", "MapReference", "ModelReference", "ReferenceLine", "LogicalLaneBoundary", "LogicalLane" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  ///
  /// \brief The ground truth information from the simulation environment.
  ///
  /// This ground truth information is supposed to describe the whole simulated
  /// environment around any simulated vehicle. For each simulated host vehicle
  /// (there may be one or multiple), define an area around the vehicle which
  /// is greater than the combined field of views (FOV) of all obstructed sensors
  /// in the vehicle. The ground truth data is supposed to describe the convex
  /// hull of all such areas w.r.t. a global simulation coordinate system.
  ///
  /// The simulation coordinate system may change during the simulation if and
  /// only if all coordinates w.r.t. this coordinate system are also changed.
  ///
  /// The data has to be sent at a rate defined by the receiving partner. When
  /// sending, values with default values might be left default in order to improve
  /// performance.
  ///
  /// To provide a complete interface, all fields of all contained messages must be
  /// properly set unless specifically stated in the field's definition that the
  /// field may remain unset.
  ///
  /// In enums (e.g. types) the unknown (first / default) value is not allowed to
  /// be used in the ground truth interface.
  ///
  /// \image html OSI_GroundTruth.svg "Ground Truth"
  /// </summary>
  public sealed partial class GroundTruth : pb::IMessage<GroundTruth>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<GroundTruth> _parser = new pb::MessageParser<GroundTruth>(() => new GroundTruth());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GroundTruth> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Osi3.OsiGroundtruthReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GroundTruth() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GroundTruth(GroundTruth other) : this() {
      version_ = other.version_ != null ? other.version_.Clone() : null;
      timestamp_ = other.timestamp_ != null ? other.timestamp_.Clone() : null;
      hostVehicleId_ = other.hostVehicleId_ != null ? other.hostVehicleId_.Clone() : null;
      stationaryObject_ = other.stationaryObject_.Clone();
      movingObject_ = other.movingObject_.Clone();
      trafficSign_ = other.trafficSign_.Clone();
      trafficLight_ = other.trafficLight_.Clone();
      roadMarking_ = other.roadMarking_.Clone();
      laneBoundary_ = other.laneBoundary_.Clone();
      lane_ = other.lane_.Clone();
      occupant_ = other.occupant_.Clone();
      environmentalConditions_ = other.environmentalConditions_ != null ? other.environmentalConditions_.Clone() : null;
      countryCode_ = other.countryCode_;
      projString_ = other.projString_;
      mapReference_ = other.mapReference_;
      modelReference_ = other.modelReference_;
      referenceLine_ = other.referenceLine_.Clone();
      logicalLaneBoundary_ = other.logicalLaneBoundary_.Clone();
      logicalLane_ = other.logicalLane_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GroundTruth Clone() {
      return new GroundTruth(this);
    }

    /// <summary>Field number for the "version" field.</summary>
    public const int VersionFieldNumber = 1;
    private global::Osi3.InterfaceVersion version_;
    /// <summary>
    /// The interface version used by the sender (i.e. the simulation
    /// environment).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.InterfaceVersion Version {
      get { return version_; }
      set {
        version_ = value;
      }
    }

    /// <summary>Field number for the "timestamp" field.</summary>
    public const int TimestampFieldNumber = 2;
    private global::Osi3.Timestamp timestamp_;
    /// <summary>
    /// The data timestamp of the simulation environment. The zero time point is
    /// arbitrary but must be identical for all messages.
    /// Recommendation: Zero time point for start point of the simulation.
    ///
    /// \note Zero time point does not need to coincide with the UNIX epoch.
    ///
    /// \note For ground truth data this timestamp coincides both with the
    /// notional simulation time the data applies to and the time it was sent
    /// (there is no inherent latency for ground truth data, as opposed to
    /// sensor data).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.Timestamp Timestamp {
      get { return timestamp_; }
      set {
        timestamp_ = value;
      }
    }

    /// <summary>Field number for the "host_vehicle_id" field.</summary>
    public const int HostVehicleIdFieldNumber = 3;
    private global::Osi3.Identifier hostVehicleId_;
    /// <summary>
    /// The ID of the host vehicle object referencing to \c MovingObject .
    ///
    /// \note This ID has to be filled and is not optional!
    ///
    /// \rules
    /// refers_to: MovingObject
    /// \endrules
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.Identifier HostVehicleId {
      get { return hostVehicleId_; }
      set {
        hostVehicleId_ = value;
      }
    }

    /// <summary>Field number for the "stationary_object" field.</summary>
    public const int StationaryObjectFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Osi3.StationaryObject> _repeated_stationaryObject_codec
        = pb::FieldCodec.ForMessage(34, global::Osi3.StationaryObject.Parser);
    private readonly pbc::RepeatedField<global::Osi3.StationaryObject> stationaryObject_ = new pbc::RepeatedField<global::Osi3.StationaryObject>();
    /// <summary>
    /// The list of stationary objects (excluding traffic signs and traffic
    /// lights).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Osi3.StationaryObject> StationaryObject {
      get { return stationaryObject_; }
    }

    /// <summary>Field number for the "moving_object" field.</summary>
    public const int MovingObjectFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Osi3.MovingObject> _repeated_movingObject_codec
        = pb::FieldCodec.ForMessage(42, global::Osi3.MovingObject.Parser);
    private readonly pbc::RepeatedField<global::Osi3.MovingObject> movingObject_ = new pbc::RepeatedField<global::Osi3.MovingObject>();
    /// <summary>
    /// The list of all other moving objects including all (host) vehicles.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Osi3.MovingObject> MovingObject {
      get { return movingObject_; }
    }

    /// <summary>Field number for the "traffic_sign" field.</summary>
    public const int TrafficSignFieldNumber = 6;
    private static readonly pb::FieldCodec<global::Osi3.TrafficSign> _repeated_trafficSign_codec
        = pb::FieldCodec.ForMessage(50, global::Osi3.TrafficSign.Parser);
    private readonly pbc::RepeatedField<global::Osi3.TrafficSign> trafficSign_ = new pbc::RepeatedField<global::Osi3.TrafficSign>();
    /// <summary>
    /// The list of traffic signs.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Osi3.TrafficSign> TrafficSign {
      get { return trafficSign_; }
    }

    /// <summary>Field number for the "traffic_light" field.</summary>
    public const int TrafficLightFieldNumber = 7;
    private static readonly pb::FieldCodec<global::Osi3.TrafficLight> _repeated_trafficLight_codec
        = pb::FieldCodec.ForMessage(58, global::Osi3.TrafficLight.Parser);
    private readonly pbc::RepeatedField<global::Osi3.TrafficLight> trafficLight_ = new pbc::RepeatedField<global::Osi3.TrafficLight>();
    /// <summary>
    /// The list of traffic lights.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Osi3.TrafficLight> TrafficLight {
      get { return trafficLight_; }
    }

    /// <summary>Field number for the "road_marking" field.</summary>
    public const int RoadMarkingFieldNumber = 8;
    private static readonly pb::FieldCodec<global::Osi3.RoadMarking> _repeated_roadMarking_codec
        = pb::FieldCodec.ForMessage(66, global::Osi3.RoadMarking.Parser);
    private readonly pbc::RepeatedField<global::Osi3.RoadMarking> roadMarking_ = new pbc::RepeatedField<global::Osi3.RoadMarking>();
    /// <summary>
    /// The list of road surface markings (lane markings are excluded and
    /// defined as \c LaneBoundary).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Osi3.RoadMarking> RoadMarking {
      get { return roadMarking_; }
    }

    /// <summary>Field number for the "lane_boundary" field.</summary>
    public const int LaneBoundaryFieldNumber = 9;
    private static readonly pb::FieldCodec<global::Osi3.LaneBoundary> _repeated_laneBoundary_codec
        = pb::FieldCodec.ForMessage(74, global::Osi3.LaneBoundary.Parser);
    private readonly pbc::RepeatedField<global::Osi3.LaneBoundary> laneBoundary_ = new pbc::RepeatedField<global::Osi3.LaneBoundary>();
    /// <summary>
    /// The list of lane boundaries.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Osi3.LaneBoundary> LaneBoundary {
      get { return laneBoundary_; }
    }

    /// <summary>Field number for the "lane" field.</summary>
    public const int LaneFieldNumber = 10;
    private static readonly pb::FieldCodec<global::Osi3.Lane> _repeated_lane_codec
        = pb::FieldCodec.ForMessage(82, global::Osi3.Lane.Parser);
    private readonly pbc::RepeatedField<global::Osi3.Lane> lane_ = new pbc::RepeatedField<global::Osi3.Lane>();
    /// <summary>
    /// The list of lanes forming a road network.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Osi3.Lane> Lane {
      get { return lane_; }
    }

    /// <summary>Field number for the "occupant" field.</summary>
    public const int OccupantFieldNumber = 11;
    private static readonly pb::FieldCodec<global::Osi3.Occupant> _repeated_occupant_codec
        = pb::FieldCodec.ForMessage(90, global::Osi3.Occupant.Parser);
    private readonly pbc::RepeatedField<global::Osi3.Occupant> occupant_ = new pbc::RepeatedField<global::Osi3.Occupant>();
    /// <summary>
    /// The list of passengers in the (host) vehicle(s).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Osi3.Occupant> Occupant {
      get { return occupant_; }
    }

    /// <summary>Field number for the "environmental_conditions" field.</summary>
    public const int EnvironmentalConditionsFieldNumber = 12;
    private global::Osi3.EnvironmentalConditions environmentalConditions_;
    /// <summary>
    /// Conditions of the environment.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.EnvironmentalConditions EnvironmentalConditions {
      get { return environmentalConditions_; }
      set {
        environmentalConditions_ = value;
      }
    }

    /// <summary>Field number for the "country_code" field.</summary>
    public const int CountryCodeFieldNumber = 13;
    private uint countryCode_;
    /// <summary>
    /// The ISO country code in 3 digit numeric format according to:
    /// ISO Code 3166/1 [1].
    /// E.g. Germany = 276, USA = 840.
    ///
    /// \par Reference:
    /// [1] ISO International Organization for Standardization. (2013). &lt;em>ISO 3166-1 Codes for the representation of names of countries and their subdivisions - Part 1: Country codes&lt;/em>. (ISO 3166-1:2013). Geneva, Switzerland.
    ///
    /// \rules
    /// is_iso_country_code:
    /// \endrules
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint CountryCode {
      get { return countryCode_; }
      set {
        countryCode_ = value;
      }
    }

    /// <summary>Field number for the "proj_string" field.</summary>
    public const int ProjStringFieldNumber = 14;
    private string projString_ = "";
    /// <summary>
    /// Projection string that allows to transform all coordinates in GroundTruth
    /// into a different cartographic projection.
    ///
    /// The string follows the PROJ rules for projections [1].
    ///
    /// \par Reference:
    /// [1] PROJ contributors. (2019). &lt;em>PROJ coordinate transformation software library&lt;/em>. Open Source Geospatial Foundation. Retrieved January 25, 2019, from https://proj.org/usage/projections.html
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ProjString {
      get { return projString_; }
      set {
        projString_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "map_reference" field.</summary>
    public const int MapReferenceFieldNumber = 15;
    private string mapReference_ = "";
    /// <summary>
    /// Opaque reference of a map.
    ///
    /// \note Origin and orientation of the map have to coincide with the
    /// inertial coordinate frame of the ground truth.
    ///
    /// \note It is implementation-specific how map_reference is resolved.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string MapReference {
      get { return mapReference_; }
      set {
        mapReference_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "model_reference" field.</summary>
    public const int ModelReferenceFieldNumber = 16;
    private string modelReference_ = "";
    /// <summary>
    /// Opaque reference of an associated 3D model.
    ///
    /// The model covers the static parts of the environment that are not
    /// provided as individual models referenced from ground truth objects
    /// like moving or stationary objects.
    ///
    /// \note Origin and orientation of the model have to coincide with the
    /// inertial coordinate frame of the ground truth.
    ///
    /// \note It is implementation-specific how model_references are resolved to
    /// 3d models. The parts the world model contains are also implementation-specific.
    /// For example, the world model can either contain street geometries or
    /// derives street geometries automatically from a map reference.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ModelReference {
      get { return modelReference_; }
      set {
        modelReference_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "reference_line" field.</summary>
    public const int ReferenceLineFieldNumber = 17;
    private static readonly pb::FieldCodec<global::Osi3.ReferenceLine> _repeated_referenceLine_codec
        = pb::FieldCodec.ForMessage(138, global::Osi3.ReferenceLine.Parser);
    private readonly pbc::RepeatedField<global::Osi3.ReferenceLine> referenceLine_ = new pbc::RepeatedField<global::Osi3.ReferenceLine>();
    /// <summary>
    /// Reference lines used by LogicalLane
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Osi3.ReferenceLine> ReferenceLine {
      get { return referenceLine_; }
    }

    /// <summary>Field number for the "logical_lane_boundary" field.</summary>
    public const int LogicalLaneBoundaryFieldNumber = 18;
    private static readonly pb::FieldCodec<global::Osi3.LogicalLaneBoundary> _repeated_logicalLaneBoundary_codec
        = pb::FieldCodec.ForMessage(146, global::Osi3.LogicalLaneBoundary.Parser);
    private readonly pbc::RepeatedField<global::Osi3.LogicalLaneBoundary> logicalLaneBoundary_ = new pbc::RepeatedField<global::Osi3.LogicalLaneBoundary>();
    /// <summary>
    /// Logical lane boundaries used by LogicalLane
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Osi3.LogicalLaneBoundary> LogicalLaneBoundary {
      get { return logicalLaneBoundary_; }
    }

    /// <summary>Field number for the "logical_lane" field.</summary>
    public const int LogicalLaneFieldNumber = 19;
    private static readonly pb::FieldCodec<global::Osi3.LogicalLane> _repeated_logicalLane_codec
        = pb::FieldCodec.ForMessage(154, global::Osi3.LogicalLane.Parser);
    private readonly pbc::RepeatedField<global::Osi3.LogicalLane> logicalLane_ = new pbc::RepeatedField<global::Osi3.LogicalLane>();
    /// <summary>
    /// Logical lanes used e.g. by traffic agents
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Osi3.LogicalLane> LogicalLane {
      get { return logicalLane_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GroundTruth);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GroundTruth other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Version, other.Version)) return false;
      if (!object.Equals(Timestamp, other.Timestamp)) return false;
      if (!object.Equals(HostVehicleId, other.HostVehicleId)) return false;
      if(!stationaryObject_.Equals(other.stationaryObject_)) return false;
      if(!movingObject_.Equals(other.movingObject_)) return false;
      if(!trafficSign_.Equals(other.trafficSign_)) return false;
      if(!trafficLight_.Equals(other.trafficLight_)) return false;
      if(!roadMarking_.Equals(other.roadMarking_)) return false;
      if(!laneBoundary_.Equals(other.laneBoundary_)) return false;
      if(!lane_.Equals(other.lane_)) return false;
      if(!occupant_.Equals(other.occupant_)) return false;
      if (!object.Equals(EnvironmentalConditions, other.EnvironmentalConditions)) return false;
      if (CountryCode != other.CountryCode) return false;
      if (ProjString != other.ProjString) return false;
      if (MapReference != other.MapReference) return false;
      if (ModelReference != other.ModelReference) return false;
      if(!referenceLine_.Equals(other.referenceLine_)) return false;
      if(!logicalLaneBoundary_.Equals(other.logicalLaneBoundary_)) return false;
      if(!logicalLane_.Equals(other.logicalLane_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (version_ != null) hash ^= Version.GetHashCode();
      if (timestamp_ != null) hash ^= Timestamp.GetHashCode();
      if (hostVehicleId_ != null) hash ^= HostVehicleId.GetHashCode();
      hash ^= stationaryObject_.GetHashCode();
      hash ^= movingObject_.GetHashCode();
      hash ^= trafficSign_.GetHashCode();
      hash ^= trafficLight_.GetHashCode();
      hash ^= roadMarking_.GetHashCode();
      hash ^= laneBoundary_.GetHashCode();
      hash ^= lane_.GetHashCode();
      hash ^= occupant_.GetHashCode();
      if (environmentalConditions_ != null) hash ^= EnvironmentalConditions.GetHashCode();
      if (CountryCode != 0) hash ^= CountryCode.GetHashCode();
      if (ProjString.Length != 0) hash ^= ProjString.GetHashCode();
      if (MapReference.Length != 0) hash ^= MapReference.GetHashCode();
      if (ModelReference.Length != 0) hash ^= ModelReference.GetHashCode();
      hash ^= referenceLine_.GetHashCode();
      hash ^= logicalLaneBoundary_.GetHashCode();
      hash ^= logicalLane_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (version_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Version);
      }
      if (timestamp_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Timestamp);
      }
      if (hostVehicleId_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(HostVehicleId);
      }
      stationaryObject_.WriteTo(output, _repeated_stationaryObject_codec);
      movingObject_.WriteTo(output, _repeated_movingObject_codec);
      trafficSign_.WriteTo(output, _repeated_trafficSign_codec);
      trafficLight_.WriteTo(output, _repeated_trafficLight_codec);
      roadMarking_.WriteTo(output, _repeated_roadMarking_codec);
      laneBoundary_.WriteTo(output, _repeated_laneBoundary_codec);
      lane_.WriteTo(output, _repeated_lane_codec);
      occupant_.WriteTo(output, _repeated_occupant_codec);
      if (environmentalConditions_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(EnvironmentalConditions);
      }
      if (CountryCode != 0) {
        output.WriteRawTag(104);
        output.WriteUInt32(CountryCode);
      }
      if (ProjString.Length != 0) {
        output.WriteRawTag(114);
        output.WriteString(ProjString);
      }
      if (MapReference.Length != 0) {
        output.WriteRawTag(122);
        output.WriteString(MapReference);
      }
      if (ModelReference.Length != 0) {
        output.WriteRawTag(130, 1);
        output.WriteString(ModelReference);
      }
      referenceLine_.WriteTo(output, _repeated_referenceLine_codec);
      logicalLaneBoundary_.WriteTo(output, _repeated_logicalLaneBoundary_codec);
      logicalLane_.WriteTo(output, _repeated_logicalLane_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (version_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Version);
      }
      if (timestamp_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Timestamp);
      }
      if (hostVehicleId_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(HostVehicleId);
      }
      stationaryObject_.WriteTo(ref output, _repeated_stationaryObject_codec);
      movingObject_.WriteTo(ref output, _repeated_movingObject_codec);
      trafficSign_.WriteTo(ref output, _repeated_trafficSign_codec);
      trafficLight_.WriteTo(ref output, _repeated_trafficLight_codec);
      roadMarking_.WriteTo(ref output, _repeated_roadMarking_codec);
      laneBoundary_.WriteTo(ref output, _repeated_laneBoundary_codec);
      lane_.WriteTo(ref output, _repeated_lane_codec);
      occupant_.WriteTo(ref output, _repeated_occupant_codec);
      if (environmentalConditions_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(EnvironmentalConditions);
      }
      if (CountryCode != 0) {
        output.WriteRawTag(104);
        output.WriteUInt32(CountryCode);
      }
      if (ProjString.Length != 0) {
        output.WriteRawTag(114);
        output.WriteString(ProjString);
      }
      if (MapReference.Length != 0) {
        output.WriteRawTag(122);
        output.WriteString(MapReference);
      }
      if (ModelReference.Length != 0) {
        output.WriteRawTag(130, 1);
        output.WriteString(ModelReference);
      }
      referenceLine_.WriteTo(ref output, _repeated_referenceLine_codec);
      logicalLaneBoundary_.WriteTo(ref output, _repeated_logicalLaneBoundary_codec);
      logicalLane_.WriteTo(ref output, _repeated_logicalLane_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (version_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Version);
      }
      if (timestamp_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Timestamp);
      }
      if (hostVehicleId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(HostVehicleId);
      }
      size += stationaryObject_.CalculateSize(_repeated_stationaryObject_codec);
      size += movingObject_.CalculateSize(_repeated_movingObject_codec);
      size += trafficSign_.CalculateSize(_repeated_trafficSign_codec);
      size += trafficLight_.CalculateSize(_repeated_trafficLight_codec);
      size += roadMarking_.CalculateSize(_repeated_roadMarking_codec);
      size += laneBoundary_.CalculateSize(_repeated_laneBoundary_codec);
      size += lane_.CalculateSize(_repeated_lane_codec);
      size += occupant_.CalculateSize(_repeated_occupant_codec);
      if (environmentalConditions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(EnvironmentalConditions);
      }
      if (CountryCode != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(CountryCode);
      }
      if (ProjString.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ProjString);
      }
      if (MapReference.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(MapReference);
      }
      if (ModelReference.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(ModelReference);
      }
      size += referenceLine_.CalculateSize(_repeated_referenceLine_codec);
      size += logicalLaneBoundary_.CalculateSize(_repeated_logicalLaneBoundary_codec);
      size += logicalLane_.CalculateSize(_repeated_logicalLane_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GroundTruth other) {
      if (other == null) {
        return;
      }
      if (other.version_ != null) {
        if (version_ == null) {
          Version = new global::Osi3.InterfaceVersion();
        }
        Version.MergeFrom(other.Version);
      }
      if (other.timestamp_ != null) {
        if (timestamp_ == null) {
          Timestamp = new global::Osi3.Timestamp();
        }
        Timestamp.MergeFrom(other.Timestamp);
      }
      if (other.hostVehicleId_ != null) {
        if (hostVehicleId_ == null) {
          HostVehicleId = new global::Osi3.Identifier();
        }
        HostVehicleId.MergeFrom(other.HostVehicleId);
      }
      stationaryObject_.Add(other.stationaryObject_);
      movingObject_.Add(other.movingObject_);
      trafficSign_.Add(other.trafficSign_);
      trafficLight_.Add(other.trafficLight_);
      roadMarking_.Add(other.roadMarking_);
      laneBoundary_.Add(other.laneBoundary_);
      lane_.Add(other.lane_);
      occupant_.Add(other.occupant_);
      if (other.environmentalConditions_ != null) {
        if (environmentalConditions_ == null) {
          EnvironmentalConditions = new global::Osi3.EnvironmentalConditions();
        }
        EnvironmentalConditions.MergeFrom(other.EnvironmentalConditions);
      }
      if (other.CountryCode != 0) {
        CountryCode = other.CountryCode;
      }
      if (other.ProjString.Length != 0) {
        ProjString = other.ProjString;
      }
      if (other.MapReference.Length != 0) {
        MapReference = other.MapReference;
      }
      if (other.ModelReference.Length != 0) {
        ModelReference = other.ModelReference;
      }
      referenceLine_.Add(other.referenceLine_);
      logicalLaneBoundary_.Add(other.logicalLaneBoundary_);
      logicalLane_.Add(other.logicalLane_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (version_ == null) {
              Version = new global::Osi3.InterfaceVersion();
            }
            input.ReadMessage(Version);
            break;
          }
          case 18: {
            if (timestamp_ == null) {
              Timestamp = new global::Osi3.Timestamp();
            }
            input.ReadMessage(Timestamp);
            break;
          }
          case 26: {
            if (hostVehicleId_ == null) {
              HostVehicleId = new global::Osi3.Identifier();
            }
            input.ReadMessage(HostVehicleId);
            break;
          }
          case 34: {
            stationaryObject_.AddEntriesFrom(input, _repeated_stationaryObject_codec);
            break;
          }
          case 42: {
            movingObject_.AddEntriesFrom(input, _repeated_movingObject_codec);
            break;
          }
          case 50: {
            trafficSign_.AddEntriesFrom(input, _repeated_trafficSign_codec);
            break;
          }
          case 58: {
            trafficLight_.AddEntriesFrom(input, _repeated_trafficLight_codec);
            break;
          }
          case 66: {
            roadMarking_.AddEntriesFrom(input, _repeated_roadMarking_codec);
            break;
          }
          case 74: {
            laneBoundary_.AddEntriesFrom(input, _repeated_laneBoundary_codec);
            break;
          }
          case 82: {
            lane_.AddEntriesFrom(input, _repeated_lane_codec);
            break;
          }
          case 90: {
            occupant_.AddEntriesFrom(input, _repeated_occupant_codec);
            break;
          }
          case 98: {
            if (environmentalConditions_ == null) {
              EnvironmentalConditions = new global::Osi3.EnvironmentalConditions();
            }
            input.ReadMessage(EnvironmentalConditions);
            break;
          }
          case 104: {
            CountryCode = input.ReadUInt32();
            break;
          }
          case 114: {
            ProjString = input.ReadString();
            break;
          }
          case 122: {
            MapReference = input.ReadString();
            break;
          }
          case 130: {
            ModelReference = input.ReadString();
            break;
          }
          case 138: {
            referenceLine_.AddEntriesFrom(input, _repeated_referenceLine_codec);
            break;
          }
          case 146: {
            logicalLaneBoundary_.AddEntriesFrom(input, _repeated_logicalLaneBoundary_codec);
            break;
          }
          case 154: {
            logicalLane_.AddEntriesFrom(input, _repeated_logicalLane_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (version_ == null) {
              Version = new global::Osi3.InterfaceVersion();
            }
            input.ReadMessage(Version);
            break;
          }
          case 18: {
            if (timestamp_ == null) {
              Timestamp = new global::Osi3.Timestamp();
            }
            input.ReadMessage(Timestamp);
            break;
          }
          case 26: {
            if (hostVehicleId_ == null) {
              HostVehicleId = new global::Osi3.Identifier();
            }
            input.ReadMessage(HostVehicleId);
            break;
          }
          case 34: {
            stationaryObject_.AddEntriesFrom(ref input, _repeated_stationaryObject_codec);
            break;
          }
          case 42: {
            movingObject_.AddEntriesFrom(ref input, _repeated_movingObject_codec);
            break;
          }
          case 50: {
            trafficSign_.AddEntriesFrom(ref input, _repeated_trafficSign_codec);
            break;
          }
          case 58: {
            trafficLight_.AddEntriesFrom(ref input, _repeated_trafficLight_codec);
            break;
          }
          case 66: {
            roadMarking_.AddEntriesFrom(ref input, _repeated_roadMarking_codec);
            break;
          }
          case 74: {
            laneBoundary_.AddEntriesFrom(ref input, _repeated_laneBoundary_codec);
            break;
          }
          case 82: {
            lane_.AddEntriesFrom(ref input, _repeated_lane_codec);
            break;
          }
          case 90: {
            occupant_.AddEntriesFrom(ref input, _repeated_occupant_codec);
            break;
          }
          case 98: {
            if (environmentalConditions_ == null) {
              EnvironmentalConditions = new global::Osi3.EnvironmentalConditions();
            }
            input.ReadMessage(EnvironmentalConditions);
            break;
          }
          case 104: {
            CountryCode = input.ReadUInt32();
            break;
          }
          case 114: {
            ProjString = input.ReadString();
            break;
          }
          case 122: {
            MapReference = input.ReadString();
            break;
          }
          case 130: {
            ModelReference = input.ReadString();
            break;
          }
          case 138: {
            referenceLine_.AddEntriesFrom(ref input, _repeated_referenceLine_codec);
            break;
          }
          case 146: {
            logicalLaneBoundary_.AddEntriesFrom(ref input, _repeated_logicalLaneBoundary_codec);
            break;
          }
          case 154: {
            logicalLane_.AddEntriesFrom(ref input, _repeated_logicalLane_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
