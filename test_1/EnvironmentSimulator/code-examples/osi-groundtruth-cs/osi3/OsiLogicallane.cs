// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: osi_logicallane.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Osi3 {

  /// <summary>Holder for reflection information generated from osi_logicallane.proto</summary>
  public static partial class OsiLogicallaneReflection {

    #region Descriptor
    /// <summary>File descriptor for osi_logicallane.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static OsiLogicallaneReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChVvc2lfbG9naWNhbGxhbmUucHJvdG8SBG9zaTMaEG9zaV9jb21tb24ucHJv",
            "dG8i5wQKE0xvZ2ljYWxMYW5lQm91bmRhcnkSHAoCaWQYASABKAsyEC5vc2kz",
            "LklkZW50aWZpZXISRQoNYm91bmRhcnlfbGluZRgCIAMoCzIuLm9zaTMuTG9n",
            "aWNhbExhbmVCb3VuZGFyeS5Mb2dpY2FsQm91bmRhcnlQb2ludBIrChFyZWZl",
            "cmVuY2VfbGluZV9pZBgDIAEoCzIQLm9zaTMuSWRlbnRpZmllchIuChRwaHlz",
            "aWNhbF9ib3VuZGFyeV9pZBgEIAMoCzIQLm9zaTMuSWRlbnRpZmllchI7Cgxw",
            "YXNzaW5nX3J1bGUYBSABKA4yJS5vc2kzLkxvZ2ljYWxMYW5lQm91bmRhcnku",
            "UGFzc2luZ1J1bGUSMQoQc291cmNlX3JlZmVyZW5jZRgGIAMoCzIXLm9zaTMu",
            "RXh0ZXJuYWxSZWZlcmVuY2UaYAoUTG9naWNhbEJvdW5kYXJ5UG9pbnQSIAoI",
            "cG9zaXRpb24YASABKAsyDi5vc2kzLlZlY3RvcjNkEhIKCnNfcG9zaXRpb24Y",
            "AiABKAESEgoKdF9wb3NpdGlvbhgDIAEoASK7AQoLUGFzc2luZ1J1bGUSGAoU",
            "UEFTU0lOR19SVUxFX1VOS05PV04QABIWChJQQVNTSU5HX1JVTEVfT1RIRVIQ",
            "ARIdChlQQVNTSU5HX1JVTEVfTk9ORV9BTExPV0VEEAISHQoZUEFTU0lOR19S",
            "VUxFX0lOQ1JFQVNJTkdfVBADEh0KGVBBU1NJTkdfUlVMRV9ERUNSRUFTSU5H",
            "X1QQBBIdChlQQVNTSU5HX1JVTEVfQk9USF9BTExPV0VEEAUimgwKC0xvZ2lj",
            "YWxMYW5lEhwKAmlkGAEgASgLMhAub3NpMy5JZGVudGlmaWVyEiQKBHR5cGUY",
            "AiABKA4yFi5vc2kzLkxvZ2ljYWxMYW5lLlR5cGUSMQoQc291cmNlX3JlZmVy",
            "ZW5jZRgDIAMoCzIXLm9zaTMuRXh0ZXJuYWxSZWZlcmVuY2USSAoXcGh5c2lj",
            "YWxfbGFuZV9yZWZlcmVuY2UYBCADKAsyJy5vc2kzLkxvZ2ljYWxMYW5lLlBo",
            "eXNpY2FsTGFuZVJlZmVyZW5jZRIrChFyZWZlcmVuY2VfbGluZV9pZBgFIAEo",
            "CzIQLm9zaTMuSWRlbnRpZmllchIPCgdzdGFydF9zGAYgASgBEg0KBWVuZF9z",
            "GAcgASgBEjcKDm1vdmVfZGlyZWN0aW9uGAggASgOMh8ub3NpMy5Mb2dpY2Fs",
            "TGFuZS5Nb3ZlRGlyZWN0aW9uEjsKE3JpZ2h0X2FkamFjZW50X2xhbmUYCSAD",
            "KAsyHi5vc2kzLkxvZ2ljYWxMYW5lLkxhbmVSZWxhdGlvbhI6ChJsZWZ0X2Fk",
            "amFjZW50X2xhbmUYCiADKAsyHi5vc2kzLkxvZ2ljYWxMYW5lLkxhbmVSZWxh",
            "dGlvbhI4ChBvdmVybGFwcGluZ19sYW5lGAsgAygLMh4ub3NpMy5Mb2dpY2Fs",
            "TGFuZS5MYW5lUmVsYXRpb24SKwoRcmlnaHRfYm91bmRhcnlfaWQYDCADKAsy",
            "EC5vc2kzLklkZW50aWZpZXISKgoQbGVmdF9ib3VuZGFyeV9pZBgNIAMoCzIQ",
            "Lm9zaTMuSWRlbnRpZmllchI6ChBwcmVkZWNlc3Nvcl9sYW5lGA4gAygLMiAu",
            "b3NpMy5Mb2dpY2FsTGFuZS5MYW5lQ29ubmVjdGlvbhI4Cg5zdWNjZXNzb3Jf",
            "bGFuZRgPIAMoCzIgLm9zaTMuTG9naWNhbExhbmUuTGFuZUNvbm5lY3Rpb24a",
            "YwoVUGh5c2ljYWxMYW5lUmVmZXJlbmNlEioKEHBoeXNpY2FsX2xhbmVfaWQY",
            "ASABKAsyEC5vc2kzLklkZW50aWZpZXISDwoHc3RhcnRfcxgCIAEoARINCgVl",
            "bmRfcxgDIAEoARpZCg5MYW5lQ29ubmVjdGlvbhInCg1vdGhlcl9sYW5lX2lk",
            "GAEgASgLMhAub3NpMy5JZGVudGlmaWVyEh4KFmF0X2JlZ2luX29mX290aGVy",
            "X2xhbmUYAiABKAgagwEKDExhbmVSZWxhdGlvbhInCg1vdGhlcl9sYW5lX2lk",
            "GAEgASgLMhAub3NpMy5JZGVudGlmaWVyEg8KB3N0YXJ0X3MYAiABKAESDQoF",
            "ZW5kX3MYAyABKAESFQoNc3RhcnRfc19vdGhlchgEIAEoARITCgtlbmRfc19v",
            "dGhlchgFIAEoASLQAgoEVHlwZRIQCgxUWVBFX1VOS05PV04QABIOCgpUWVBF",
            "X09USEVSEAESDwoLVFlQRV9OT1JNQUwQAhIPCgtUWVBFX0JJS0lORxADEhEK",
            "DVRZUEVfU0lERVdBTEsQBBIQCgxUWVBFX1BBUktJTkcQBRINCglUWVBFX1NU",
            "T1AQBhITCg9UWVBFX1JFU1RSSUNURUQQBxIPCgtUWVBFX0JPUkRFUhAIEhEK",
            "DVRZUEVfU0hPVUxERVIQCRINCglUWVBFX0VYSVQQChIOCgpUWVBFX0VOVFJZ",
            "EAsSDwoLVFlQRV9PTlJBTVAQDBIQCgxUWVBFX09GRlJBTVAQDRIXChNUWVBF",
            "X0NPTk5FQ1RJTkdSQU1QEA4SDwoLVFlQRV9NRURJQU4QDxINCglUWVBFX0NV",
            "UkIQEBINCglUWVBFX1JBSUwQERINCglUWVBFX1RSQU0QEiKoAQoNTW92ZURp",
            "cmVjdGlvbhIaChZNT1ZFX0RJUkVDVElPTl9VTktOT1dOEAASGAoUTU9WRV9E",
            "SVJFQ1RJT05fT1RIRVIQARIfChtNT1ZFX0RJUkVDVElPTl9JTkNSRUFTSU5H",
            "X1MQAhIfChtNT1ZFX0RJUkVDVElPTl9ERUNSRUFTSU5HX1MQAxIfChtNT1ZF",
            "X0RJUkVDVElPTl9CT1RIX0FMTE9XRUQQBEICSAFiBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Osi3.OsiCommonReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Osi3.LogicalLaneBoundary), global::Osi3.LogicalLaneBoundary.Parser, new[]{ "Id", "BoundaryLine", "ReferenceLineId", "PhysicalBoundaryId", "PassingRule", "SourceReference" }, null, new[]{ typeof(global::Osi3.LogicalLaneBoundary.Types.PassingRule) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Osi3.LogicalLaneBoundary.Types.LogicalBoundaryPoint), global::Osi3.LogicalLaneBoundary.Types.LogicalBoundaryPoint.Parser, new[]{ "Position", "SPosition", "TPosition" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Osi3.LogicalLane), global::Osi3.LogicalLane.Parser, new[]{ "Id", "Type", "SourceReference", "PhysicalLaneReference", "ReferenceLineId", "StartS", "EndS", "MoveDirection", "RightAdjacentLane", "LeftAdjacentLane", "OverlappingLane", "RightBoundaryId", "LeftBoundaryId", "PredecessorLane", "SuccessorLane" }, null, new[]{ typeof(global::Osi3.LogicalLane.Types.Type), typeof(global::Osi3.LogicalLane.Types.MoveDirection) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Osi3.LogicalLane.Types.PhysicalLaneReference), global::Osi3.LogicalLane.Types.PhysicalLaneReference.Parser, new[]{ "PhysicalLaneId", "StartS", "EndS" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Osi3.LogicalLane.Types.LaneConnection), global::Osi3.LogicalLane.Types.LaneConnection.Parser, new[]{ "OtherLaneId", "AtBeginOfOtherLane" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Osi3.LogicalLane.Types.LaneRelation), global::Osi3.LogicalLane.Types.LaneRelation.Parser, new[]{ "OtherLaneId", "StartS", "EndS", "StartSOther", "EndSOther" }, null, null, null, null)})
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  ///
  /// \brief Boundary line of a LogicalLane
  ///
  /// Similar to a LaneBoundary, but with a reference line and ST positions.
  ///
  /// A logical lane boundary describes the boundary between two logical lanes. As
  /// such, there will always be exactly one logical lane boundary between two
  /// lanes at a given S position. Contrary to that, there can be 0 to N physical
  /// lane boundaries (i.e. type LaneBoundary) between two logical lanes at a
  /// given S position.
  ///
  /// If there are multiple physical lane boundaries at one S position between two
  /// lanes (think of a solid-broken marking, which would be described by two
  /// LaneBoundary objects, one for the solid lane marking, one for the broken lane
  /// marking), then the single LogicalLaneBoundary describing the boundary between
  /// two logical lanes should be between the physical boundaries.
  ///
  /// A logical lane boundary consists of a list of \link LogicalBoundaryPoint
  /// LogicalBoundaryPoints\endlink. Each point has a XYZ and an ST coordinate.
  /// The XYZ coordinates describe the position and height of the boundary in the
  /// world.
  ///
  /// Notes on design decisions:
  /// - The LogicalLaneBoundary has ST coordinates, and is thus a separate type
  ///   from LaneBoundary.
  ///   Advantages of this decision:
  ///   - Calculations like getting the lane width at a position are easy, since
  ///     one can just get the boundary points of the left and right boundary at
  ///     the desired S position (via linear interpolation), and calculate the
  ///     width from the two points. Also getting something like the distance to
  ///     the lane border is very easy.
  ///   - No centerline of the lane is necessary, since this can very easily be
  ///     generated from the boundaries.
  ///   Disadvantages of this decision:
  ///   - %Lane boundaries cannot be shared with physical lanes. This results in
  ///     more data needed. This can mostly be mitigated by only transmitting the
  ///     lane boundaries during initialization (e.g. via the OSMP GroundTruthInit
  ///     message).
  /// - The LogicalLaneBoundary contains all data directly which an agent model is
  ///   likely to need. It does not include information normally only used by
  ///   sensor models (e.g. the exact length of the color markings on the road).
  ///   This information can be gotten from the physical lane referenced in the
  ///   LogicalLane, if needed.
  /// </summary>
  public sealed partial class LogicalLaneBoundary : pb::IMessage<LogicalLaneBoundary>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<LogicalLaneBoundary> _parser = new pb::MessageParser<LogicalLaneBoundary>(() => new LogicalLaneBoundary());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<LogicalLaneBoundary> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Osi3.OsiLogicallaneReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LogicalLaneBoundary() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LogicalLaneBoundary(LogicalLaneBoundary other) : this() {
      id_ = other.id_ != null ? other.id_.Clone() : null;
      boundaryLine_ = other.boundaryLine_.Clone();
      referenceLineId_ = other.referenceLineId_ != null ? other.referenceLineId_.Clone() : null;
      physicalBoundaryId_ = other.physicalBoundaryId_.Clone();
      passingRule_ = other.passingRule_;
      sourceReference_ = other.sourceReference_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LogicalLaneBoundary Clone() {
      return new LogicalLaneBoundary(this);
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private global::Osi3.Identifier id_;
    /// <summary>
    /// The ID of the lane boundary.
    ///
    /// \rules
    /// is_globally_unique
    /// \endrules
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.Identifier Id {
      get { return id_; }
      set {
        id_ = value;
      }
    }

    /// <summary>Field number for the "boundary_line" field.</summary>
    public const int BoundaryLineFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Osi3.LogicalLaneBoundary.Types.LogicalBoundaryPoint> _repeated_boundaryLine_codec
        = pb::FieldCodec.ForMessage(18, global::Osi3.LogicalLaneBoundary.Types.LogicalBoundaryPoint.Parser);
    private readonly pbc::RepeatedField<global::Osi3.LogicalLaneBoundary.Types.LogicalBoundaryPoint> boundaryLine_ = new pbc::RepeatedField<global::Osi3.LogicalLaneBoundary.Types.LogicalBoundaryPoint>();
    /// <summary>
    /// Points making up the lane boundary.
    ///
    /// The boundary must be defined in the same direction as the reference
    /// line. So S positions should increase along the line. Note that S
    /// positions will not always increase strictly monotonically.
    /// Example:
    /// &lt;pre>
    ///                |---------\
    ///                |          \
    ///  /---boundary--|           \\------------
    /// /
    /// ---------- reference line --------------
    /// &lt;/pre>
    /// At the place where the boundary suddenly increases, two points will have
    /// the same S coordinate.
    ///
    /// If the boundary approximates a curve (e.g. a cubic function in
    /// OpenDRIVE), the points must be chosen in a way that the lateral distance
    /// to the ideal line does not exceed 5cm. As shown in the following image:
    ///
    /// \image html line_approximation_error.svg "Approximation error"
    /// Approximation error green line.
    ///
    /// The Z error (difference in Z height between #boundary_line and the
    /// "real" line) must not exceed 2cm. This is a stricter requirement than
    /// for errors in the XY plane, because Z differences between lanes
    /// influence driving very much.
    ///
    /// Note: if two lanes have different Z heights (e.g. a driving lane is
    /// beside a sidewalk, where the sidewalk is 10cm higher than the road),
    /// then these lanes cannot share a boundary, since their boundaries have
    /// different Z heights.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Osi3.LogicalLaneBoundary.Types.LogicalBoundaryPoint> BoundaryLine {
      get { return boundaryLine_; }
    }

    /// <summary>Field number for the "reference_line_id" field.</summary>
    public const int ReferenceLineIdFieldNumber = 3;
    private global::Osi3.Identifier referenceLineId_;
    /// <summary>
    /// The reference line for this boundary.
    ///
    /// The reference line is used as a coordinate system for this boundary.
    /// All points of this LogicalLaneBoundary must have S coordinates in the
    /// range [\c sStart,\c sEnd].
    ///
    /// The reference line should roughly have the same shape as the boundary (so
    /// roughly parallel to the lane middle), so that S coordinates continually
    /// increase along the boundary.
    ///
    /// \rules
    /// refers_to: ReferenceLine
    /// \endrules
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.Identifier ReferenceLineId {
      get { return referenceLineId_; }
      set {
        referenceLineId_ = value;
      }
    }

    /// <summary>Field number for the "physical_boundary_id" field.</summary>
    public const int PhysicalBoundaryIdFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Osi3.Identifier> _repeated_physicalBoundaryId_codec
        = pb::FieldCodec.ForMessage(34, global::Osi3.Identifier.Parser);
    private readonly pbc::RepeatedField<global::Osi3.Identifier> physicalBoundaryId_ = new pbc::RepeatedField<global::Osi3.Identifier>();
    /// <summary>
    /// Reference to the physical lane boundary or boundaries that make up this
    /// logical boundary.
    ///
    /// Rules and notes:
    /// - This list is empty if there are no physical lane boundaries to delimit
    ///   a lane.
    /// - In the common case, this will contain one physical boundary.
    /// - This list contains several lane boundaries if there are several physical
    ///   lane boundaries at one S position (e.g. both a broken and a solid
    ///   line).
    /// - If there are several lane boundaries, they must be listed in increasing
    ///   T order (i.e. from right to left in reference line direction).
    ///   Rationale: this makes it easier to determine e.g. rules on lane
    ///   changes, which depend on the T order of the lanes.
    /// - Whenever physical lane boundaries begin or end, or switch their T
    ///   position (if there are multiple physical lane boundaries), a new
    ///   LogicalLaneBoundary must be created.
    /// - The referenced LaneBoundary objects may be longer than the
    ///   LogicalLaneBoundary which references them, but must never be shorter.
    ///
    /// Example:
    /// &lt;pre>
    ///       Lane 1
    ///  --------a------------------ - - - -c- - - -           ----&amp;gt;
    ///  \- - - -b- - - -
    ///       Lane -1
    /// &lt;/pre>
    ///
    /// This shows the boundary between lane 1 and lane -1, with the reference
    /// line going from left to right. First there is a solid-broken line (a and
    /// b), then there is only a solid line (a), then there is a broken line
    /// (c). There would be three LogicalLaneBoundary objects between Lane1 and
    /// Lane2: the first would reference first b and then a, the second would
    /// reference only a, and the third would reference c.
    ///
    /// \rules
    /// refers_to: LaneBoundary
    /// \endrules
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Osi3.Identifier> PhysicalBoundaryId {
      get { return physicalBoundaryId_; }
    }

    /// <summary>Field number for the "passing_rule" field.</summary>
    public const int PassingRuleFieldNumber = 5;
    private global::Osi3.LogicalLaneBoundary.Types.PassingRule passingRule_ = global::Osi3.LogicalLaneBoundary.Types.PassingRule.Unknown;
    /// <summary>
    /// The passing rules, insomuch as they can be determined just from road
    /// markings.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.LogicalLaneBoundary.Types.PassingRule PassingRule {
      get { return passingRule_; }
      set {
        passingRule_ = value;
      }
    }

    /// <summary>Field number for the "source_reference" field.</summary>
    public const int SourceReferenceFieldNumber = 6;
    private static readonly pb::FieldCodec<global::Osi3.ExternalReference> _repeated_sourceReference_codec
        = pb::FieldCodec.ForMessage(50, global::Osi3.ExternalReference.Parser);
    private readonly pbc::RepeatedField<global::Osi3.ExternalReference> sourceReference_ = new pbc::RepeatedField<global::Osi3.ExternalReference>();
    /// <summary>
    /// Optional external reference to the lane boundary source.
    ///
    /// \note For OpenDRIVE, there is no direct possibility to reference the
    ///       RoadMark, as there is no unique identifier in this sub-object.
    ///
    /// \note For non-ASAM Standards, it is implementation-specific how
    ///       source_reference is resolved.
    ///
    /// \note The value has to be repeated because one object may be derived
    ///       from more than one origin source, for example, from a scenario file
    ///       and from sensors.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Osi3.ExternalReference> SourceReference {
      get { return sourceReference_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as LogicalLaneBoundary);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(LogicalLaneBoundary other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Id, other.Id)) return false;
      if(!boundaryLine_.Equals(other.boundaryLine_)) return false;
      if (!object.Equals(ReferenceLineId, other.ReferenceLineId)) return false;
      if(!physicalBoundaryId_.Equals(other.physicalBoundaryId_)) return false;
      if (PassingRule != other.PassingRule) return false;
      if(!sourceReference_.Equals(other.sourceReference_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (id_ != null) hash ^= Id.GetHashCode();
      hash ^= boundaryLine_.GetHashCode();
      if (referenceLineId_ != null) hash ^= ReferenceLineId.GetHashCode();
      hash ^= physicalBoundaryId_.GetHashCode();
      if (PassingRule != global::Osi3.LogicalLaneBoundary.Types.PassingRule.Unknown) hash ^= PassingRule.GetHashCode();
      hash ^= sourceReference_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (id_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Id);
      }
      boundaryLine_.WriteTo(output, _repeated_boundaryLine_codec);
      if (referenceLineId_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(ReferenceLineId);
      }
      physicalBoundaryId_.WriteTo(output, _repeated_physicalBoundaryId_codec);
      if (PassingRule != global::Osi3.LogicalLaneBoundary.Types.PassingRule.Unknown) {
        output.WriteRawTag(40);
        output.WriteEnum((int) PassingRule);
      }
      sourceReference_.WriteTo(output, _repeated_sourceReference_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (id_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Id);
      }
      boundaryLine_.WriteTo(ref output, _repeated_boundaryLine_codec);
      if (referenceLineId_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(ReferenceLineId);
      }
      physicalBoundaryId_.WriteTo(ref output, _repeated_physicalBoundaryId_codec);
      if (PassingRule != global::Osi3.LogicalLaneBoundary.Types.PassingRule.Unknown) {
        output.WriteRawTag(40);
        output.WriteEnum((int) PassingRule);
      }
      sourceReference_.WriteTo(ref output, _repeated_sourceReference_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (id_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Id);
      }
      size += boundaryLine_.CalculateSize(_repeated_boundaryLine_codec);
      if (referenceLineId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ReferenceLineId);
      }
      size += physicalBoundaryId_.CalculateSize(_repeated_physicalBoundaryId_codec);
      if (PassingRule != global::Osi3.LogicalLaneBoundary.Types.PassingRule.Unknown) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) PassingRule);
      }
      size += sourceReference_.CalculateSize(_repeated_sourceReference_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(LogicalLaneBoundary other) {
      if (other == null) {
        return;
      }
      if (other.id_ != null) {
        if (id_ == null) {
          Id = new global::Osi3.Identifier();
        }
        Id.MergeFrom(other.Id);
      }
      boundaryLine_.Add(other.boundaryLine_);
      if (other.referenceLineId_ != null) {
        if (referenceLineId_ == null) {
          ReferenceLineId = new global::Osi3.Identifier();
        }
        ReferenceLineId.MergeFrom(other.ReferenceLineId);
      }
      physicalBoundaryId_.Add(other.physicalBoundaryId_);
      if (other.PassingRule != global::Osi3.LogicalLaneBoundary.Types.PassingRule.Unknown) {
        PassingRule = other.PassingRule;
      }
      sourceReference_.Add(other.sourceReference_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (id_ == null) {
              Id = new global::Osi3.Identifier();
            }
            input.ReadMessage(Id);
            break;
          }
          case 18: {
            boundaryLine_.AddEntriesFrom(input, _repeated_boundaryLine_codec);
            break;
          }
          case 26: {
            if (referenceLineId_ == null) {
              ReferenceLineId = new global::Osi3.Identifier();
            }
            input.ReadMessage(ReferenceLineId);
            break;
          }
          case 34: {
            physicalBoundaryId_.AddEntriesFrom(input, _repeated_physicalBoundaryId_codec);
            break;
          }
          case 40: {
            PassingRule = (global::Osi3.LogicalLaneBoundary.Types.PassingRule) input.ReadEnum();
            break;
          }
          case 50: {
            sourceReference_.AddEntriesFrom(input, _repeated_sourceReference_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (id_ == null) {
              Id = new global::Osi3.Identifier();
            }
            input.ReadMessage(Id);
            break;
          }
          case 18: {
            boundaryLine_.AddEntriesFrom(ref input, _repeated_boundaryLine_codec);
            break;
          }
          case 26: {
            if (referenceLineId_ == null) {
              ReferenceLineId = new global::Osi3.Identifier();
            }
            input.ReadMessage(ReferenceLineId);
            break;
          }
          case 34: {
            physicalBoundaryId_.AddEntriesFrom(ref input, _repeated_physicalBoundaryId_codec);
            break;
          }
          case 40: {
            PassingRule = (global::Osi3.LogicalLaneBoundary.Types.PassingRule) input.ReadEnum();
            break;
          }
          case 50: {
            sourceReference_.AddEntriesFrom(ref input, _repeated_sourceReference_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the LogicalLaneBoundary message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      ///
      /// Passing rule of the LogicalLaneBoundary.
      ///
      /// This describes how vehicles are legally allowed to move across the 
      /// LogicalLaneBoundary. The PassingRule is determined solely based 
      /// on the semantics of (physical) lane boundaries, not on any signs
      /// (i.e. it may be overridden by signs).
      /// </summary>
      public enum PassingRule {
        /// <summary>
        /// Passing rule is unknown (must not be used in ground truth).
        /// </summary>
        [pbr::OriginalName("PASSING_RULE_UNKNOWN")] Unknown = 0,
        /// <summary>
        /// Passing rule fits neither of the other categories.
        ///
        /// Example: this type needs to be used if passing depends on the agent
        /// type, e.g. if cars may change lane, but trucks may not.
        ///
        /// This value is also used between LogicalLanes where the traffic
        /// regulations do not say anything about passing rules (e.g. for a 
        /// LogicalLaneBoundary between LogicalLanes of TYPE_NORMAL 
        /// and TYPE_CURB or between LogicalLanes of TYPE_BORDER and 
        /// TYPE_SHOULDER) .
        /// </summary>
        [pbr::OriginalName("PASSING_RULE_OTHER")] Other = 1,
        /// <summary>
        /// No passing is allowed (neither from left to right nor from right to
        /// left).
        /// </summary>
        [pbr::OriginalName("PASSING_RULE_NONE_ALLOWED")] NoneAllowed = 2,
        /// <summary>
        /// Only passing in increasing T direction allowed. Passing is allowed
        /// from one lane to the other if the points on the target lane have
        /// larger T values than points on the source lane (at the same S
        /// position). In reference line direction (but not necessarily in
        /// driving direction), this means changing from right to left is
        /// allowed.
        /// </summary>
        [pbr::OriginalName("PASSING_RULE_INCREASING_T")] IncreasingT = 3,
        /// <summary>
        /// Only passing in decreasing T direction allowed. Passing is allowed
        /// from one lane to the other if the points on the target lane have
        /// smaller T values than points on the source lane (at the same S
        /// position). In reference line direction (but not necessarily in
        /// driving direction), this means changing from left to right is
        /// allowed.
        /// </summary>
        [pbr::OriginalName("PASSING_RULE_DECREASING_T")] DecreasingT = 4,
        /// <summary>
        /// Passing is allowed in both directions (left to right and right to
        /// left).
        /// </summary>
        [pbr::OriginalName("PASSING_RULE_BOTH_ALLOWED")] BothAllowed = 5,
      }

      /// <summary>
      ///
      /// \brief A point on the boundary
      /// </summary>
      public sealed partial class LogicalBoundaryPoint : pb::IMessage<LogicalBoundaryPoint>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<LogicalBoundaryPoint> _parser = new pb::MessageParser<LogicalBoundaryPoint>(() => new LogicalBoundaryPoint());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<LogicalBoundaryPoint> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Osi3.LogicalLaneBoundary.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public LogicalBoundaryPoint() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public LogicalBoundaryPoint(LogicalBoundaryPoint other) : this() {
          position_ = other.position_ != null ? other.position_.Clone() : null;
          sPosition_ = other.sPosition_;
          tPosition_ = other.tPosition_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public LogicalBoundaryPoint Clone() {
          return new LogicalBoundaryPoint(this);
        }

        /// <summary>Field number for the "position" field.</summary>
        public const int PositionFieldNumber = 1;
        private global::Osi3.Vector3d position_;
        /// <summary>
        /// The position of the \c LaneBoundaryPoint.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Osi3.Vector3d Position {
          get { return position_; }
          set {
            position_ = value;
          }
        }

        /// <summary>Field number for the "s_position" field.</summary>
        public const int SPositionFieldNumber = 2;
        private double sPosition_;
        /// <summary>
        /// S position of the LaneBoundaryPoint, measured along the parent's
        /// reference_line_id.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public double SPosition {
          get { return sPosition_; }
          set {
            sPosition_ = value;
          }
        }

        /// <summary>Field number for the "t_position" field.</summary>
        public const int TPositionFieldNumber = 3;
        private double tPosition_;
        /// <summary>
        /// T position of the LaneBoundaryPoint, measured along the parent's
        /// reference_line_id.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public double TPosition {
          get { return tPosition_; }
          set {
            tPosition_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as LogicalBoundaryPoint);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(LogicalBoundaryPoint other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(Position, other.Position)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(SPosition, other.SPosition)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(TPosition, other.TPosition)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (position_ != null) hash ^= Position.GetHashCode();
          if (SPosition != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(SPosition);
          if (TPosition != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(TPosition);
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (position_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(Position);
          }
          if (SPosition != 0D) {
            output.WriteRawTag(17);
            output.WriteDouble(SPosition);
          }
          if (TPosition != 0D) {
            output.WriteRawTag(25);
            output.WriteDouble(TPosition);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (position_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(Position);
          }
          if (SPosition != 0D) {
            output.WriteRawTag(17);
            output.WriteDouble(SPosition);
          }
          if (TPosition != 0D) {
            output.WriteRawTag(25);
            output.WriteDouble(TPosition);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (position_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Position);
          }
          if (SPosition != 0D) {
            size += 1 + 8;
          }
          if (TPosition != 0D) {
            size += 1 + 8;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(LogicalBoundaryPoint other) {
          if (other == null) {
            return;
          }
          if (other.position_ != null) {
            if (position_ == null) {
              Position = new global::Osi3.Vector3d();
            }
            Position.MergeFrom(other.Position);
          }
          if (other.SPosition != 0D) {
            SPosition = other.SPosition;
          }
          if (other.TPosition != 0D) {
            TPosition = other.TPosition;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (position_ == null) {
                  Position = new global::Osi3.Vector3d();
                }
                input.ReadMessage(Position);
                break;
              }
              case 17: {
                SPosition = input.ReadDouble();
                break;
              }
              case 25: {
                TPosition = input.ReadDouble();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                if (position_ == null) {
                  Position = new global::Osi3.Vector3d();
                }
                input.ReadMessage(Position);
                break;
              }
              case 17: {
                SPosition = input.ReadDouble();
                break;
              }
              case 25: {
                TPosition = input.ReadDouble();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  ///
  /// \brief A logical lane in the road network.
  ///
  /// A logical lane is part of a road. Compared to a physical lane (OSI type
  /// \c Lane), its existence doesn't hinge on the existence of road markings. So
  /// e.g. a road with two driving directions but no road markings in-between
  /// would be presented as two \link LogicalLane LogicalLanes\endlink, but only
  /// one Lane. So one Lane can consist of multiple \link LogicalLane
  /// LogicalLanes\endlink. E.g. on intersections, each driving path is one
  /// LogicalLane, but the whole area is one \c Lane of type \link
  /// osi3::Lane::Classification::TYPE_INTERSECTION \c TYPE_INTERSECTION \endlink.
  ///
  /// Outside of intersections, logical lanes are constructed such that each point on
  /// the road belongs to at least one (typically: exactly one) logical lane. So
  /// there are no gaps between logical lanes, and no areas that don't belong to a
  /// logical lane.
  ///
  /// If OSI is generated from OpenDRIVE, then \link LogicalLane
  /// LogicalLanes\endlink map directly to OpenDRIVE lanes. However, it is allowed
  /// to merge multiple consecutive (in S direction) OpenDRIVE lanes with the same
  /// type into one OSI LogicalLane: if an OpenDRIVE lane has a single successor,
  /// which has the same lane type, and this successor has only one predecessor
  /// (so no lane merging or splitting) then the two lanes may be presented as one
  /// continuous LogicalLane. This may be done recursively.
  ///
  /// The \link ReferenceLine reference line\endlink pointed to by
  /// #reference_line_id defines an ST coordinate system for the lane. This ST
  /// coordinate system is used to describe positions on the lane.
  ///
  /// ## Example
  ///
  /// The example below shows two logical lanes on an intersection, with a focus
  /// on the left-turn lane (\c l1):
  /// \image html OSI_LogicalLane1.png "Two logical lanes on an intersection"
  ///
  /// Assumptions not shown in the image:
  /// - This is right-hand traffic (and thus vehicles on \c l1 drive from the bottom
  ///   to the left, vehicles on \c l2 drive from right to left).
  /// - The yellow line is a ReferenceLine, defined starting at the bottom, and
  ///   going to the left.
  ///
  /// Some features shown in the image relative to \c l1:
  /// - The yellow line is the ReferenceLine of \c l1 . The ReferenceLine can be
  ///   shared with other lanes.  Because the ReferenceLine has the same direction
  ///   as the driving direction of \c l1 in this example,
  ///   &lt;code>#move_direction == #MOVE_DIRECTION_INCREASING_S&lt;/code>.
  /// - The red line marks the area where \c l2 is left of
  ///   \c l1 - this info is recorded in #left_adjacent_lane of \c l1.
  /// - The red area is the area where \c l2 overlaps \c l1. This is recorded in
  ///   #overlapping_lane of \c l1.
  ///
  /// The image below shows the same two lanes, but from the perspective of \c l2:
  /// \image html OSI_LogicalLane2.png "Two logical lanes on an intersection"
  ///
  /// Assumptions not shown in the image:
  /// - The yellow line is a ReferenceLine, defined starting at the right, going
  ///   to the left.
  ///
  /// Some features shown in the image relative to \c l2:
  /// - The yellow line is the ReferenceLine of \c l2 . The ReferenceLine can be
  ///   shared with other lanes.  Because the ReferenceLine has the same direction
  ///   as the driving direction of \c l2 in this example,
  ///   &lt;code>#move_direction == #MOVE_DIRECTION_INCREASING_S&lt;/code>.
  /// - The green line marks the area where \c l1 is right of
  ///   \c l2 - this info is recorded in #right_adjacent_lane of \c l2.
  /// - The red area is the area where \c l1 overlaps \c l2. This is recorded in
  ///   #overlapping_lane of \c l1.
  ///
  /// As can be seen in the images, the two highlighted lanes are neighbours for
  /// part of their length, but it makes no sense for them to have the same
  /// reference line, since they diverge significantly.
  ///
  /// Note: all the relations shown above are also defined outside of intersections.
  /// </summary>
  public sealed partial class LogicalLane : pb::IMessage<LogicalLane>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<LogicalLane> _parser = new pb::MessageParser<LogicalLane>(() => new LogicalLane());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<LogicalLane> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Osi3.OsiLogicallaneReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LogicalLane() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LogicalLane(LogicalLane other) : this() {
      id_ = other.id_ != null ? other.id_.Clone() : null;
      type_ = other.type_;
      sourceReference_ = other.sourceReference_.Clone();
      physicalLaneReference_ = other.physicalLaneReference_.Clone();
      referenceLineId_ = other.referenceLineId_ != null ? other.referenceLineId_.Clone() : null;
      startS_ = other.startS_;
      endS_ = other.endS_;
      moveDirection_ = other.moveDirection_;
      rightAdjacentLane_ = other.rightAdjacentLane_.Clone();
      leftAdjacentLane_ = other.leftAdjacentLane_.Clone();
      overlappingLane_ = other.overlappingLane_.Clone();
      rightBoundaryId_ = other.rightBoundaryId_.Clone();
      leftBoundaryId_ = other.leftBoundaryId_.Clone();
      predecessorLane_ = other.predecessorLane_.Clone();
      successorLane_ = other.successorLane_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LogicalLane Clone() {
      return new LogicalLane(this);
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private global::Osi3.Identifier id_;
    /// <summary>
    /// The ID of the logical lane.
    ///
    /// \note Note ID is global unique.
    ///
    /// \rules
    /// is_globally_unique
    /// \endrules
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.Identifier Id {
      get { return id_; }
      set {
        id_ = value;
      }
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 2;
    private global::Osi3.LogicalLane.Types.Type type_ = global::Osi3.LogicalLane.Types.Type.Unknown;
    /// <summary>
    /// The type of the logical lane.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.LogicalLane.Types.Type Type {
      get { return type_; }
      set {
        type_ = value;
      }
    }

    /// <summary>Field number for the "source_reference" field.</summary>
    public const int SourceReferenceFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Osi3.ExternalReference> _repeated_sourceReference_codec
        = pb::FieldCodec.ForMessage(26, global::Osi3.ExternalReference.Parser);
    private readonly pbc::RepeatedField<global::Osi3.ExternalReference> sourceReference_ = new pbc::RepeatedField<global::Osi3.ExternalReference>();
    /// <summary>
    /// Optional external reference to the lane source.
    ///
    /// The external reference points to the source of the lane, if it is derived
    /// from one or more objects or external references.
    ///
    /// For example, to reference a lane defined in an OpenDRIVE map
    /// the items should be set as follows:
    /// * reference = URI to map, can remain empty if identical with definiton
    ///               in \c GroundTruth::map_reference
    /// * type = "net.asam.opendrive"
    /// * identifier[0] = id of t_road
    /// * identifier[1] = s of t_road_lanes_laneSection
    /// * identifier[2] = id of t_road_lanes_laneSection_left_lane,
    ///                         t_road_lanes_laneSection_right_lane
    ///
    /// \note For non-ASAM Standards, it is implementation-specific how
    ///       source_reference is resolved.
    ///
    /// \note The value has to be repeated, because one lane segment may be
    ///       derived from more than one origin segment. Multiple sources
    ///       may be added as reference as well, for example, a map and sensors.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Osi3.ExternalReference> SourceReference {
      get { return sourceReference_; }
    }

    /// <summary>Field number for the "physical_lane_reference" field.</summary>
    public const int PhysicalLaneReferenceFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Osi3.LogicalLane.Types.PhysicalLaneReference> _repeated_physicalLaneReference_codec
        = pb::FieldCodec.ForMessage(34, global::Osi3.LogicalLane.Types.PhysicalLaneReference.Parser);
    private readonly pbc::RepeatedField<global::Osi3.LogicalLane.Types.PhysicalLaneReference> physicalLaneReference_ = new pbc::RepeatedField<global::Osi3.LogicalLane.Types.PhysicalLaneReference>();
    /// <summary>
    /// Reference to the physical lanes this logical lane belongs to.
    ///
    /// This makes it possible to get detailed information on the physical lane
    /// properties, e.g. the visual colors of the boundaries, the road
    /// condition, etc..
    ///
    /// Note: a logical lane may consist of several physical lanes (in a row).
    /// At any one S position, a logical lane should only reference one physical
    /// lane. Several logical lanes may reference the same physical lane (see
    /// drawing below).
    ///
    /// Logical lanes should not extend beyond intersections. All logical lanes
    /// on intersections should end at the latest at the border of the
    /// intersection.
    ///
    /// Example:
    /// &lt;pre>
    /// ---------------------------------
    ///  l1                       l2
    /// ----------    l3        ---------
    ///  l4                       l5
    /// ---------------------------------
    /// &lt;/pre>
    ///
    /// In this case, we have five physical lanes: l1, l2, l4 and l5 where a
    /// lane marking is present. And l3 is one lane covering the whole road
    /// (because no road marking is present).
    ///
    /// This would typically be presented as two logical lanes:
    /// - One encompassing l1, part of l3, and l2
    /// - The other encompassing l4, part of l3 and l5
    ///
    /// In this example, both logical lanes would reference l3. Their shared
    /// LogicalLaneBoundary would cut through the middle of l3.
    ///
    /// physical_lane_reference does not give any information how much of the
    /// area of a physical lane is covered by a logical lane.
    ///
    /// For LogicalLanes without a correspondence to a Lane.Classification.Subtype 
    /// (i.e. TYPE_MEDIAN, TYPE_CURB, TYPE_TRAM, TYPE_RAIL) this field has no value.
    ///
    /// \rules
    /// refers_to: Lane
    /// \endrules
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Osi3.LogicalLane.Types.PhysicalLaneReference> PhysicalLaneReference {
      get { return physicalLaneReference_; }
    }

    /// <summary>Field number for the "reference_line_id" field.</summary>
    public const int ReferenceLineIdFieldNumber = 5;
    private global::Osi3.Identifier referenceLineId_;
    /// <summary>
    /// The \link ReferenceLine reference line\endlink for this logical lane
    ///
    /// The reference line is used as a coordinate system on this lane.
    ///
    /// The reference line should roughly have the same shape as the lane, so
    /// that S coordinates continually increase/decrease along the lane. It is
    /// not required that the reference line has the same direction as the
    /// driving direction of the lane.
    ///
    /// Neighbouring lanes (i.e. lanes that are neighbours and whose directions
    /// do not diverge significantly) are strongly encouraged to reference the
    /// same ReferenceLine, so that vehicles that are next to each other on
    /// neighbouring lanes have comparable S positions.
    ///
    /// The S coordinate of the reference line makes it easy to find e.g. which
    /// object is next on a lane, using the LogicalLaneAssignment of the
    /// objects.
    ///
    /// The reference trajectory must be sampled such that there are no two
    /// positions on the lane more than 5cm apart with the same ST coordinate.
    ///
    /// \rules
    /// refers_to: ReferenceLine
    /// \endrules
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.Identifier ReferenceLineId {
      get { return referenceLineId_; }
      set {
        referenceLineId_ = value;
      }
    }

    /// <summary>Field number for the "start_s" field.</summary>
    public const int StartSFieldNumber = 6;
    private double startS_;
    /// <summary>
    /// Start S position of the lane.
    ///
    /// Must be in range [\c sStart,\c sEnd] of the reference line.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double StartS {
      get { return startS_; }
      set {
        startS_ = value;
      }
    }

    /// <summary>Field number for the "end_s" field.</summary>
    public const int EndSFieldNumber = 7;
    private double endS_;
    /// <summary>
    /// End S position of the lane.
    ///
    /// Must be in range [\c sStart,\c sEnd] of the reference line.
    ///
    /// Requirement: #end_s > #start_s
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double EndS {
      get { return endS_; }
      set {
        endS_ = value;
      }
    }

    /// <summary>Field number for the "move_direction" field.</summary>
    public const int MoveDirectionFieldNumber = 8;
    private global::Osi3.LogicalLane.Types.MoveDirection moveDirection_ = global::Osi3.LogicalLane.Types.MoveDirection.Unknown;
    /// <summary>
    /// Definition of the intended driving direction.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.LogicalLane.Types.MoveDirection MoveDirection {
      get { return moveDirection_; }
      set {
        moveDirection_ = value;
      }
    }

    /// <summary>Field number for the "right_adjacent_lane" field.</summary>
    public const int RightAdjacentLaneFieldNumber = 9;
    private static readonly pb::FieldCodec<global::Osi3.LogicalLane.Types.LaneRelation> _repeated_rightAdjacentLane_codec
        = pb::FieldCodec.ForMessage(74, global::Osi3.LogicalLane.Types.LaneRelation.Parser);
    private readonly pbc::RepeatedField<global::Osi3.LogicalLane.Types.LaneRelation> rightAdjacentLane_ = new pbc::RepeatedField<global::Osi3.LogicalLane.Types.LaneRelation>();
    /// <summary>
    /// Lanes that are directly right of this lane, without gap or overlap.
    ///
    /// "Right" is in definition direction (not driving direction), so right lanes
    /// have smaller T coordinates.
    /// Entries must be ordered: first by #start_s, then by #end_s.
    ///
    /// The XY positions of the polyline generated by the LogicalLaneBoundaries
    /// of adjacent lanes must match up to a small error (5cm).
    /// Typically adjacent lanes will share a LogicalLaneBoundary, but this will
    /// not always be true. Examples: on intersections, it might be hard to generate
    /// data such that lanes that are adjacent for a short length share a
    /// LogicalLaneBoundary for this length; also different LogicalLaneBoundaries
    /// are needed if the lanes have different heights at their boundaries (e.g.
    /// road adjacent to a sidewalk).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Osi3.LogicalLane.Types.LaneRelation> RightAdjacentLane {
      get { return rightAdjacentLane_; }
    }

    /// <summary>Field number for the "left_adjacent_lane" field.</summary>
    public const int LeftAdjacentLaneFieldNumber = 10;
    private static readonly pb::FieldCodec<global::Osi3.LogicalLane.Types.LaneRelation> _repeated_leftAdjacentLane_codec
        = pb::FieldCodec.ForMessage(82, global::Osi3.LogicalLane.Types.LaneRelation.Parser);
    private readonly pbc::RepeatedField<global::Osi3.LogicalLane.Types.LaneRelation> leftAdjacentLane_ = new pbc::RepeatedField<global::Osi3.LogicalLane.Types.LaneRelation>();
    /// <summary>
    /// Lanes that are directly left of this lane, without gap or overlap.
    ///
    /// "Left" is in definition direction (not driving direction), so left lanes
    /// have larger T coordinates.
    /// Entries must be ordered: first by #start_s, then by #end_s.
    ///
    /// The XY positions of the polyline generated by the LogicalLaneBoundaries
    /// of adjacent lanes must match up to a small error (5cm).
    /// Typically adjacent lanes will share a LogicalLaneBoundary, but this will
    /// not always be true. Examples: on intersections, it might be hard to generate
    /// data such that lanes that are adjacent for a short length share a
    /// LogicalLaneBoundary for this length; also different LogicalLaneBoundaries
    /// are needed if the lanes have different heights at their boundaries (e.g.
    /// road adjacent to a sidewalk).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Osi3.LogicalLane.Types.LaneRelation> LeftAdjacentLane {
      get { return leftAdjacentLane_; }
    }

    /// <summary>Field number for the "overlapping_lane" field.</summary>
    public const int OverlappingLaneFieldNumber = 11;
    private static readonly pb::FieldCodec<global::Osi3.LogicalLane.Types.LaneRelation> _repeated_overlappingLane_codec
        = pb::FieldCodec.ForMessage(90, global::Osi3.LogicalLane.Types.LaneRelation.Parser);
    private readonly pbc::RepeatedField<global::Osi3.LogicalLane.Types.LaneRelation> overlappingLane_ = new pbc::RepeatedField<global::Osi3.LogicalLane.Types.LaneRelation>();
    /// <summary>
    /// Lanes that partially or completely overlap this lane.
    ///
    /// Only overlaps laterally larger than 5cm are considered overlaps for the
    /// purpose of this relation.
    ///
    /// This will typically contain a lot of entries on intersections, but might
    /// also be used outside of intersections (e.g. if a #TYPE_BIKING lane
    /// overlaps a #TYPE_NORMAL lane).
    ///
    /// Entries must be ordered: first by #start_s, then by #end_s.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Osi3.LogicalLane.Types.LaneRelation> OverlappingLane {
      get { return overlappingLane_; }
    }

    /// <summary>Field number for the "right_boundary_id" field.</summary>
    public const int RightBoundaryIdFieldNumber = 12;
    private static readonly pb::FieldCodec<global::Osi3.Identifier> _repeated_rightBoundaryId_codec
        = pb::FieldCodec.ForMessage(98, global::Osi3.Identifier.Parser);
    private readonly pbc::RepeatedField<global::Osi3.Identifier> rightBoundaryId_ = new pbc::RepeatedField<global::Osi3.Identifier>();
    /// <summary>
    /// Right boundary of this lane.
    ///
    /// References to LogicalLaneBoundary elements.
    /// All LogicalLaneBoundary elements referenced here must refer to the same
    /// ReferenceLine as this lane.
    /// The boundaries together must cover the whole length of the lane (the
    /// range \[#start_s,#end_s\]) without gap or overlap. The boundaries must be
    /// stored in ascending order, starting with the smallest S position.
    /// Consecutive boundaries must share a point: the last point of the
    /// previous boundary must be identical to the first point of the next
    /// boundary.
    ///
    /// Note: the referenced boundaries may have points outside of
    /// \[#start_s,#end_s\] (e.g. a boundary may extend beyond the end of a lane).
    ///
    /// Note: A curb is a type of LogicalLane and of LaneBoundary. 
    /// If LogicalLane.Type == TYPE_CURB, by convention this
    /// field references the respective LaneBoundary of TYPE_CURB
    /// identically to the left_boundary_id of this LogicalLane.
    ///
    /// \rules
    /// refers_to: LogicalLaneBoundary
    /// \endrules
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Osi3.Identifier> RightBoundaryId {
      get { return rightBoundaryId_; }
    }

    /// <summary>Field number for the "left_boundary_id" field.</summary>
    public const int LeftBoundaryIdFieldNumber = 13;
    private static readonly pb::FieldCodec<global::Osi3.Identifier> _repeated_leftBoundaryId_codec
        = pb::FieldCodec.ForMessage(106, global::Osi3.Identifier.Parser);
    private readonly pbc::RepeatedField<global::Osi3.Identifier> leftBoundaryId_ = new pbc::RepeatedField<global::Osi3.Identifier>();
    /// <summary>
    /// Left boundary of this lane.
    ///
    /// References to LogicalLaneBoundary elements.
    /// All LogicalLaneBoundary elements referenced here must refer to the same
    /// ReferenceLine as this lane.
    /// The boundaries together must cover the whole length of the lane (the
    /// range \[#start_s,#end_s\]) without gap or overlap. The boundaries must be
    /// stored in ascending order, starting with the smallest S position.
    /// Consecutive boundaries must share a point: the last point of the
    /// previous boundary must be identical to the first point of the next
    /// boundary.
    ///
    /// Note: the referenced boundaries may have points outside of
    /// \[#start_s,#end_s\] (e.g. a boundary may extend beyond the end of a lane).
    ///
    /// Note: A curb is a type of LogicalLane and of LaneBoundary. 
    /// If LogicalLane.Type == TYPE_CURB, by convention this
    /// field references the respective LaneBoundary of TYPE_CURB.
    /// identically to the right_boundary_id of this LogicalLane.    
    ///
    /// \rules
    /// refers_to: LogicalLaneBoundary
    /// \endrules
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Osi3.Identifier> LeftBoundaryId {
      get { return leftBoundaryId_; }
    }

    /// <summary>Field number for the "predecessor_lane" field.</summary>
    public const int PredecessorLaneFieldNumber = 14;
    private static readonly pb::FieldCodec<global::Osi3.LogicalLane.Types.LaneConnection> _repeated_predecessorLane_codec
        = pb::FieldCodec.ForMessage(114, global::Osi3.LogicalLane.Types.LaneConnection.Parser);
    private readonly pbc::RepeatedField<global::Osi3.LogicalLane.Types.LaneConnection> predecessorLane_ = new pbc::RepeatedField<global::Osi3.LogicalLane.Types.LaneConnection>();
    /// <summary>
    /// Lanes that directly are connected to this lane at the beginning.
    ///
    /// "Beginning" is relative to the reference line, so connections at #start_s.
    ///
    /// Lane predecessors and successors shall only be used to connect lanes if
    /// a physical connection at the beginning or end of both lanes exist. Both
    /// lanes have a non-zero width at the connection point and they are
    /// semantically connected.
    ///
    /// A lane may have several predecessors e.g. on intersections, or if a wide
    /// lane splits into two, or two merge into one.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Osi3.LogicalLane.Types.LaneConnection> PredecessorLane {
      get { return predecessorLane_; }
    }

    /// <summary>Field number for the "successor_lane" field.</summary>
    public const int SuccessorLaneFieldNumber = 15;
    private static readonly pb::FieldCodec<global::Osi3.LogicalLane.Types.LaneConnection> _repeated_successorLane_codec
        = pb::FieldCodec.ForMessage(122, global::Osi3.LogicalLane.Types.LaneConnection.Parser);
    private readonly pbc::RepeatedField<global::Osi3.LogicalLane.Types.LaneConnection> successorLane_ = new pbc::RepeatedField<global::Osi3.LogicalLane.Types.LaneConnection>();
    /// <summary>
    /// Lanes that directly are connected to this lane at the end.
    ///
    /// "End" is relative to the reference line, so connections at #end_s.
    ///
    /// Lane predecessors and successors shall only be used to connect lanes if
    /// a physical connection at the beginning or end of both lanes exist. Both
    /// lanes have a non-zero width at the connection point and they are
    /// semantically connected.
    ///
    /// A lane may have several successors e.g. on intersections, or if a wide
    /// lane splits into two, or two merge into one.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Osi3.LogicalLane.Types.LaneConnection> SuccessorLane {
      get { return successorLane_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as LogicalLane);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(LogicalLane other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Id, other.Id)) return false;
      if (Type != other.Type) return false;
      if(!sourceReference_.Equals(other.sourceReference_)) return false;
      if(!physicalLaneReference_.Equals(other.physicalLaneReference_)) return false;
      if (!object.Equals(ReferenceLineId, other.ReferenceLineId)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(StartS, other.StartS)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(EndS, other.EndS)) return false;
      if (MoveDirection != other.MoveDirection) return false;
      if(!rightAdjacentLane_.Equals(other.rightAdjacentLane_)) return false;
      if(!leftAdjacentLane_.Equals(other.leftAdjacentLane_)) return false;
      if(!overlappingLane_.Equals(other.overlappingLane_)) return false;
      if(!rightBoundaryId_.Equals(other.rightBoundaryId_)) return false;
      if(!leftBoundaryId_.Equals(other.leftBoundaryId_)) return false;
      if(!predecessorLane_.Equals(other.predecessorLane_)) return false;
      if(!successorLane_.Equals(other.successorLane_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (id_ != null) hash ^= Id.GetHashCode();
      if (Type != global::Osi3.LogicalLane.Types.Type.Unknown) hash ^= Type.GetHashCode();
      hash ^= sourceReference_.GetHashCode();
      hash ^= physicalLaneReference_.GetHashCode();
      if (referenceLineId_ != null) hash ^= ReferenceLineId.GetHashCode();
      if (StartS != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(StartS);
      if (EndS != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(EndS);
      if (MoveDirection != global::Osi3.LogicalLane.Types.MoveDirection.Unknown) hash ^= MoveDirection.GetHashCode();
      hash ^= rightAdjacentLane_.GetHashCode();
      hash ^= leftAdjacentLane_.GetHashCode();
      hash ^= overlappingLane_.GetHashCode();
      hash ^= rightBoundaryId_.GetHashCode();
      hash ^= leftBoundaryId_.GetHashCode();
      hash ^= predecessorLane_.GetHashCode();
      hash ^= successorLane_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (id_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Id);
      }
      if (Type != global::Osi3.LogicalLane.Types.Type.Unknown) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Type);
      }
      sourceReference_.WriteTo(output, _repeated_sourceReference_codec);
      physicalLaneReference_.WriteTo(output, _repeated_physicalLaneReference_codec);
      if (referenceLineId_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(ReferenceLineId);
      }
      if (StartS != 0D) {
        output.WriteRawTag(49);
        output.WriteDouble(StartS);
      }
      if (EndS != 0D) {
        output.WriteRawTag(57);
        output.WriteDouble(EndS);
      }
      if (MoveDirection != global::Osi3.LogicalLane.Types.MoveDirection.Unknown) {
        output.WriteRawTag(64);
        output.WriteEnum((int) MoveDirection);
      }
      rightAdjacentLane_.WriteTo(output, _repeated_rightAdjacentLane_codec);
      leftAdjacentLane_.WriteTo(output, _repeated_leftAdjacentLane_codec);
      overlappingLane_.WriteTo(output, _repeated_overlappingLane_codec);
      rightBoundaryId_.WriteTo(output, _repeated_rightBoundaryId_codec);
      leftBoundaryId_.WriteTo(output, _repeated_leftBoundaryId_codec);
      predecessorLane_.WriteTo(output, _repeated_predecessorLane_codec);
      successorLane_.WriteTo(output, _repeated_successorLane_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (id_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Id);
      }
      if (Type != global::Osi3.LogicalLane.Types.Type.Unknown) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Type);
      }
      sourceReference_.WriteTo(ref output, _repeated_sourceReference_codec);
      physicalLaneReference_.WriteTo(ref output, _repeated_physicalLaneReference_codec);
      if (referenceLineId_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(ReferenceLineId);
      }
      if (StartS != 0D) {
        output.WriteRawTag(49);
        output.WriteDouble(StartS);
      }
      if (EndS != 0D) {
        output.WriteRawTag(57);
        output.WriteDouble(EndS);
      }
      if (MoveDirection != global::Osi3.LogicalLane.Types.MoveDirection.Unknown) {
        output.WriteRawTag(64);
        output.WriteEnum((int) MoveDirection);
      }
      rightAdjacentLane_.WriteTo(ref output, _repeated_rightAdjacentLane_codec);
      leftAdjacentLane_.WriteTo(ref output, _repeated_leftAdjacentLane_codec);
      overlappingLane_.WriteTo(ref output, _repeated_overlappingLane_codec);
      rightBoundaryId_.WriteTo(ref output, _repeated_rightBoundaryId_codec);
      leftBoundaryId_.WriteTo(ref output, _repeated_leftBoundaryId_codec);
      predecessorLane_.WriteTo(ref output, _repeated_predecessorLane_codec);
      successorLane_.WriteTo(ref output, _repeated_successorLane_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (id_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Id);
      }
      if (Type != global::Osi3.LogicalLane.Types.Type.Unknown) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      size += sourceReference_.CalculateSize(_repeated_sourceReference_codec);
      size += physicalLaneReference_.CalculateSize(_repeated_physicalLaneReference_codec);
      if (referenceLineId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ReferenceLineId);
      }
      if (StartS != 0D) {
        size += 1 + 8;
      }
      if (EndS != 0D) {
        size += 1 + 8;
      }
      if (MoveDirection != global::Osi3.LogicalLane.Types.MoveDirection.Unknown) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) MoveDirection);
      }
      size += rightAdjacentLane_.CalculateSize(_repeated_rightAdjacentLane_codec);
      size += leftAdjacentLane_.CalculateSize(_repeated_leftAdjacentLane_codec);
      size += overlappingLane_.CalculateSize(_repeated_overlappingLane_codec);
      size += rightBoundaryId_.CalculateSize(_repeated_rightBoundaryId_codec);
      size += leftBoundaryId_.CalculateSize(_repeated_leftBoundaryId_codec);
      size += predecessorLane_.CalculateSize(_repeated_predecessorLane_codec);
      size += successorLane_.CalculateSize(_repeated_successorLane_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(LogicalLane other) {
      if (other == null) {
        return;
      }
      if (other.id_ != null) {
        if (id_ == null) {
          Id = new global::Osi3.Identifier();
        }
        Id.MergeFrom(other.Id);
      }
      if (other.Type != global::Osi3.LogicalLane.Types.Type.Unknown) {
        Type = other.Type;
      }
      sourceReference_.Add(other.sourceReference_);
      physicalLaneReference_.Add(other.physicalLaneReference_);
      if (other.referenceLineId_ != null) {
        if (referenceLineId_ == null) {
          ReferenceLineId = new global::Osi3.Identifier();
        }
        ReferenceLineId.MergeFrom(other.ReferenceLineId);
      }
      if (other.StartS != 0D) {
        StartS = other.StartS;
      }
      if (other.EndS != 0D) {
        EndS = other.EndS;
      }
      if (other.MoveDirection != global::Osi3.LogicalLane.Types.MoveDirection.Unknown) {
        MoveDirection = other.MoveDirection;
      }
      rightAdjacentLane_.Add(other.rightAdjacentLane_);
      leftAdjacentLane_.Add(other.leftAdjacentLane_);
      overlappingLane_.Add(other.overlappingLane_);
      rightBoundaryId_.Add(other.rightBoundaryId_);
      leftBoundaryId_.Add(other.leftBoundaryId_);
      predecessorLane_.Add(other.predecessorLane_);
      successorLane_.Add(other.successorLane_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (id_ == null) {
              Id = new global::Osi3.Identifier();
            }
            input.ReadMessage(Id);
            break;
          }
          case 16: {
            Type = (global::Osi3.LogicalLane.Types.Type) input.ReadEnum();
            break;
          }
          case 26: {
            sourceReference_.AddEntriesFrom(input, _repeated_sourceReference_codec);
            break;
          }
          case 34: {
            physicalLaneReference_.AddEntriesFrom(input, _repeated_physicalLaneReference_codec);
            break;
          }
          case 42: {
            if (referenceLineId_ == null) {
              ReferenceLineId = new global::Osi3.Identifier();
            }
            input.ReadMessage(ReferenceLineId);
            break;
          }
          case 49: {
            StartS = input.ReadDouble();
            break;
          }
          case 57: {
            EndS = input.ReadDouble();
            break;
          }
          case 64: {
            MoveDirection = (global::Osi3.LogicalLane.Types.MoveDirection) input.ReadEnum();
            break;
          }
          case 74: {
            rightAdjacentLane_.AddEntriesFrom(input, _repeated_rightAdjacentLane_codec);
            break;
          }
          case 82: {
            leftAdjacentLane_.AddEntriesFrom(input, _repeated_leftAdjacentLane_codec);
            break;
          }
          case 90: {
            overlappingLane_.AddEntriesFrom(input, _repeated_overlappingLane_codec);
            break;
          }
          case 98: {
            rightBoundaryId_.AddEntriesFrom(input, _repeated_rightBoundaryId_codec);
            break;
          }
          case 106: {
            leftBoundaryId_.AddEntriesFrom(input, _repeated_leftBoundaryId_codec);
            break;
          }
          case 114: {
            predecessorLane_.AddEntriesFrom(input, _repeated_predecessorLane_codec);
            break;
          }
          case 122: {
            successorLane_.AddEntriesFrom(input, _repeated_successorLane_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (id_ == null) {
              Id = new global::Osi3.Identifier();
            }
            input.ReadMessage(Id);
            break;
          }
          case 16: {
            Type = (global::Osi3.LogicalLane.Types.Type) input.ReadEnum();
            break;
          }
          case 26: {
            sourceReference_.AddEntriesFrom(ref input, _repeated_sourceReference_codec);
            break;
          }
          case 34: {
            physicalLaneReference_.AddEntriesFrom(ref input, _repeated_physicalLaneReference_codec);
            break;
          }
          case 42: {
            if (referenceLineId_ == null) {
              ReferenceLineId = new global::Osi3.Identifier();
            }
            input.ReadMessage(ReferenceLineId);
            break;
          }
          case 49: {
            StartS = input.ReadDouble();
            break;
          }
          case 57: {
            EndS = input.ReadDouble();
            break;
          }
          case 64: {
            MoveDirection = (global::Osi3.LogicalLane.Types.MoveDirection) input.ReadEnum();
            break;
          }
          case 74: {
            rightAdjacentLane_.AddEntriesFrom(ref input, _repeated_rightAdjacentLane_codec);
            break;
          }
          case 82: {
            leftAdjacentLane_.AddEntriesFrom(ref input, _repeated_leftAdjacentLane_codec);
            break;
          }
          case 90: {
            overlappingLane_.AddEntriesFrom(ref input, _repeated_overlappingLane_codec);
            break;
          }
          case 98: {
            rightBoundaryId_.AddEntriesFrom(ref input, _repeated_rightBoundaryId_codec);
            break;
          }
          case 106: {
            leftBoundaryId_.AddEntriesFrom(ref input, _repeated_leftBoundaryId_codec);
            break;
          }
          case 114: {
            predecessorLane_.AddEntriesFrom(ref input, _repeated_predecessorLane_codec);
            break;
          }
          case 122: {
            successorLane_.AddEntriesFrom(ref input, _repeated_successorLane_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the LogicalLane message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      ///
      /// Definition of available lane types.
      ///
      /// This is mostly aligned with OpenDRIVE, except that lane types modelling
      /// access restrictions (e.g. "taxi") are not made available here. These are
      /// already deprecated in OpenDRIVE.  To support this, access restrictions
      /// should be added later, in alignment with OpenDRIVE.
      /// </summary>
      public enum Type {
        /// <summary>
        /// %Lane of unknown type. Do not use in ground truth.
        /// </summary>
        [pbr::OriginalName("TYPE_UNKNOWN")] Unknown = 0,
        /// <summary>
        /// Any other type of lane.
        /// </summary>
        [pbr::OriginalName("TYPE_OTHER")] Other = 1,
        /// <summary>
        /// A normal driving lane.
        /// Example: Lanes with IDs l1, l2, l3 and l4 in image \ref
        /// HighwayExit.
        /// This matches the OpenDRIVE type "driving".
        ///
        /// Note: a lane with OpenDRIVE type "bidirectional" will have an OSI
        /// type of TYPE_NORMAL, with &lt;code>#move_direction ==
        /// #MOVE_DIRECTION_BOTH_ALLOWED&lt;/code>.
        /// </summary>
        [pbr::OriginalName("TYPE_NORMAL")] Normal = 2,
        /// <summary>
        /// A lane that is designated for bicylists.
        /// Note that biking lanes that cross the road (e.g. on an intersection)
        /// are also labeled with this type.
        /// </summary>
        [pbr::OriginalName("TYPE_BIKING")] Biking = 3,
        /// <summary>
        /// A lane that is designated for pedestrians (sidewalk).
        /// Note that pedestrian lanes that cross the road (e.g. on an
        /// intersection) are also labeled with this type.
        /// </summary>
        [pbr::OriginalName("TYPE_SIDEWALK")] Sidewalk = 4,
        /// <summary>
        /// A lane with parking spaces.
        /// </summary>
        [pbr::OriginalName("TYPE_PARKING")] Parking = 5,
        /// <summary>
        /// A hard shoulder on motorways for emergency stops.
        /// Example: Lane l5 in image \ref
        /// HighwayExit.
        /// </summary>
        [pbr::OriginalName("TYPE_STOP")] Stop = 6,
        /// <summary>
        /// A lane on which cars should not drive.
        /// </summary>
        [pbr::OriginalName("TYPE_RESTRICTED")] Restricted = 7,
        /// <summary>
        /// A hard border on the edge of a road.
        /// </summary>
        [pbr::OriginalName("TYPE_BORDER")] Border = 8,
        /// <summary>
        /// A soft border on the edge of a road.
        /// </summary>
        [pbr::OriginalName("TYPE_SHOULDER")] Shoulder = 9,
        /// <summary>
        /// A deceleration lane in parallel to the main road.
        /// Example: Lane l6 in image \ref
        /// HighwayExit.
        /// </summary>
        [pbr::OriginalName("TYPE_EXIT")] Exit = 10,
        /// <summary>
        /// An acceleration lane in parallel to the main road.
        /// </summary>
        [pbr::OriginalName("TYPE_ENTRY")] Entry = 11,
        /// <summary>
        /// A ramp from rural or urban roads joining a motorway.
        /// </summary>
        [pbr::OriginalName("TYPE_ONRAMP")] Onramp = 12,
        /// <summary>
        /// A ramp leading off a motorway onto rural or urban roads.
        /// </summary>
        [pbr::OriginalName("TYPE_OFFRAMP")] Offramp = 13,
        /// <summary>
        /// A ramp that connect two motorways.
        /// </summary>
        [pbr::OriginalName("TYPE_CONNECTINGRAMP")] Connectingramp = 14,
        /// <summary>
        /// A lane that sits between driving lanes
        /// that lead in opposite directions. It is
        /// typically used to separate traffic in
        /// towns on large roads.
        /// </summary>
        [pbr::OriginalName("TYPE_MEDIAN")] Median = 15,
        /// <summary>
        /// Curb stones. Curb stones have a different
        /// height than the adjacent drivable lanes.
        /// </summary>
        [pbr::OriginalName("TYPE_CURB")] Curb = 16,
        /// <summary>
        /// A rail lane. This lane covers the area a train needs to drive along
        /// its rails.
        /// #overlapping_lane then describes where a train crosses other lanes.
        /// </summary>
        [pbr::OriginalName("TYPE_RAIL")] Rail = 17,
        /// <summary>
        /// A tram lane. This lane covers the area a tram needs to drive along
        /// its rails.
        /// #overlapping_lane then describes where a tram crosses other lanes.
        /// </summary>
        [pbr::OriginalName("TYPE_TRAM")] Tram = 18,
      }

      /// <summary>
      ///
      /// Describes in which direction moving objects may typically move along a
      /// lane.
      ///
      /// This describes the allowed typical driving direction on a lane, or (in
      /// the case of pedestrian) the allowed walking direction.
      ///
      /// Note: Allowed overtaking (e.g. on country roads) does not automatically
      /// make a lane bidirectional, since vehicles may normally only drive in the
      /// other direction during the overtake maneuver, not for longer periods of
      /// time.
      /// </summary>
      public enum MoveDirection {
        /// <summary>
        /// Move direction is unknown. Do not use in ground truth.
        /// </summary>
        [pbr::OriginalName("MOVE_DIRECTION_UNKNOWN")] Unknown = 0,
        /// <summary>
        /// Move direction fits neither of the other categories.
        ///
        /// Example: a lane where cars may only drive in one direction, but
        /// bikes may drive in both.
        /// </summary>
        [pbr::OriginalName("MOVE_DIRECTION_OTHER")] Other = 1,
        /// <summary>
        /// Objects may move in increasing S direction.
        ///
        /// This means they move in the same direction as the reference line.
        /// </summary>
        [pbr::OriginalName("MOVE_DIRECTION_INCREASING_S")] IncreasingS = 2,
        /// <summary>
        /// Objects may move in decreasing S direction.
        ///
        /// This means they move in the opposite direction as the reference line.
        /// </summary>
        [pbr::OriginalName("MOVE_DIRECTION_DECREASING_S")] DecreasingS = 3,
        /// <summary>
        /// Objects may move in both directions.
        /// </summary>
        [pbr::OriginalName("MOVE_DIRECTION_BOTH_ALLOWED")] BothAllowed = 4,
      }

      /// <summary>
      ///
      /// \brief Reference to a physical lane.
      /// </summary>
      public sealed partial class PhysicalLaneReference : pb::IMessage<PhysicalLaneReference>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<PhysicalLaneReference> _parser = new pb::MessageParser<PhysicalLaneReference>(() => new PhysicalLaneReference());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<PhysicalLaneReference> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Osi3.LogicalLane.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PhysicalLaneReference() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PhysicalLaneReference(PhysicalLaneReference other) : this() {
          physicalLaneId_ = other.physicalLaneId_ != null ? other.physicalLaneId_.Clone() : null;
          startS_ = other.startS_;
          endS_ = other.endS_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PhysicalLaneReference Clone() {
          return new PhysicalLaneReference(this);
        }

        /// <summary>Field number for the "physical_lane_id" field.</summary>
        public const int PhysicalLaneIdFieldNumber = 1;
        private global::Osi3.Identifier physicalLaneId_;
        /// <summary>
        /// Id of the physical lane referenced.
        ///
        /// \rules
        /// refers_to: Lane
        /// \endrules
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Osi3.Identifier PhysicalLaneId {
          get { return physicalLaneId_; }
          set {
            physicalLaneId_ = value;
          }
        }

        /// <summary>Field number for the "start_s" field.</summary>
        public const int StartSFieldNumber = 2;
        private double startS_;
        /// <summary>
        /// S position on the logical lane where the physical lane starts.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public double StartS {
          get { return startS_; }
          set {
            startS_ = value;
          }
        }

        /// <summary>Field number for the "end_s" field.</summary>
        public const int EndSFieldNumber = 3;
        private double endS_;
        /// <summary>
        /// S position on the logical lane where the physical lane ends.
        ///
        /// Requirement: #end_s > #start_s
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public double EndS {
          get { return endS_; }
          set {
            endS_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as PhysicalLaneReference);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(PhysicalLaneReference other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(PhysicalLaneId, other.PhysicalLaneId)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(StartS, other.StartS)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(EndS, other.EndS)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (physicalLaneId_ != null) hash ^= PhysicalLaneId.GetHashCode();
          if (StartS != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(StartS);
          if (EndS != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(EndS);
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (physicalLaneId_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(PhysicalLaneId);
          }
          if (StartS != 0D) {
            output.WriteRawTag(17);
            output.WriteDouble(StartS);
          }
          if (EndS != 0D) {
            output.WriteRawTag(25);
            output.WriteDouble(EndS);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (physicalLaneId_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(PhysicalLaneId);
          }
          if (StartS != 0D) {
            output.WriteRawTag(17);
            output.WriteDouble(StartS);
          }
          if (EndS != 0D) {
            output.WriteRawTag(25);
            output.WriteDouble(EndS);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (physicalLaneId_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(PhysicalLaneId);
          }
          if (StartS != 0D) {
            size += 1 + 8;
          }
          if (EndS != 0D) {
            size += 1 + 8;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(PhysicalLaneReference other) {
          if (other == null) {
            return;
          }
          if (other.physicalLaneId_ != null) {
            if (physicalLaneId_ == null) {
              PhysicalLaneId = new global::Osi3.Identifier();
            }
            PhysicalLaneId.MergeFrom(other.PhysicalLaneId);
          }
          if (other.StartS != 0D) {
            StartS = other.StartS;
          }
          if (other.EndS != 0D) {
            EndS = other.EndS;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (physicalLaneId_ == null) {
                  PhysicalLaneId = new global::Osi3.Identifier();
                }
                input.ReadMessage(PhysicalLaneId);
                break;
              }
              case 17: {
                StartS = input.ReadDouble();
                break;
              }
              case 25: {
                EndS = input.ReadDouble();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                if (physicalLaneId_ == null) {
                  PhysicalLaneId = new global::Osi3.Identifier();
                }
                input.ReadMessage(PhysicalLaneId);
                break;
              }
              case 17: {
                StartS = input.ReadDouble();
                break;
              }
              case 25: {
                EndS = input.ReadDouble();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      ///
      /// \brief Connection to another lane (predecessor or successor)
      /// </summary>
      public sealed partial class LaneConnection : pb::IMessage<LaneConnection>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<LaneConnection> _parser = new pb::MessageParser<LaneConnection>(() => new LaneConnection());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<LaneConnection> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Osi3.LogicalLane.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public LaneConnection() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public LaneConnection(LaneConnection other) : this() {
          otherLaneId_ = other.otherLaneId_ != null ? other.otherLaneId_.Clone() : null;
          atBeginOfOtherLane_ = other.atBeginOfOtherLane_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public LaneConnection Clone() {
          return new LaneConnection(this);
        }

        /// <summary>Field number for the "other_lane_id" field.</summary>
        public const int OtherLaneIdFieldNumber = 1;
        private global::Osi3.Identifier otherLaneId_;
        /// <summary>
        /// Id of the other logical lane that is connected.
        ///
        /// \rules
        /// refers_to: LogicalLane
        /// \endrules
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Osi3.Identifier OtherLaneId {
          get { return otherLaneId_; }
          set {
            otherLaneId_ = value;
          }
        }

        /// <summary>Field number for the "at_begin_of_other_lane" field.</summary>
        public const int AtBeginOfOtherLaneFieldNumber = 2;
        private bool atBeginOfOtherLane_;
        /// <summary>
        /// If true: LaneConnection is at the beginning of the other lane
        /// If false: LaneConnection is a the end of the other lane
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool AtBeginOfOtherLane {
          get { return atBeginOfOtherLane_; }
          set {
            atBeginOfOtherLane_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as LaneConnection);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(LaneConnection other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(OtherLaneId, other.OtherLaneId)) return false;
          if (AtBeginOfOtherLane != other.AtBeginOfOtherLane) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (otherLaneId_ != null) hash ^= OtherLaneId.GetHashCode();
          if (AtBeginOfOtherLane != false) hash ^= AtBeginOfOtherLane.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (otherLaneId_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(OtherLaneId);
          }
          if (AtBeginOfOtherLane != false) {
            output.WriteRawTag(16);
            output.WriteBool(AtBeginOfOtherLane);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (otherLaneId_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(OtherLaneId);
          }
          if (AtBeginOfOtherLane != false) {
            output.WriteRawTag(16);
            output.WriteBool(AtBeginOfOtherLane);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (otherLaneId_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(OtherLaneId);
          }
          if (AtBeginOfOtherLane != false) {
            size += 1 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(LaneConnection other) {
          if (other == null) {
            return;
          }
          if (other.otherLaneId_ != null) {
            if (otherLaneId_ == null) {
              OtherLaneId = new global::Osi3.Identifier();
            }
            OtherLaneId.MergeFrom(other.OtherLaneId);
          }
          if (other.AtBeginOfOtherLane != false) {
            AtBeginOfOtherLane = other.AtBeginOfOtherLane;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (otherLaneId_ == null) {
                  OtherLaneId = new global::Osi3.Identifier();
                }
                input.ReadMessage(OtherLaneId);
                break;
              }
              case 16: {
                AtBeginOfOtherLane = input.ReadBool();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                if (otherLaneId_ == null) {
                  OtherLaneId = new global::Osi3.Identifier();
                }
                input.ReadMessage(OtherLaneId);
                break;
              }
              case 16: {
                AtBeginOfOtherLane = input.ReadBool();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      ///
      /// \brief Relation of this lane to another logical lane
      /// </summary>
      public sealed partial class LaneRelation : pb::IMessage<LaneRelation>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<LaneRelation> _parser = new pb::MessageParser<LaneRelation>(() => new LaneRelation());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<LaneRelation> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Osi3.LogicalLane.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public LaneRelation() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public LaneRelation(LaneRelation other) : this() {
          otherLaneId_ = other.otherLaneId_ != null ? other.otherLaneId_.Clone() : null;
          startS_ = other.startS_;
          endS_ = other.endS_;
          startSOther_ = other.startSOther_;
          endSOther_ = other.endSOther_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public LaneRelation Clone() {
          return new LaneRelation(this);
        }

        /// <summary>Field number for the "other_lane_id" field.</summary>
        public const int OtherLaneIdFieldNumber = 1;
        private global::Osi3.Identifier otherLaneId_;
        /// <summary>
        /// Id of the other logical lane.
        ///
        /// \rules
        /// refers_to: LogicalLane
        /// \endrules
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Osi3.Identifier OtherLaneId {
          get { return otherLaneId_; }
          set {
            otherLaneId_ = value;
          }
        }

        /// <summary>Field number for the "start_s" field.</summary>
        public const int StartSFieldNumber = 2;
        private double startS_;
        /// <summary>
        /// Start s position of the relation.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public double StartS {
          get { return startS_; }
          set {
            startS_ = value;
          }
        }

        /// <summary>Field number for the "end_s" field.</summary>
        public const int EndSFieldNumber = 3;
        private double endS_;
        /// <summary>
        /// End s position of the relation.
        ///
        /// Requirement: #end_s > #start_s
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public double EndS {
          get { return endS_; }
          set {
            endS_ = value;
          }
        }

        /// <summary>Field number for the "start_s_other" field.</summary>
        public const int StartSOtherFieldNumber = 4;
        private double startSOther_;
        /// <summary>
        /// Start s position of the relation on the other lane.
        ///
        /// This is the same place as #start_s, but measured along the reference
        /// line of the other lane.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public double StartSOther {
          get { return startSOther_; }
          set {
            startSOther_ = value;
          }
        }

        /// <summary>Field number for the "end_s_other" field.</summary>
        public const int EndSOtherFieldNumber = 5;
        private double endSOther_;
        /// <summary>
        /// End s position of the relation on the other lane.
        ///
        /// This is the same place as #end_s, but measured along the reference
        /// line of the other lane.
        ///
        /// Note: #end_s_other might be smaller than #start_s_other
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public double EndSOther {
          get { return endSOther_; }
          set {
            endSOther_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as LaneRelation);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(LaneRelation other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(OtherLaneId, other.OtherLaneId)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(StartS, other.StartS)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(EndS, other.EndS)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(StartSOther, other.StartSOther)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(EndSOther, other.EndSOther)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (otherLaneId_ != null) hash ^= OtherLaneId.GetHashCode();
          if (StartS != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(StartS);
          if (EndS != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(EndS);
          if (StartSOther != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(StartSOther);
          if (EndSOther != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(EndSOther);
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (otherLaneId_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(OtherLaneId);
          }
          if (StartS != 0D) {
            output.WriteRawTag(17);
            output.WriteDouble(StartS);
          }
          if (EndS != 0D) {
            output.WriteRawTag(25);
            output.WriteDouble(EndS);
          }
          if (StartSOther != 0D) {
            output.WriteRawTag(33);
            output.WriteDouble(StartSOther);
          }
          if (EndSOther != 0D) {
            output.WriteRawTag(41);
            output.WriteDouble(EndSOther);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (otherLaneId_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(OtherLaneId);
          }
          if (StartS != 0D) {
            output.WriteRawTag(17);
            output.WriteDouble(StartS);
          }
          if (EndS != 0D) {
            output.WriteRawTag(25);
            output.WriteDouble(EndS);
          }
          if (StartSOther != 0D) {
            output.WriteRawTag(33);
            output.WriteDouble(StartSOther);
          }
          if (EndSOther != 0D) {
            output.WriteRawTag(41);
            output.WriteDouble(EndSOther);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (otherLaneId_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(OtherLaneId);
          }
          if (StartS != 0D) {
            size += 1 + 8;
          }
          if (EndS != 0D) {
            size += 1 + 8;
          }
          if (StartSOther != 0D) {
            size += 1 + 8;
          }
          if (EndSOther != 0D) {
            size += 1 + 8;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(LaneRelation other) {
          if (other == null) {
            return;
          }
          if (other.otherLaneId_ != null) {
            if (otherLaneId_ == null) {
              OtherLaneId = new global::Osi3.Identifier();
            }
            OtherLaneId.MergeFrom(other.OtherLaneId);
          }
          if (other.StartS != 0D) {
            StartS = other.StartS;
          }
          if (other.EndS != 0D) {
            EndS = other.EndS;
          }
          if (other.StartSOther != 0D) {
            StartSOther = other.StartSOther;
          }
          if (other.EndSOther != 0D) {
            EndSOther = other.EndSOther;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (otherLaneId_ == null) {
                  OtherLaneId = new global::Osi3.Identifier();
                }
                input.ReadMessage(OtherLaneId);
                break;
              }
              case 17: {
                StartS = input.ReadDouble();
                break;
              }
              case 25: {
                EndS = input.ReadDouble();
                break;
              }
              case 33: {
                StartSOther = input.ReadDouble();
                break;
              }
              case 41: {
                EndSOther = input.ReadDouble();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                if (otherLaneId_ == null) {
                  OtherLaneId = new global::Osi3.Identifier();
                }
                input.ReadMessage(OtherLaneId);
                break;
              }
              case 17: {
                StartS = input.ReadDouble();
                break;
              }
              case 25: {
                EndS = input.ReadDouble();
                break;
              }
              case 33: {
                StartSOther = input.ReadDouble();
                break;
              }
              case 41: {
                EndSOther = input.ReadDouble();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
