// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: osi_roadmarking.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Osi3 {

  /// <summary>Holder for reflection information generated from osi_roadmarking.proto</summary>
  public static partial class OsiRoadmarkingReflection {

    #region Descriptor
    /// <summary>File descriptor for osi_roadmarking.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static OsiRoadmarkingReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChVvc2lfcm9hZG1hcmtpbmcucHJvdG8SBG9zaTMaEG9zaV9jb21tb24ucHJv",
            "dG8aFW9zaV90cmFmZmljc2lnbi5wcm90byLJCAoLUm9hZE1hcmtpbmcSHAoC",
            "aWQYASABKAsyEC5vc2kzLklkZW50aWZpZXISIgoEYmFzZRgCIAEoCzIULm9z",
            "aTMuQmFzZVN0YXRpb25hcnkSOAoOY2xhc3NpZmljYXRpb24YAyABKAsyIC5v",
            "c2kzLlJvYWRNYXJraW5nLkNsYXNzaWZpY2F0aW9uEjEKEHNvdXJjZV9yZWZl",
            "cmVuY2UYBCADKAsyFy5vc2kzLkV4dGVybmFsUmVmZXJlbmNlEjEKEWNvbG9y",
            "X2Rlc2NyaXB0aW9uGAUgASgLMhYub3NpMy5Db2xvckRlc2NyaXB0aW9uGtcG",
            "Cg5DbGFzc2lmaWNhdGlvbhIzCgR0eXBlGAEgASgOMiUub3NpMy5Sb2FkTWFy",
            "a2luZy5DbGFzc2lmaWNhdGlvbi5UeXBlEk4KFnRyYWZmaWNfbWFpbl9zaWdu",
            "X3R5cGUYAiABKA4yLi5vc2kzLlRyYWZmaWNTaWduLk1haW5TaWduLkNsYXNz",
            "aWZpY2F0aW9uLlR5cGUSQAoQbW9ub2Nocm9tZV9jb2xvchgDIAEoDjImLm9z",
            "aTMuUm9hZE1hcmtpbmcuQ2xhc3NpZmljYXRpb24uQ29sb3ISJQoFdmFsdWUY",
            "BCABKAsyFi5vc2kzLlRyYWZmaWNTaWduVmFsdWUSEgoKdmFsdWVfdGV4dBgF",
            "IAEoCRIqChBhc3NpZ25lZF9sYW5lX2lkGAYgAygLMhAub3NpMy5JZGVudGlm",
            "aWVyEhkKEWlzX291dF9vZl9zZXJ2aWNlGAcgASgIEg8KB2NvdW50cnkYCCAB",
            "KAkSGAoQY291bnRyeV9yZXZpc2lvbhgJIAEoCRIMCgRjb2RlGAogASgJEhAK",
            "CHN1Yl9jb2RlGAsgASgJEjwKF2xvZ2ljYWxfbGFuZV9hc3NpZ25tZW50GAwg",
            "AygLMhsub3NpMy5Mb2dpY2FsTGFuZUFzc2lnbm1lbnQizQEKBFR5cGUSEAoM",
            "VFlQRV9VTktOT1dOEAASDgoKVFlQRV9PVEhFUhABEh0KGVRZUEVfUEFJTlRF",
            "RF9UUkFGRklDX1NJR04QAhIeChpUWVBFX1NZTUJPTElDX1RSQUZGSUNfU0lH",
            "ThADEh0KGVRZUEVfVEVYVFVBTF9UUkFGRklDX1NJR04QBBIXChNUWVBFX0dF",
            "TkVSSUNfU1lNQk9MEAUSFQoRVFlQRV9HRU5FUklDX0xJTkUQBhIVChFUWVBF",
            "X0dFTkVSSUNfVEVYVBAHIqIBCgVDb2xvchIRCg1DT0xPUl9VTktOT1dOEAAS",
            "DwoLQ09MT1JfT1RIRVIQARIPCgtDT0xPUl9XSElURRACEhAKDENPTE9SX1lF",
            "TExPVxADEg4KCkNPTE9SX0JMVUUQBRINCglDT0xPUl9SRUQQBhIPCgtDT0xP",
            "Ul9HUkVFThAHEhAKDENPTE9SX1ZJT0xFVBAIEhAKDENPTE9SX09SQU5HRRAJ",
            "QgJIAWIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Osi3.OsiCommonReflection.Descriptor, global::Osi3.OsiTrafficsignReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Osi3.RoadMarking), global::Osi3.RoadMarking.Parser, new[]{ "Id", "Base", "Classification", "SourceReference", "ColorDescription" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Osi3.RoadMarking.Types.Classification), global::Osi3.RoadMarking.Types.Classification.Parser, new[]{ "Type", "TrafficMainSignType", "MonochromeColor", "Value", "ValueText", "AssignedLaneId", "IsOutOfService", "Country", "CountryRevision", "Code", "SubCode", "LogicalLaneAssignment" }, null, new[]{ typeof(global::Osi3.RoadMarking.Types.Classification.Types.Type), typeof(global::Osi3.RoadMarking.Types.Classification.Types.Color) }, null, null)})
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// </summary>
  public sealed partial class RoadMarking : pb::IMessage<RoadMarking>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<RoadMarking> _parser = new pb::MessageParser<RoadMarking>(() => new RoadMarking());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RoadMarking> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Osi3.OsiRoadmarkingReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RoadMarking() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RoadMarking(RoadMarking other) : this() {
      id_ = other.id_ != null ? other.id_.Clone() : null;
      base_ = other.base_ != null ? other.base_.Clone() : null;
      classification_ = other.classification_ != null ? other.classification_.Clone() : null;
      sourceReference_ = other.sourceReference_.Clone();
      colorDescription_ = other.colorDescription_ != null ? other.colorDescription_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RoadMarking Clone() {
      return new RoadMarking(this);
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private global::Osi3.Identifier id_;
    /// <summary>
    /// The ID of the road marking.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.Identifier Id {
      get { return id_; }
      set {
        id_ = value;
      }
    }

    /// <summary>Field number for the "base" field.</summary>
    public const int BaseFieldNumber = 2;
    private global::Osi3.BaseStationary base_;
    /// <summary>
    /// The base parameters of the road marking.
    ///
    /// The orientation of the bounding box \c #base
    /// \c BaseStationary::orientation is defined as follows:
    /// The z-axis of the \c BaseStationary::orientation is the vector from the
    /// 'bottom' to the 'top' of the road marking's (i.e. painted traffic sign)
    /// 2D image area.
    /// (Normally it is in the ground truth xy-plain.)
    /// The x-axis of the \c BaseStationary::orientation is the view normal of
    /// the road marking's 2D image area.
    /// Normally this x-axis points to the sky.
    ///
    /// \note If a valid unidirectional road marking is assigned to the host
    /// vehicle's current lane and the driving direction of the latter roughly
    /// matches the z-axis of the \c #base \c BaseStationary::orientation then
    /// the road marking is of relevance to (i.e. in effect for) the host
    /// vehicle.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.BaseStationary Base {
      get { return base_; }
      set {
        base_ = value;
      }
    }

    /// <summary>Field number for the "classification" field.</summary>
    public const int ClassificationFieldNumber = 3;
    private global::Osi3.RoadMarking.Types.Classification classification_;
    /// <summary>
    /// The classification data for the road marking.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.RoadMarking.Types.Classification Classification {
      get { return classification_; }
      set {
        classification_ = value;
      }
    }

    /// <summary>Field number for the "source_reference" field.</summary>
    public const int SourceReferenceFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Osi3.ExternalReference> _repeated_sourceReference_codec
        = pb::FieldCodec.ForMessage(34, global::Osi3.ExternalReference.Parser);
    private readonly pbc::RepeatedField<global::Osi3.ExternalReference> sourceReference_ = new pbc::RepeatedField<global::Osi3.ExternalReference>();
    /// <summary>
    /// Optional external reference to the road-marking source.
    ///
    /// The external reference points to the source of the surface marking, if it
    /// is derived from one or more objects or external references. An example
    /// here is the reference to the signal defined in a OpenDRIVE map.
    ///
    /// For example, to reference a signal defined in an OpenDRIVE map
    /// the items should be set as follows:
    /// * reference = URI to map, can remain empty if identical with definiton
    ///               in \c GroundTruth::map_reference
    /// * type = "net.asam.opendrive"
    /// * identifier[0] = id of t_road_signals_signal
    ///
    /// \note With OpenDRIVE, surface markings can also be defined as objects.
    ///       In this case, the associated object is usually referenced within
    ///       OpenDRIVE using the reference t_road_signals_signal_reference.
    ///       An additional reference to the object is therefore not necessary.
    ///
    /// \note For non-ASAM Standards, it is implementation-specific how
    ///       source_reference is resolved.
    ///
    /// \note The value has to be repeated, because one lane segment may be
    ///       derived from more than one origin segment. Multiple sources
    ///       may be added as reference as well, for example, a map and sensors.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Osi3.ExternalReference> SourceReference {
      get { return sourceReference_; }
    }

    /// <summary>Field number for the "color_description" field.</summary>
    public const int ColorDescriptionFieldNumber = 5;
    private global::Osi3.ColorDescription colorDescription_;
    /// <summary>
    /// The visual color of the material of the road marking.
    ///
    /// \note This does not represent the semantic classification but the visual
    /// appearance. For semantic classification of the road marking use the color
    /// field in \c Classification.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.ColorDescription ColorDescription {
      get { return colorDescription_; }
      set {
        colorDescription_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RoadMarking);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RoadMarking other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Id, other.Id)) return false;
      if (!object.Equals(Base, other.Base)) return false;
      if (!object.Equals(Classification, other.Classification)) return false;
      if(!sourceReference_.Equals(other.sourceReference_)) return false;
      if (!object.Equals(ColorDescription, other.ColorDescription)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (id_ != null) hash ^= Id.GetHashCode();
      if (base_ != null) hash ^= Base.GetHashCode();
      if (classification_ != null) hash ^= Classification.GetHashCode();
      hash ^= sourceReference_.GetHashCode();
      if (colorDescription_ != null) hash ^= ColorDescription.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (id_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Id);
      }
      if (base_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Base);
      }
      if (classification_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Classification);
      }
      sourceReference_.WriteTo(output, _repeated_sourceReference_codec);
      if (colorDescription_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(ColorDescription);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (id_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Id);
      }
      if (base_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Base);
      }
      if (classification_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Classification);
      }
      sourceReference_.WriteTo(ref output, _repeated_sourceReference_codec);
      if (colorDescription_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(ColorDescription);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (id_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Id);
      }
      if (base_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Base);
      }
      if (classification_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Classification);
      }
      size += sourceReference_.CalculateSize(_repeated_sourceReference_codec);
      if (colorDescription_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ColorDescription);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RoadMarking other) {
      if (other == null) {
        return;
      }
      if (other.id_ != null) {
        if (id_ == null) {
          Id = new global::Osi3.Identifier();
        }
        Id.MergeFrom(other.Id);
      }
      if (other.base_ != null) {
        if (base_ == null) {
          Base = new global::Osi3.BaseStationary();
        }
        Base.MergeFrom(other.Base);
      }
      if (other.classification_ != null) {
        if (classification_ == null) {
          Classification = new global::Osi3.RoadMarking.Types.Classification();
        }
        Classification.MergeFrom(other.Classification);
      }
      sourceReference_.Add(other.sourceReference_);
      if (other.colorDescription_ != null) {
        if (colorDescription_ == null) {
          ColorDescription = new global::Osi3.ColorDescription();
        }
        ColorDescription.MergeFrom(other.ColorDescription);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (id_ == null) {
              Id = new global::Osi3.Identifier();
            }
            input.ReadMessage(Id);
            break;
          }
          case 18: {
            if (base_ == null) {
              Base = new global::Osi3.BaseStationary();
            }
            input.ReadMessage(Base);
            break;
          }
          case 26: {
            if (classification_ == null) {
              Classification = new global::Osi3.RoadMarking.Types.Classification();
            }
            input.ReadMessage(Classification);
            break;
          }
          case 34: {
            sourceReference_.AddEntriesFrom(input, _repeated_sourceReference_codec);
            break;
          }
          case 42: {
            if (colorDescription_ == null) {
              ColorDescription = new global::Osi3.ColorDescription();
            }
            input.ReadMessage(ColorDescription);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (id_ == null) {
              Id = new global::Osi3.Identifier();
            }
            input.ReadMessage(Id);
            break;
          }
          case 18: {
            if (base_ == null) {
              Base = new global::Osi3.BaseStationary();
            }
            input.ReadMessage(Base);
            break;
          }
          case 26: {
            if (classification_ == null) {
              Classification = new global::Osi3.RoadMarking.Types.Classification();
            }
            input.ReadMessage(Classification);
            break;
          }
          case 34: {
            sourceReference_.AddEntriesFrom(ref input, _repeated_sourceReference_codec);
            break;
          }
          case 42: {
            if (colorDescription_ == null) {
              ColorDescription = new global::Osi3.ColorDescription();
            }
            input.ReadMessage(ColorDescription);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the RoadMarking message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      ///
      /// \brief \c Classification data for a road surface marking.
      /// </summary>
      public sealed partial class Classification : pb::IMessage<Classification>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Classification> _parser = new pb::MessageParser<Classification>(() => new Classification());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Classification> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Osi3.RoadMarking.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Classification() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Classification(Classification other) : this() {
          type_ = other.type_;
          trafficMainSignType_ = other.trafficMainSignType_;
          monochromeColor_ = other.monochromeColor_;
          value_ = other.value_ != null ? other.value_.Clone() : null;
          valueText_ = other.valueText_;
          assignedLaneId_ = other.assignedLaneId_.Clone();
          isOutOfService_ = other.isOutOfService_;
          country_ = other.country_;
          countryRevision_ = other.countryRevision_;
          code_ = other.code_;
          subCode_ = other.subCode_;
          logicalLaneAssignment_ = other.logicalLaneAssignment_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Classification Clone() {
          return new Classification(this);
        }

        /// <summary>Field number for the "type" field.</summary>
        public const int TypeFieldNumber = 1;
        private global::Osi3.RoadMarking.Types.Classification.Types.Type type_ = global::Osi3.RoadMarking.Types.Classification.Types.Type.Unknown;
        /// <summary>
        /// The type of the road marking.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Osi3.RoadMarking.Types.Classification.Types.Type Type {
          get { return type_; }
          set {
            type_ = value;
          }
        }

        /// <summary>Field number for the "traffic_main_sign_type" field.</summary>
        public const int TrafficMainSignTypeFieldNumber = 2;
        private global::Osi3.TrafficSign.Types.MainSign.Types.Classification.Types.Type trafficMainSignType_ = global::Osi3.TrafficSign.Types.MainSign.Types.Classification.Types.Type.Unknown;
        /// <summary>
        /// Traffic sign as road marking (color image, monochrome image or
        /// character string).
        ///
        /// \note Field is set if ( \c #type == \c #TYPE_PAINTED_TRAFFIC_SIGN or
        /// \c #TYPE_SYMBOLIC_TRAFFIC_SIGN or \c #TYPE_TEXTUAL_TRAFFIC_SIGN ).
        ///
        /// \note Field need not be set (or set to \c #TYPE_OTHER)
        /// if road marking type (\c #type) does not require it.
        ///
        /// \attention Deprecated: A revision is planned for version 4.0.0 to
        /// replace the type enum with a more semantically defined enumeration,
        /// with the exact sign specification being relegated to the newly
        /// introduced 4-tupel traffic sign catalog specification as used in
        /// &lt;a href="https://releases.asam.net/OpenDRIVE/1.6.0/ASAM_OpenDRIVE_BS_V1-6-0.html#_signals">OpenDRIVE&lt;/a>.
        ///
        /// \rules
        /// check_if this.type is_greater_than_or_equal_to 2 else do_check is_set
        /// check_if this.type is_less_than_or_equal_to 4 else do_check is_set
        /// \endrules
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Osi3.TrafficSign.Types.MainSign.Types.Classification.Types.Type TrafficMainSignType {
          get { return trafficMainSignType_; }
          set {
            trafficMainSignType_ = value;
          }
        }

        /// <summary>Field number for the "monochrome_color" field.</summary>
        public const int MonochromeColorFieldNumber = 3;
        private global::Osi3.RoadMarking.Types.Classification.Types.Color monochromeColor_ = global::Osi3.RoadMarking.Types.Classification.Types.Color.Unknown;
        /// <summary>
        /// \note Field need not be set (or set to \c #COLOR_OTHER)
        /// if road marking type does not require it (e.g. for \c #type ==
        /// \c #TYPE_PAINTED_TRAFFIC_SIGN).
        ///
        /// \rules
        /// check_if this.type is_equal_to 2 else do_check is_set
        /// check_if this.monochrome_color is_equal_to 1 else do_check is_set
        /// \endrules
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Osi3.RoadMarking.Types.Classification.Types.Color MonochromeColor {
          get { return monochromeColor_; }
          set {
            monochromeColor_ = value;
          }
        }

        /// <summary>Field number for the "value" field.</summary>
        public const int ValueFieldNumber = 4;
        private global::Osi3.TrafficSignValue value_;
        /// <summary>
        /// Additional value associated with the road marking, e.g. value of the
        /// speed limit.
        ///
        /// \note Field need not be set if road marking type does not require it.
        ///
        /// \note OSI 3 uses \c #value_text and not \c TrafficSignValue for
        /// simple chars.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Osi3.TrafficSignValue Value {
          get { return value_; }
          set {
            value_ = value;
          }
        }

        /// <summary>Field number for the "value_text" field.</summary>
        public const int ValueTextFieldNumber = 5;
        private string valueText_ = "";
        /// <summary>
        /// Additional text value as road marking, e.g. BUS, TAXI etc.
        ///
        /// \note Field need not be set if road marking type does not require it.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string ValueText {
          get { return valueText_; }
          set {
            valueText_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "assigned_lane_id" field.</summary>
        public const int AssignedLaneIdFieldNumber = 6;
        private static readonly pb::FieldCodec<global::Osi3.Identifier> _repeated_assignedLaneId_codec
            = pb::FieldCodec.ForMessage(50, global::Osi3.Identifier.Parser);
        private readonly pbc::RepeatedField<global::Osi3.Identifier> assignedLaneId_ = new pbc::RepeatedField<global::Osi3.Identifier>();
        /// <summary>
        /// The ID(s) of the lane(s) that the road marking is assigned to.
        /// May be multiple if the road marking goes across multiple lanes.
        ///
        /// \note OSI uses singular instead of plural for repeated field names.
        ///
        /// \rules
        /// refers_to: Lane
        /// \endrules
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Osi3.Identifier> AssignedLaneId {
          get { return assignedLaneId_; }
        }

        /// <summary>Field number for the "is_out_of_service" field.</summary>
        public const int IsOutOfServiceFieldNumber = 7;
        private bool isOutOfService_;
        /// <summary>
        /// Boolean flag to indicate that the road marking is taken out of service.
        /// This can be achieved by visibly crossing the road marking with stripes,
        /// or completely covering a road marking making it not visible.
        ///
        /// \image html OSI_RoadMaking_is_out_of_service.jpg width=800px
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool IsOutOfService {
          get { return isOutOfService_; }
          set {
            isOutOfService_ = value;
          }
        }

        /// <summary>Field number for the "country" field.</summary>
        public const int CountryFieldNumber = 8;
        private string country_ = "";
        /// <summary>
        /// Country specification of the traffic sign catalog specification
        /// that identifies the actual traffic sign. This is part of the
        /// 4-tupel traffic sign catalog specification as used in
        /// &lt;a href="https://releases.asam.net/OpenDRIVE/1.6.0/ASAM_OpenDRIVE_BS_V1-6-0.html#_signals">OpenDRIVE&lt;/a>.
        ///
        /// Country is specified using the ISO 3166-1, alpha-2 code
        /// https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2, or the
        /// special OpenDRIVE country for generic signs.&lt;br>
        ///
        /// \rules
        /// check_if this.type is_greater_than_or_equal_to 2 else do_check is_set
        /// check_if this.type is_less_than_or_equal_to 4 else do_check is_set
        /// \endrules
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Country {
          get { return country_; }
          set {
            country_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "country_revision" field.</summary>
        public const int CountryRevisionFieldNumber = 9;
        private string countryRevision_ = "";
        /// <summary>
        /// Revision specification of the traffic sign catalog specification
        /// that identifies the actual traffic sign. This is part of the
        /// 4-tupel traffic sign catalog specification as used in
        /// &lt;a href="https://releases.asam.net/OpenDRIVE/1.6.0/ASAM_OpenDRIVE_BS_V1-6-0.html#_signals">OpenDRIVE&lt;/a>.
        ///
        /// The year the traffic rules came into force. &lt;br>
        /// e.g. "2017"
        ///
        /// \note Field is set if ( \c #type == \c #TYPE_PAINTED_TRAFFIC_SIGN or
        /// \c #TYPE_SYMBOLIC_TRAFFIC_SIGN or \c #TYPE_TEXTUAL_TRAFFIC_SIGN ).
        ///
        /// \note Field need not be set (or set to \c #TYPE_OTHER)
        /// if road marking type (\c #type) does not require it.
        ///
        /// \rules
        /// check_if this.type is_greater_than_or_equal_to 2 else do_check is_set
        /// check_if this.type is_less_than_or_equal_to 4 else do_check is_set
        /// \endrules
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string CountryRevision {
          get { return countryRevision_; }
          set {
            countryRevision_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "code" field.</summary>
        public const int CodeFieldNumber = 10;
        private string code_ = "";
        /// <summary>
        /// Code specification of the traffic sign catalog specification
        /// that identifies the actual traffic sign. This is part of the
        /// 4-tupel traffic sign catalog specification as used in
        /// &lt;a href="https://releases.asam.net/OpenDRIVE/1.6.0/ASAM_OpenDRIVE_BS_V1-6-0.html#_signals">OpenDRIVE&lt;/a>.
        ///
        /// Code identifier according to country and country revision,
        /// corresponds to the type field of OpenDRIVE. &lt;br>
        /// code is only unique in combination with #country and #country_revision.  &lt;br>
        /// e.g. http://www.vzkat.de/2017/VzKat.htm
        ///
        /// \note Field is set if ( \c #type == \c #TYPE_PAINTED_TRAFFIC_SIGN or
        /// \c #TYPE_SYMBOLIC_TRAFFIC_SIGN or \c #TYPE_TEXTUAL_TRAFFIC_SIGN ).
        ///
        /// \note Field need not be set (or set to \c #TYPE_OTHER)
        /// if road marking type (\c #type) does not require it.
        ///
        /// \rules
        /// check_if this.type is_greater_than_or_equal_to 2 else do_check is_set
        /// check_if this.type is_less_than_or_equal_to 4 else do_check is_set
        /// \endrules
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Code {
          get { return code_; }
          set {
            code_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "sub_code" field.</summary>
        public const int SubCodeFieldNumber = 11;
        private string subCode_ = "";
        /// <summary>
        /// Sub-code specification of the traffic sign catalog specification
        /// that identifies the actual traffic sign. This is part of the
        /// 4-tupel traffic sign catalog specification as used in
        /// &lt;a href="https://releases.asam.net/OpenDRIVE/1.6.0/ASAM_OpenDRIVE_BS_V1-6-0.html#_signals">OpenDRIVE&lt;/a>.
        ///
        /// Sub-code identifier according to country, country revision and code,
        /// corresponds to the subtype field of OpenDRIVE. &lt;br>
        /// sub_code is only unique in combination with #country, #country_revision,
        /// and #code.  &lt;br>
        /// e.g. http://www.vzkat.de/2017/VzKat.htm
        ///
        /// \note Field is set if ( \c #type == \c #TYPE_PAINTED_TRAFFIC_SIGN or
        /// \c #TYPE_SYMBOLIC_TRAFFIC_SIGN or \c #TYPE_TEXTUAL_TRAFFIC_SIGN ).
        ///
        /// \note Field need not be set (or set to \c #TYPE_OTHER)
        /// if road marking type (\c #type) does not require it.
        ///
        /// \rules
        /// check_if this.type is_greater_than_or_equal_to 2 else do_check is_set
        /// check_if this.type is_less_than_or_equal_to 4 else do_check is_set
        /// \endrules
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string SubCode {
          get { return subCode_; }
          set {
            subCode_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "logical_lane_assignment" field.</summary>
        public const int LogicalLaneAssignmentFieldNumber = 12;
        private static readonly pb::FieldCodec<global::Osi3.LogicalLaneAssignment> _repeated_logicalLaneAssignment_codec
            = pb::FieldCodec.ForMessage(98, global::Osi3.LogicalLaneAssignment.Parser);
        private readonly pbc::RepeatedField<global::Osi3.LogicalLaneAssignment> logicalLaneAssignment_ = new pbc::RepeatedField<global::Osi3.LogicalLaneAssignment>();
        /// <summary>
        /// Assignment of this object to logical lanes.
        ///
        /// \note OSI uses singular instead of plural for repeated field names.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Osi3.LogicalLaneAssignment> LogicalLaneAssignment {
          get { return logicalLaneAssignment_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Classification);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Classification other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Type != other.Type) return false;
          if (TrafficMainSignType != other.TrafficMainSignType) return false;
          if (MonochromeColor != other.MonochromeColor) return false;
          if (!object.Equals(Value, other.Value)) return false;
          if (ValueText != other.ValueText) return false;
          if(!assignedLaneId_.Equals(other.assignedLaneId_)) return false;
          if (IsOutOfService != other.IsOutOfService) return false;
          if (Country != other.Country) return false;
          if (CountryRevision != other.CountryRevision) return false;
          if (Code != other.Code) return false;
          if (SubCode != other.SubCode) return false;
          if(!logicalLaneAssignment_.Equals(other.logicalLaneAssignment_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Type != global::Osi3.RoadMarking.Types.Classification.Types.Type.Unknown) hash ^= Type.GetHashCode();
          if (TrafficMainSignType != global::Osi3.TrafficSign.Types.MainSign.Types.Classification.Types.Type.Unknown) hash ^= TrafficMainSignType.GetHashCode();
          if (MonochromeColor != global::Osi3.RoadMarking.Types.Classification.Types.Color.Unknown) hash ^= MonochromeColor.GetHashCode();
          if (value_ != null) hash ^= Value.GetHashCode();
          if (ValueText.Length != 0) hash ^= ValueText.GetHashCode();
          hash ^= assignedLaneId_.GetHashCode();
          if (IsOutOfService != false) hash ^= IsOutOfService.GetHashCode();
          if (Country.Length != 0) hash ^= Country.GetHashCode();
          if (CountryRevision.Length != 0) hash ^= CountryRevision.GetHashCode();
          if (Code.Length != 0) hash ^= Code.GetHashCode();
          if (SubCode.Length != 0) hash ^= SubCode.GetHashCode();
          hash ^= logicalLaneAssignment_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Type != global::Osi3.RoadMarking.Types.Classification.Types.Type.Unknown) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Type);
          }
          if (TrafficMainSignType != global::Osi3.TrafficSign.Types.MainSign.Types.Classification.Types.Type.Unknown) {
            output.WriteRawTag(16);
            output.WriteEnum((int) TrafficMainSignType);
          }
          if (MonochromeColor != global::Osi3.RoadMarking.Types.Classification.Types.Color.Unknown) {
            output.WriteRawTag(24);
            output.WriteEnum((int) MonochromeColor);
          }
          if (value_ != null) {
            output.WriteRawTag(34);
            output.WriteMessage(Value);
          }
          if (ValueText.Length != 0) {
            output.WriteRawTag(42);
            output.WriteString(ValueText);
          }
          assignedLaneId_.WriteTo(output, _repeated_assignedLaneId_codec);
          if (IsOutOfService != false) {
            output.WriteRawTag(56);
            output.WriteBool(IsOutOfService);
          }
          if (Country.Length != 0) {
            output.WriteRawTag(66);
            output.WriteString(Country);
          }
          if (CountryRevision.Length != 0) {
            output.WriteRawTag(74);
            output.WriteString(CountryRevision);
          }
          if (Code.Length != 0) {
            output.WriteRawTag(82);
            output.WriteString(Code);
          }
          if (SubCode.Length != 0) {
            output.WriteRawTag(90);
            output.WriteString(SubCode);
          }
          logicalLaneAssignment_.WriteTo(output, _repeated_logicalLaneAssignment_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Type != global::Osi3.RoadMarking.Types.Classification.Types.Type.Unknown) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Type);
          }
          if (TrafficMainSignType != global::Osi3.TrafficSign.Types.MainSign.Types.Classification.Types.Type.Unknown) {
            output.WriteRawTag(16);
            output.WriteEnum((int) TrafficMainSignType);
          }
          if (MonochromeColor != global::Osi3.RoadMarking.Types.Classification.Types.Color.Unknown) {
            output.WriteRawTag(24);
            output.WriteEnum((int) MonochromeColor);
          }
          if (value_ != null) {
            output.WriteRawTag(34);
            output.WriteMessage(Value);
          }
          if (ValueText.Length != 0) {
            output.WriteRawTag(42);
            output.WriteString(ValueText);
          }
          assignedLaneId_.WriteTo(ref output, _repeated_assignedLaneId_codec);
          if (IsOutOfService != false) {
            output.WriteRawTag(56);
            output.WriteBool(IsOutOfService);
          }
          if (Country.Length != 0) {
            output.WriteRawTag(66);
            output.WriteString(Country);
          }
          if (CountryRevision.Length != 0) {
            output.WriteRawTag(74);
            output.WriteString(CountryRevision);
          }
          if (Code.Length != 0) {
            output.WriteRawTag(82);
            output.WriteString(Code);
          }
          if (SubCode.Length != 0) {
            output.WriteRawTag(90);
            output.WriteString(SubCode);
          }
          logicalLaneAssignment_.WriteTo(ref output, _repeated_logicalLaneAssignment_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Type != global::Osi3.RoadMarking.Types.Classification.Types.Type.Unknown) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
          }
          if (TrafficMainSignType != global::Osi3.TrafficSign.Types.MainSign.Types.Classification.Types.Type.Unknown) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) TrafficMainSignType);
          }
          if (MonochromeColor != global::Osi3.RoadMarking.Types.Classification.Types.Color.Unknown) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) MonochromeColor);
          }
          if (value_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Value);
          }
          if (ValueText.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(ValueText);
          }
          size += assignedLaneId_.CalculateSize(_repeated_assignedLaneId_codec);
          if (IsOutOfService != false) {
            size += 1 + 1;
          }
          if (Country.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Country);
          }
          if (CountryRevision.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(CountryRevision);
          }
          if (Code.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Code);
          }
          if (SubCode.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(SubCode);
          }
          size += logicalLaneAssignment_.CalculateSize(_repeated_logicalLaneAssignment_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Classification other) {
          if (other == null) {
            return;
          }
          if (other.Type != global::Osi3.RoadMarking.Types.Classification.Types.Type.Unknown) {
            Type = other.Type;
          }
          if (other.TrafficMainSignType != global::Osi3.TrafficSign.Types.MainSign.Types.Classification.Types.Type.Unknown) {
            TrafficMainSignType = other.TrafficMainSignType;
          }
          if (other.MonochromeColor != global::Osi3.RoadMarking.Types.Classification.Types.Color.Unknown) {
            MonochromeColor = other.MonochromeColor;
          }
          if (other.value_ != null) {
            if (value_ == null) {
              Value = new global::Osi3.TrafficSignValue();
            }
            Value.MergeFrom(other.Value);
          }
          if (other.ValueText.Length != 0) {
            ValueText = other.ValueText;
          }
          assignedLaneId_.Add(other.assignedLaneId_);
          if (other.IsOutOfService != false) {
            IsOutOfService = other.IsOutOfService;
          }
          if (other.Country.Length != 0) {
            Country = other.Country;
          }
          if (other.CountryRevision.Length != 0) {
            CountryRevision = other.CountryRevision;
          }
          if (other.Code.Length != 0) {
            Code = other.Code;
          }
          if (other.SubCode.Length != 0) {
            SubCode = other.SubCode;
          }
          logicalLaneAssignment_.Add(other.logicalLaneAssignment_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Type = (global::Osi3.RoadMarking.Types.Classification.Types.Type) input.ReadEnum();
                break;
              }
              case 16: {
                TrafficMainSignType = (global::Osi3.TrafficSign.Types.MainSign.Types.Classification.Types.Type) input.ReadEnum();
                break;
              }
              case 24: {
                MonochromeColor = (global::Osi3.RoadMarking.Types.Classification.Types.Color) input.ReadEnum();
                break;
              }
              case 34: {
                if (value_ == null) {
                  Value = new global::Osi3.TrafficSignValue();
                }
                input.ReadMessage(Value);
                break;
              }
              case 42: {
                ValueText = input.ReadString();
                break;
              }
              case 50: {
                assignedLaneId_.AddEntriesFrom(input, _repeated_assignedLaneId_codec);
                break;
              }
              case 56: {
                IsOutOfService = input.ReadBool();
                break;
              }
              case 66: {
                Country = input.ReadString();
                break;
              }
              case 74: {
                CountryRevision = input.ReadString();
                break;
              }
              case 82: {
                Code = input.ReadString();
                break;
              }
              case 90: {
                SubCode = input.ReadString();
                break;
              }
              case 98: {
                logicalLaneAssignment_.AddEntriesFrom(input, _repeated_logicalLaneAssignment_codec);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                Type = (global::Osi3.RoadMarking.Types.Classification.Types.Type) input.ReadEnum();
                break;
              }
              case 16: {
                TrafficMainSignType = (global::Osi3.TrafficSign.Types.MainSign.Types.Classification.Types.Type) input.ReadEnum();
                break;
              }
              case 24: {
                MonochromeColor = (global::Osi3.RoadMarking.Types.Classification.Types.Color) input.ReadEnum();
                break;
              }
              case 34: {
                if (value_ == null) {
                  Value = new global::Osi3.TrafficSignValue();
                }
                input.ReadMessage(Value);
                break;
              }
              case 42: {
                ValueText = input.ReadString();
                break;
              }
              case 50: {
                assignedLaneId_.AddEntriesFrom(ref input, _repeated_assignedLaneId_codec);
                break;
              }
              case 56: {
                IsOutOfService = input.ReadBool();
                break;
              }
              case 66: {
                Country = input.ReadString();
                break;
              }
              case 74: {
                CountryRevision = input.ReadString();
                break;
              }
              case 82: {
                Code = input.ReadString();
                break;
              }
              case 90: {
                SubCode = input.ReadString();
                break;
              }
              case 98: {
                logicalLaneAssignment_.AddEntriesFrom(ref input, _repeated_logicalLaneAssignment_codec);
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the Classification message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          /// <summary>
          /// Definition of road marking types.
          /// </summary>
          public enum Type {
            /// <summary>
            /// Type of road marking is unknown (must not be used in ground
            /// truth).
            /// </summary>
            [pbr::OriginalName("TYPE_UNKNOWN")] Unknown = 0,
            /// <summary>
            /// Other (unspecified but known) type of road marking.
            /// </summary>
            [pbr::OriginalName("TYPE_OTHER")] Other = 1,
            /// <summary>
            /// Paint on the road surface indicating a color image of a traffic
            /// sign.
            /// </summary>
            [pbr::OriginalName("TYPE_PAINTED_TRAFFIC_SIGN")] PaintedTrafficSign = 2,
            /// <summary>
            /// Paint on the road surface indicating a monochrome logical symbol
            /// of a traffic sign (e.g. digits 50 as start of speed limit 50 or
            /// stop line for stop sign).
            /// </summary>
            [pbr::OriginalName("TYPE_SYMBOLIC_TRAFFIC_SIGN")] SymbolicTrafficSign = 3,
            /// <summary>
            /// Paint on the road surface as a character string (e.g. BUS as bus
            /// only lane).
            /// </summary>
            [pbr::OriginalName("TYPE_TEXTUAL_TRAFFIC_SIGN")] TextualTrafficSign = 4,
            /// <summary>
            /// Paint on the road surface indicating a generic symbol.
            /// </summary>
            [pbr::OriginalName("TYPE_GENERIC_SYMBOL")] GenericSymbol = 5,
            /// <summary>
            /// Paint on the road surface indicating a generic line.
            /// </summary>
            [pbr::OriginalName("TYPE_GENERIC_LINE")] GenericLine = 6,
            /// <summary>
            /// Paint on the road surface indicating a generic character string.
            /// </summary>
            [pbr::OriginalName("TYPE_GENERIC_TEXT")] GenericText = 7,
          }

          /// <summary>
          /// Definition of semantic road marking colors
          ///
          /// \note The color types represent the semantic classification of
          /// road markings only. They do not represent an actual visual appearance.
          /// </summary>
          public enum Color {
            /// <summary>
            /// Color of road marking is unknown (must not be used in ground
            /// truth).
            /// </summary>
            [pbr::OriginalName("COLOR_UNKNOWN")] Unknown = 0,
            /// <summary>
            /// Marking with another (unspecified but known) color.
            /// </summary>
            [pbr::OriginalName("COLOR_OTHER")] Other = 1,
            /// <summary>
            /// Marking with white color.
            /// </summary>
            [pbr::OriginalName("COLOR_WHITE")] White = 2,
            /// <summary>
            /// Marking with yellow / orange-yellow color.
            /// </summary>
            [pbr::OriginalName("COLOR_YELLOW")] Yellow = 3,
            /// <summary>
            /// Marking with blue color.
            /// </summary>
            [pbr::OriginalName("COLOR_BLUE")] Blue = 5,
            /// <summary>
            /// Marking with red color.
            /// </summary>
            [pbr::OriginalName("COLOR_RED")] Red = 6,
            /// <summary>
            /// Marking with green color.
            /// </summary>
            [pbr::OriginalName("COLOR_GREEN")] Green = 7,
            /// <summary>
            /// Marking with violet color.
            /// </summary>
            [pbr::OriginalName("COLOR_VIOLET")] Violet = 8,
            /// <summary>
            /// Marking with orange color.
            /// </summary>
            [pbr::OriginalName("COLOR_ORANGE")] Orange = 9,
          }

        }
        #endregion

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
