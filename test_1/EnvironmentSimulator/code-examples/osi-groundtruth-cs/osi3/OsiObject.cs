// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: osi_object.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Osi3 {

  /// <summary>Holder for reflection information generated from osi_object.proto</summary>
  public static partial class OsiObjectReflection {

    #region Descriptor
    /// <summary>File descriptor for osi_object.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static OsiObjectReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChBvc2lfb2JqZWN0LnByb3RvEgRvc2kzGhBvc2lfY29tbW9uLnByb3RvIvwO",
            "ChBTdGF0aW9uYXJ5T2JqZWN0EhwKAmlkGAEgASgLMhAub3NpMy5JZGVudGlm",
            "aWVyEiIKBGJhc2UYAiABKAsyFC5vc2kzLkJhc2VTdGF0aW9uYXJ5Ej0KDmNs",
            "YXNzaWZpY2F0aW9uGAMgASgLMiUub3NpMy5TdGF0aW9uYXJ5T2JqZWN0LkNs",
            "YXNzaWZpY2F0aW9uEhcKD21vZGVsX3JlZmVyZW5jZRgEIAEoCRIxChBzb3Vy",
            "Y2VfcmVmZXJlbmNlGAUgAygLMhcub3NpMy5FeHRlcm5hbFJlZmVyZW5jZRIx",
            "ChFjb2xvcl9kZXNjcmlwdGlvbhgGIAEoCzIWLm9zaTMuQ29sb3JEZXNjcmlw",
            "dGlvbhrnDAoOQ2xhc3NpZmljYXRpb24SOAoEdHlwZRgBIAEoDjIqLm9zaTMu",
            "U3RhdGlvbmFyeU9iamVjdC5DbGFzc2lmaWNhdGlvbi5UeXBlEkAKCG1hdGVy",
            "aWFsGAIgASgOMi4ub3NpMy5TdGF0aW9uYXJ5T2JqZWN0LkNsYXNzaWZpY2F0",
            "aW9uLk1hdGVyaWFsEj4KB2RlbnNpdHkYAyABKA4yLS5vc2kzLlN0YXRpb25h",
            "cnlPYmplY3QuQ2xhc3NpZmljYXRpb24uRGVuc2l0eRI6CgVjb2xvchgEIAEo",
            "DjIrLm9zaTMuU3RhdGlvbmFyeU9iamVjdC5DbGFzc2lmaWNhdGlvbi5Db2xv",
            "chJmChxlbWl0dGluZ19zdHJ1Y3R1cmVfYXR0cmlidXRlGAUgASgLMkAub3Np",
            "My5TdGF0aW9uYXJ5T2JqZWN0LkNsYXNzaWZpY2F0aW9uLkVtaXR0aW5nU3Ry",
            "dWN0dXJlQXR0cmlidXRlEioKEGFzc2lnbmVkX2xhbmVfaWQYBiADKAsyEC5v",
            "c2kzLklkZW50aWZpZXISIAoYYXNzaWduZWRfbGFuZV9wZXJjZW50YWdlGAcg",
            "AygBEjwKF2xvZ2ljYWxfbGFuZV9hc3NpZ25tZW50GAggAygLMhsub3NpMy5M",
            "b2dpY2FsTGFuZUFzc2lnbm1lbnQakQEKGkVtaXR0aW5nU3RydWN0dXJlQXR0",
            "cmlidXRlEi0KD3dhdmVsZW5ndGhfZGF0YRgBIAMoCzIULm9zaTMuV2F2ZWxl",
            "bmd0aERhdGESRAofZW1pdHRlZF9zcGF0aWFsX3NpZ25hbF9zdHJlbmd0aBgD",
            "IAMoCzIbLm9zaTMuU3BhdGlhbFNpZ25hbFN0cmVuZ3RoIqgDCgRUeXBlEhAK",
            "DFRZUEVfVU5LTk9XThAAEg4KClRZUEVfT1RIRVIQARIPCgtUWVBFX0JSSURH",
            "RRACEhEKDVRZUEVfQlVJTERJTkcQAxINCglUWVBFX1BPTEUQBBIOCgpUWVBF",
            "X1BZTE9OEAUSEwoPVFlQRV9ERUxJTkVBVE9SEAYSDQoJVFlQRV9UUkVFEAcS",
            "EAoMVFlQRV9CQVJSSUVSEAgSEwoPVFlQRV9WRUdFVEFUSU9OEAkSEgoOVFlQ",
            "RV9DVVJCU1RPTkUQChINCglUWVBFX1dBTEwQCxIbChdUWVBFX1ZFUlRJQ0FM",
            "X1NUUlVDVFVSRRAMEh4KGlRZUEVfUkVDVEFOR1VMQVJfU1RSVUNUVVJFEA0S",
            "GwoXVFlQRV9PVkVSSEVBRF9TVFJVQ1RVUkUQDhIdChlUWVBFX1JFRkxFQ1RJ",
            "VkVfU1RSVUNUVVJFEA8SIgoeVFlQRV9DT05TVFJVQ1RJT05fU0lURV9FTEVN",
            "RU5UEBASEwoPVFlQRV9TUEVFRF9CVU1QEBESGwoXVFlQRV9FTUlUVElOR19T",
            "VFJVQ1RVUkUQEiLBAQoITWF0ZXJpYWwSFAoQTUFURVJJQUxfVU5LTk9XThAA",
            "EhIKDk1BVEVSSUFMX09USEVSEAESEQoNTUFURVJJQUxfV09PRBACEhQKEE1B",
            "VEVSSUFMX1BMQVNUSUMQAxIVChFNQVRFUklBTF9DT05DUkVURRAEEhIKDk1B",
            "VEVSSUFMX01FVEFMEAUSEgoOTUFURVJJQUxfU1RPTkUQBhIRCg1NQVRFUklB",
            "TF9HTEFTEAcSEAoMTUFURVJJQUxfTVVEEAginwEKB0RlbnNpdHkSEwoPREVO",
            "U0lUWV9VTktOT1dOEAASEQoNREVOU0lUWV9PVEhFUhABEhEKDURFTlNJVFlf",
            "U09MSUQQAhIWChJERU5TSVRZX1NNQUxMX01FU0gQAxIXChNERU5TSVRZX01F",
            "RElBTl9NRVNIEAQSFgoSREVOU0lUWV9MQVJHRV9NRVNIEAUSEAoMREVOU0lU",
            "WV9PUEVOEAYiwwEKBUNvbG9yEhEKDUNPTE9SX1VOS05PV04QABIPCgtDT0xP",
            "Ul9PVEhFUhABEhAKDENPTE9SX1lFTExPVxACEg8KC0NPTE9SX0dSRUVOEAMS",
            "DgoKQ09MT1JfQkxVRRAEEhAKDENPTE9SX1ZJT0xFVBAFEg0KCUNPTE9SX1JF",
            "RBAGEhAKDENPTE9SX09SQU5HRRAHEg8KC0NPTE9SX0JMQUNLEAgSDgoKQ09M",
            "T1JfR1JFWRAJEg8KC0NPTE9SX1dISVRFEAoioR4KDE1vdmluZ09iamVjdBIc",
            "CgJpZBgBIAEoCzIQLm9zaTMuSWRlbnRpZmllchIeCgRiYXNlGAIgASgLMhAu",
            "b3NpMy5CYXNlTW92aW5nEiUKBHR5cGUYAyABKA4yFy5vc2kzLk1vdmluZ09i",
            "amVjdC5UeXBlEioKEGFzc2lnbmVkX2xhbmVfaWQYBCADKAsyEC5vc2kzLklk",
            "ZW50aWZpZXISQAoSdmVoaWNsZV9hdHRyaWJ1dGVzGAUgASgLMiQub3NpMy5N",
            "b3ZpbmdPYmplY3QuVmVoaWNsZUF0dHJpYnV0ZXMSSAoWdmVoaWNsZV9jbGFz",
            "c2lmaWNhdGlvbhgGIAEoCzIoLm9zaTMuTW92aW5nT2JqZWN0LlZlaGljbGVD",
            "bGFzc2lmaWNhdGlvbhIXCg9tb2RlbF9yZWZlcmVuY2UYByABKAkSKwoRZnV0",
            "dXJlX3RyYWplY3RvcnkYCCADKAsyEC5vc2kzLlN0YXRlUG9pbnQSUwocbW92",
            "aW5nX29iamVjdF9jbGFzc2lmaWNhdGlvbhgJIAEoCzItLm9zaTMuTW92aW5n",
            "T2JqZWN0Lk1vdmluZ09iamVjdENsYXNzaWZpY2F0aW9uEjEKEHNvdXJjZV9y",
            "ZWZlcmVuY2UYCiADKAsyFy5vc2kzLkV4dGVybmFsUmVmZXJlbmNlEjEKEWNv",
            "bG9yX2Rlc2NyaXB0aW9uGAsgASgLMhYub3NpMy5Db2xvckRlc2NyaXB0aW9u",
            "GrQEChFWZWhpY2xlQXR0cmlidXRlcxIjCglkcml2ZXJfaWQYASABKAsyEC5v",
            "c2kzLklkZW50aWZpZXISFAoMcmFkaXVzX3doZWVsGAIgASgBEhUKDW51bWJl",
            "cl93aGVlbHMYAyABKA0SKAoQYmJjZW50ZXJfdG9fcmVhchgEIAEoCzIOLm9z",
            "aTMuVmVjdG9yM2QSKQoRYmJjZW50ZXJfdG9fZnJvbnQYBSABKAsyDi5vc2kz",
            "LlZlY3RvcjNkEhgKEGdyb3VuZF9jbGVhcmFuY2UYBiABKAESQgoKd2hlZWxf",
            "ZGF0YRgHIAMoCzIuLm9zaTMuTW92aW5nT2JqZWN0LlZlaGljbGVBdHRyaWJ1",
            "dGVzLldoZWVsRGF0YRIcChRzdGVlcmluZ193aGVlbF9hbmdsZRgIIAEoARr7",
            "AQoJV2hlZWxEYXRhEgwKBGF4bGUYASABKA0SDQoFaW5kZXgYAiABKA0SIAoI",
            "cG9zaXRpb24YAyABKAsyDi5vc2kzLlZlY3RvcjNkEhQKDHdoZWVsX3JhZGl1",
            "cxgEIAEoARISCgpyaW1fcmFkaXVzGAUgASgBEg0KBXdpZHRoGAYgASgBEigK",
            "C29yaWVudGF0aW9uGAcgASgLMhMub3NpMy5PcmllbnRhdGlvbjNkEhUKDXJv",
            "dGF0aW9uX3JhdGUYCCABKAESFwoPbW9kZWxfcmVmZXJlbmNlGAkgASgJEhwK",
            "FGZyaWN0aW9uX2NvZWZmaWNpZW50GAogASgBGqgBChpNb3ZpbmdPYmplY3RD",
            "bGFzc2lmaWNhdGlvbhIqChBhc3NpZ25lZF9sYW5lX2lkGAEgAygLMhAub3Np",
            "My5JZGVudGlmaWVyEiAKGGFzc2lnbmVkX2xhbmVfcGVyY2VudGFnZRgCIAMo",
            "ARI8Chdsb2dpY2FsX2xhbmVfYXNzaWdubWVudBgDIAMoCzIbLm9zaTMuTG9n",
            "aWNhbExhbmVBc3NpZ25tZW50Gq4TChVWZWhpY2xlQ2xhc3NpZmljYXRpb24S",
            "OwoEdHlwZRgBIAEoDjItLm9zaTMuTW92aW5nT2JqZWN0LlZlaGljbGVDbGFz",
            "c2lmaWNhdGlvbi5UeXBlEkgKC2xpZ2h0X3N0YXRlGAIgASgLMjMub3NpMy5N",
            "b3ZpbmdPYmplY3QuVmVoaWNsZUNsYXNzaWZpY2F0aW9uLkxpZ2h0U3RhdGUS",
            "EwoLaGFzX3RyYWlsZXIYAyABKAgSJAoKdHJhaWxlcl9pZBgEIAEoCzIQLm9z",
            "aTMuSWRlbnRpZmllchI7CgRyb2xlGAUgASgOMi0ub3NpMy5Nb3ZpbmdPYmpl",
            "Y3QuVmVoaWNsZUNsYXNzaWZpY2F0aW9uLlJvbGUa0wwKCkxpZ2h0U3RhdGUS",
            "WwoPaW5kaWNhdG9yX3N0YXRlGAEgASgOMkIub3NpMy5Nb3ZpbmdPYmplY3Qu",
            "VmVoaWNsZUNsYXNzaWZpY2F0aW9uLkxpZ2h0U3RhdGUuSW5kaWNhdG9yU3Rh",
            "dGUSXgoPZnJvbnRfZm9nX2xpZ2h0GAIgASgOMkUub3NpMy5Nb3ZpbmdPYmpl",
            "Y3QuVmVoaWNsZUNsYXNzaWZpY2F0aW9uLkxpZ2h0U3RhdGUuR2VuZXJpY0xp",
            "Z2h0U3RhdGUSXQoOcmVhcl9mb2dfbGlnaHQYAyABKA4yRS5vc2kzLk1vdmlu",
            "Z09iamVjdC5WZWhpY2xlQ2xhc3NpZmljYXRpb24uTGlnaHRTdGF0ZS5HZW5l",
            "cmljTGlnaHRTdGF0ZRJZCgpoZWFkX2xpZ2h0GAQgASgOMkUub3NpMy5Nb3Zp",
            "bmdPYmplY3QuVmVoaWNsZUNsYXNzaWZpY2F0aW9uLkxpZ2h0U3RhdGUuR2Vu",
            "ZXJpY0xpZ2h0U3RhdGUSWAoJaGlnaF9iZWFtGAUgASgOMkUub3NpMy5Nb3Zp",
            "bmdPYmplY3QuVmVoaWNsZUNsYXNzaWZpY2F0aW9uLkxpZ2h0U3RhdGUuR2Vu",
            "ZXJpY0xpZ2h0U3RhdGUSXgoPcmV2ZXJzaW5nX2xpZ2h0GAYgASgOMkUub3Np",
            "My5Nb3ZpbmdPYmplY3QuVmVoaWNsZUNsYXNzaWZpY2F0aW9uLkxpZ2h0U3Rh",
            "dGUuR2VuZXJpY0xpZ2h0U3RhdGUSXgoRYnJha2VfbGlnaHRfc3RhdGUYByAB",
            "KA4yQy5vc2kzLk1vdmluZ09iamVjdC5WZWhpY2xlQ2xhc3NpZmljYXRpb24u",
            "TGlnaHRTdGF0ZS5CcmFrZUxpZ2h0U3RhdGUSbgofbGljZW5zZV9wbGF0ZV9p",
            "bGx1bWluYXRpb25fcmVhchgIIAEoDjJFLm9zaTMuTW92aW5nT2JqZWN0LlZl",
            "aGljbGVDbGFzc2lmaWNhdGlvbi5MaWdodFN0YXRlLkdlbmVyaWNMaWdodFN0",
            "YXRlEm0KHmVtZXJnZW5jeV92ZWhpY2xlX2lsbHVtaW5hdGlvbhgJIAEoDjJF",
            "Lm9zaTMuTW92aW5nT2JqZWN0LlZlaGljbGVDbGFzc2lmaWNhdGlvbi5MaWdo",
            "dFN0YXRlLkdlbmVyaWNMaWdodFN0YXRlEmsKHHNlcnZpY2VfdmVoaWNsZV9p",
            "bGx1bWluYXRpb24YCiABKA4yRS5vc2kzLk1vdmluZ09iamVjdC5WZWhpY2xl",
            "Q2xhc3NpZmljYXRpb24uTGlnaHRTdGF0ZS5HZW5lcmljTGlnaHRTdGF0ZSKz",
            "AQoOSW5kaWNhdG9yU3RhdGUSGwoXSU5ESUNBVE9SX1NUQVRFX1VOS05PV04Q",
            "ABIZChVJTkRJQ0FUT1JfU1RBVEVfT1RIRVIQARIXChNJTkRJQ0FUT1JfU1RB",
            "VEVfT0ZGEAISGAoUSU5ESUNBVE9SX1NUQVRFX0xFRlQQAxIZChVJTkRJQ0FU",
            "T1JfU1RBVEVfUklHSFQQBBIbChdJTkRJQ0FUT1JfU1RBVEVfV0FSTklORxAF",
            "IooCChFHZW5lcmljTGlnaHRTdGF0ZRIfChtHRU5FUklDX0xJR0hUX1NUQVRF",
            "X1VOS05PV04QABIdChlHRU5FUklDX0xJR0hUX1NUQVRFX09USEVSEAESGwoX",
            "R0VORVJJQ19MSUdIVF9TVEFURV9PRkYQAhIaChZHRU5FUklDX0xJR0hUX1NU",
            "QVRFX09OEAMSJQohR0VORVJJQ19MSUdIVF9TVEFURV9GTEFTSElOR19CTFVF",
            "EAQSLQopR0VORVJJQ19MSUdIVF9TVEFURV9GTEFTSElOR19CTFVFX0FORF9S",
            "RUQQBRImCiJHRU5FUklDX0xJR0hUX1NUQVRFX0ZMQVNISU5HX0FNQkVSEAYi",
            "pAEKD0JyYWtlTGlnaHRTdGF0ZRIdChlCUkFLRV9MSUdIVF9TVEFURV9VTktO",
            "T1dOEAASGwoXQlJBS0VfTElHSFRfU1RBVEVfT1RIRVIQARIZChVCUkFLRV9M",
            "SUdIVF9TVEFURV9PRkYQAhIcChhCUkFLRV9MSUdIVF9TVEFURV9OT1JNQUwQ",
            "AxIcChhCUkFLRV9MSUdIVF9TVEFURV9TVFJPTkcQBCLPAgoEVHlwZRIQCgxU",
            "WVBFX1VOS05PV04QABIOCgpUWVBFX09USEVSEAESEgoOVFlQRV9TTUFMTF9D",
            "QVIQAhIUChBUWVBFX0NPTVBBQ1RfQ0FSEAMSEwoPVFlQRV9NRURJVU1fQ0FS",
            "EAQSEwoPVFlQRV9MVVhVUllfQ0FSEAUSFQoRVFlQRV9ERUxJVkVSWV9WQU4Q",
            "BhIUChBUWVBFX0hFQVZZX1RSVUNLEAcSFAoQVFlQRV9TRU1JVFJBQ1RPUhAQ",
            "EhQKEFRZUEVfU0VNSVRSQUlMRVIQCBIQCgxUWVBFX1RSQUlMRVIQCRISCg5U",
            "WVBFX01PVE9SQklLRRAKEhAKDFRZUEVfQklDWUNMRRALEgwKCFRZUEVfQlVT",
            "EAwSDQoJVFlQRV9UUkFNEA0SDgoKVFlQRV9UUkFJThAOEhMKD1RZUEVfV0hF",
            "RUxDSEFJUhAPIu0BCgRSb2xlEhAKDFJPTEVfVU5LTk9XThAAEg4KClJPTEVf",
            "T1RIRVIQARIOCgpST0xFX0NJVklMEAISEgoOUk9MRV9BTUJVTEFOQ0UQAxIN",
            "CglST0xFX0ZJUkUQBBIPCgtST0xFX1BPTElDRRAFEhkKFVJPTEVfUFVCTElD",
            "X1RSQU5TUE9SVBAGEhgKFFJPTEVfUk9BRF9BU1NJU1RBTkNFEAcSGwoXUk9M",
            "RV9HQVJCQUdFX0NPTExFQ1RJT04QCBIaChZST0xFX1JPQURfQ09OU1RSVUNU",
            "SU9OEAkSEQoNUk9MRV9NSUxJVEFSWRAKImAKBFR5cGUSEAoMVFlQRV9VTktO",
            "T1dOEAASDgoKVFlQRV9PVEhFUhABEhAKDFRZUEVfVkVISUNMRRACEhMKD1RZ",
            "UEVfUEVERVNUUklBThADEg8KC1RZUEVfQU5JTUFMEARCAkgBYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Osi3.OsiCommonReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Osi3.StationaryObject), global::Osi3.StationaryObject.Parser, new[]{ "Id", "Base", "Classification", "ModelReference", "SourceReference", "ColorDescription" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Osi3.StationaryObject.Types.Classification), global::Osi3.StationaryObject.Types.Classification.Parser, new[]{ "Type", "Material", "Density", "Color", "EmittingStructureAttribute", "AssignedLaneId", "AssignedLanePercentage", "LogicalLaneAssignment" }, null, new[]{ typeof(global::Osi3.StationaryObject.Types.Classification.Types.Type), typeof(global::Osi3.StationaryObject.Types.Classification.Types.Material), typeof(global::Osi3.StationaryObject.Types.Classification.Types.Density), typeof(global::Osi3.StationaryObject.Types.Classification.Types.Color) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Osi3.StationaryObject.Types.Classification.Types.EmittingStructureAttribute), global::Osi3.StationaryObject.Types.Classification.Types.EmittingStructureAttribute.Parser, new[]{ "WavelengthData", "EmittedSpatialSignalStrength" }, null, null, null, null)})}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Osi3.MovingObject), global::Osi3.MovingObject.Parser, new[]{ "Id", "Base", "Type", "AssignedLaneId", "VehicleAttributes", "VehicleClassification", "ModelReference", "FutureTrajectory", "MovingObjectClassification", "SourceReference", "ColorDescription" }, null, new[]{ typeof(global::Osi3.MovingObject.Types.Type) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Osi3.MovingObject.Types.VehicleAttributes), global::Osi3.MovingObject.Types.VehicleAttributes.Parser, new[]{ "DriverId", "RadiusWheel", "NumberWheels", "BbcenterToRear", "BbcenterToFront", "GroundClearance", "WheelData", "SteeringWheelAngle" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Osi3.MovingObject.Types.VehicleAttributes.Types.WheelData), global::Osi3.MovingObject.Types.VehicleAttributes.Types.WheelData.Parser, new[]{ "Axle", "Index", "Position", "WheelRadius", "RimRadius", "Width", "Orientation", "RotationRate", "ModelReference", "FrictionCoefficient" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Osi3.MovingObject.Types.MovingObjectClassification), global::Osi3.MovingObject.Types.MovingObjectClassification.Parser, new[]{ "AssignedLaneId", "AssignedLanePercentage", "LogicalLaneAssignment" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Osi3.MovingObject.Types.VehicleClassification), global::Osi3.MovingObject.Types.VehicleClassification.Parser, new[]{ "Type", "LightState", "HasTrailer", "TrailerId", "Role" }, null, new[]{ typeof(global::Osi3.MovingObject.Types.VehicleClassification.Types.Type), typeof(global::Osi3.MovingObject.Types.VehicleClassification.Types.Role) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState), global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Parser, new[]{ "IndicatorState", "FrontFogLight", "RearFogLight", "HeadLight", "HighBeam", "ReversingLight", "BrakeLightState", "LicensePlateIlluminationRear", "EmergencyVehicleIllumination", "ServiceVehicleIllumination" }, null, new[]{ typeof(global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.IndicatorState), typeof(global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState), typeof(global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.BrakeLightState) }, null, null)})})
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  ///
  /// \brief A simulated object that is neither a moving object (vehicle or
  /// \c MovingObject e.g. pedestrian, animal, or vehicle) nor a traffic related
  /// object (\c TrafficLight, \c TrafficSign).
  ///
  /// \image html OSI_BaseStationary.svg
  ///
  /// \c StationaryObject excludes traffic lights, traffic signs and road marking
  /// </summary>
  public sealed partial class StationaryObject : pb::IMessage<StationaryObject>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<StationaryObject> _parser = new pb::MessageParser<StationaryObject>(() => new StationaryObject());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<StationaryObject> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Osi3.OsiObjectReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StationaryObject() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StationaryObject(StationaryObject other) : this() {
      id_ = other.id_ != null ? other.id_.Clone() : null;
      base_ = other.base_ != null ? other.base_.Clone() : null;
      classification_ = other.classification_ != null ? other.classification_.Clone() : null;
      modelReference_ = other.modelReference_;
      sourceReference_ = other.sourceReference_.Clone();
      colorDescription_ = other.colorDescription_ != null ? other.colorDescription_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StationaryObject Clone() {
      return new StationaryObject(this);
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private global::Osi3.Identifier id_;
    /// <summary>
    /// The ID of the object.
    ///
    /// \rules
    /// is_globally_unique
    /// \endrules
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.Identifier Id {
      get { return id_; }
      set {
        id_ = value;
      }
    }

    /// <summary>Field number for the "base" field.</summary>
    public const int BaseFieldNumber = 2;
    private global::Osi3.BaseStationary base_;
    /// <summary>
    /// The base parameters of the stationary object.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.BaseStationary Base {
      get { return base_; }
      set {
        base_ = value;
      }
    }

    /// <summary>Field number for the "classification" field.</summary>
    public const int ClassificationFieldNumber = 3;
    private global::Osi3.StationaryObject.Types.Classification classification_;
    /// <summary>
    /// The classification of the stationary object.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.StationaryObject.Types.Classification Classification {
      get { return classification_; }
      set {
        classification_ = value;
      }
    }

    /// <summary>Field number for the "model_reference" field.</summary>
    public const int ModelReferenceFieldNumber = 4;
    private string modelReference_ = "";
    /// <summary>
    /// Opaque reference of an associated 3D model of the stationary object.
    ///
    /// \note It is implementation-specific how model_references are resolved to
    /// 3d models.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ModelReference {
      get { return modelReference_; }
      set {
        modelReference_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "source_reference" field.</summary>
    public const int SourceReferenceFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Osi3.ExternalReference> _repeated_sourceReference_codec
        = pb::FieldCodec.ForMessage(42, global::Osi3.ExternalReference.Parser);
    private readonly pbc::RepeatedField<global::Osi3.ExternalReference> sourceReference_ = new pbc::RepeatedField<global::Osi3.ExternalReference>();
    /// <summary>
    /// External reference to the stationary-object source.
    ///
    /// The external reference points to the source of a stationary object, if it
    /// is derived from an external sources like OpenDRIVE or OpenSCENARIO.
    ///
    /// For example, to reference an object defined in an OpenDRIVE map
    /// the items should be set as follows:
    /// * reference = URI to map, can remain empty if identical with definiton
    ///               in \c GroundTruth::map_reference
    /// * type = "net.asam.opendrive"
    /// * identifier[0] = "object" for t_road_objects_object and
    ///                   "bridge" for t_road_objects_bridge
    /// * identifier[1] = id of t_road_objects_object or t_road_objects_bridge
    ///
    /// For example, to reference OpenSCENARIO entities of the type MiscObject,
    /// which describe partly stationary objects, the items should be set as
    /// follows:
    /// * reference = URI to the OpenSCENARIO File
    /// * type = "net.asam.openscenario"
    /// * identifier[0] = Entity-Type ("MiscObject")
    /// * identifier[1] = name of MiscObject in Entity
    ///
    /// \note The following rule, described in OpenDRIVE, also applies:
    /// * Objects derived from OpenSCENARIO shall not be mixed with objects
    ///   described in OpenDRIVE.
    ///
    /// \note For non-ASAM Standards, it is implementation-specific how
    ///       source_reference is resolved.
    ///
    /// \note The value has to be repeated because one object may be derived
    ///       from more than one origin source, for example, from a scenario file
    ///       and from sensors.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Osi3.ExternalReference> SourceReference {
      get { return sourceReference_; }
    }

    /// <summary>Field number for the "color_description" field.</summary>
    public const int ColorDescriptionFieldNumber = 6;
    private global::Osi3.ColorDescription colorDescription_;
    /// <summary>
    /// The dominating color of the material of the structure.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.ColorDescription ColorDescription {
      get { return colorDescription_; }
      set {
        colorDescription_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as StationaryObject);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(StationaryObject other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Id, other.Id)) return false;
      if (!object.Equals(Base, other.Base)) return false;
      if (!object.Equals(Classification, other.Classification)) return false;
      if (ModelReference != other.ModelReference) return false;
      if(!sourceReference_.Equals(other.sourceReference_)) return false;
      if (!object.Equals(ColorDescription, other.ColorDescription)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (id_ != null) hash ^= Id.GetHashCode();
      if (base_ != null) hash ^= Base.GetHashCode();
      if (classification_ != null) hash ^= Classification.GetHashCode();
      if (ModelReference.Length != 0) hash ^= ModelReference.GetHashCode();
      hash ^= sourceReference_.GetHashCode();
      if (colorDescription_ != null) hash ^= ColorDescription.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (id_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Id);
      }
      if (base_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Base);
      }
      if (classification_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Classification);
      }
      if (ModelReference.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(ModelReference);
      }
      sourceReference_.WriteTo(output, _repeated_sourceReference_codec);
      if (colorDescription_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(ColorDescription);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (id_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Id);
      }
      if (base_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Base);
      }
      if (classification_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Classification);
      }
      if (ModelReference.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(ModelReference);
      }
      sourceReference_.WriteTo(ref output, _repeated_sourceReference_codec);
      if (colorDescription_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(ColorDescription);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (id_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Id);
      }
      if (base_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Base);
      }
      if (classification_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Classification);
      }
      if (ModelReference.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ModelReference);
      }
      size += sourceReference_.CalculateSize(_repeated_sourceReference_codec);
      if (colorDescription_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ColorDescription);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(StationaryObject other) {
      if (other == null) {
        return;
      }
      if (other.id_ != null) {
        if (id_ == null) {
          Id = new global::Osi3.Identifier();
        }
        Id.MergeFrom(other.Id);
      }
      if (other.base_ != null) {
        if (base_ == null) {
          Base = new global::Osi3.BaseStationary();
        }
        Base.MergeFrom(other.Base);
      }
      if (other.classification_ != null) {
        if (classification_ == null) {
          Classification = new global::Osi3.StationaryObject.Types.Classification();
        }
        Classification.MergeFrom(other.Classification);
      }
      if (other.ModelReference.Length != 0) {
        ModelReference = other.ModelReference;
      }
      sourceReference_.Add(other.sourceReference_);
      if (other.colorDescription_ != null) {
        if (colorDescription_ == null) {
          ColorDescription = new global::Osi3.ColorDescription();
        }
        ColorDescription.MergeFrom(other.ColorDescription);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (id_ == null) {
              Id = new global::Osi3.Identifier();
            }
            input.ReadMessage(Id);
            break;
          }
          case 18: {
            if (base_ == null) {
              Base = new global::Osi3.BaseStationary();
            }
            input.ReadMessage(Base);
            break;
          }
          case 26: {
            if (classification_ == null) {
              Classification = new global::Osi3.StationaryObject.Types.Classification();
            }
            input.ReadMessage(Classification);
            break;
          }
          case 34: {
            ModelReference = input.ReadString();
            break;
          }
          case 42: {
            sourceReference_.AddEntriesFrom(input, _repeated_sourceReference_codec);
            break;
          }
          case 50: {
            if (colorDescription_ == null) {
              ColorDescription = new global::Osi3.ColorDescription();
            }
            input.ReadMessage(ColorDescription);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (id_ == null) {
              Id = new global::Osi3.Identifier();
            }
            input.ReadMessage(Id);
            break;
          }
          case 18: {
            if (base_ == null) {
              Base = new global::Osi3.BaseStationary();
            }
            input.ReadMessage(Base);
            break;
          }
          case 26: {
            if (classification_ == null) {
              Classification = new global::Osi3.StationaryObject.Types.Classification();
            }
            input.ReadMessage(Classification);
            break;
          }
          case 34: {
            ModelReference = input.ReadString();
            break;
          }
          case 42: {
            sourceReference_.AddEntriesFrom(ref input, _repeated_sourceReference_codec);
            break;
          }
          case 50: {
            if (colorDescription_ == null) {
              ColorDescription = new global::Osi3.ColorDescription();
            }
            input.ReadMessage(ColorDescription);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the StationaryObject message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      ///
      /// \brief Classification data for a stationary object.
      /// </summary>
      public sealed partial class Classification : pb::IMessage<Classification>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Classification> _parser = new pb::MessageParser<Classification>(() => new Classification());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Classification> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Osi3.StationaryObject.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Classification() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Classification(Classification other) : this() {
          type_ = other.type_;
          material_ = other.material_;
          density_ = other.density_;
          color_ = other.color_;
          emittingStructureAttribute_ = other.emittingStructureAttribute_ != null ? other.emittingStructureAttribute_.Clone() : null;
          assignedLaneId_ = other.assignedLaneId_.Clone();
          assignedLanePercentage_ = other.assignedLanePercentage_.Clone();
          logicalLaneAssignment_ = other.logicalLaneAssignment_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Classification Clone() {
          return new Classification(this);
        }

        /// <summary>Field number for the "type" field.</summary>
        public const int TypeFieldNumber = 1;
        private global::Osi3.StationaryObject.Types.Classification.Types.Type type_ = global::Osi3.StationaryObject.Types.Classification.Types.Type.Unknown;
        /// <summary>
        /// The type of the object.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Osi3.StationaryObject.Types.Classification.Types.Type Type {
          get { return type_; }
          set {
            type_ = value;
          }
        }

        /// <summary>Field number for the "material" field.</summary>
        public const int MaterialFieldNumber = 2;
        private global::Osi3.StationaryObject.Types.Classification.Types.Material material_ = global::Osi3.StationaryObject.Types.Classification.Types.Material.Unknown;
        /// <summary>
        /// The dominating material of the structure.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Osi3.StationaryObject.Types.Classification.Types.Material Material {
          get { return material_; }
          set {
            material_ = value;
          }
        }

        /// <summary>Field number for the "density" field.</summary>
        public const int DensityFieldNumber = 3;
        private global::Osi3.StationaryObject.Types.Classification.Types.Density density_ = global::Osi3.StationaryObject.Types.Classification.Types.Density.Unknown;
        /// <summary>
        /// The dominating density of the material of the structure.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Osi3.StationaryObject.Types.Classification.Types.Density Density {
          get { return density_; }
          set {
            density_ = value;
          }
        }

        /// <summary>Field number for the "color" field.</summary>
        public const int ColorFieldNumber = 4;
        private global::Osi3.StationaryObject.Types.Classification.Types.Color color_ = global::Osi3.StationaryObject.Types.Classification.Types.Color.Unknown;
        /// <summary>
        /// The dominating color of the material of the structure.
        ///
        /// \attention DEPRECATED: This color enum will be removed in version
        /// 4.0.0. Use the field \c #color_description (\c ColorDescription) of
        /// \c StationaryObject instead.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Osi3.StationaryObject.Types.Classification.Types.Color Color {
          get { return color_; }
          set {
            color_ = value;
          }
        }

        /// <summary>Field number for the "emitting_structure_attribute" field.</summary>
        public const int EmittingStructureAttributeFieldNumber = 5;
        private global::Osi3.StationaryObject.Types.Classification.Types.EmittingStructureAttribute emittingStructureAttribute_;
        /// <summary>
        /// The attributes of the emitting structure if stationary object is classified as such.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Osi3.StationaryObject.Types.Classification.Types.EmittingStructureAttribute EmittingStructureAttribute {
          get { return emittingStructureAttribute_; }
          set {
            emittingStructureAttribute_ = value;
          }
        }

        /// <summary>Field number for the "assigned_lane_id" field.</summary>
        public const int AssignedLaneIdFieldNumber = 6;
        private static readonly pb::FieldCodec<global::Osi3.Identifier> _repeated_assignedLaneId_codec
            = pb::FieldCodec.ForMessage(50, global::Osi3.Identifier.Parser);
        private readonly pbc::RepeatedField<global::Osi3.Identifier> assignedLaneId_ = new pbc::RepeatedField<global::Osi3.Identifier>();
        /// <summary>
        /// The IDs of the lanes that the object is assigned to.
        ///
        /// \note Might be multiple IDs if the object stretches over multiple lanes.
        ///
        /// \note OSI uses singular instead of plural for repeated field names.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Osi3.Identifier> AssignedLaneId {
          get { return assignedLaneId_; }
        }

        /// <summary>Field number for the "assigned_lane_percentage" field.</summary>
        public const int AssignedLanePercentageFieldNumber = 7;
        private static readonly pb::FieldCodec<double> _repeated_assignedLanePercentage_codec
            = pb::FieldCodec.ForDouble(58);
        private readonly pbc::RepeatedField<double> assignedLanePercentage_ = new pbc::RepeatedField<double>();
        /// <summary>
        /// Percentage values of the object width in the corresponding lane.
        ///
        /// \note Might be multiple percentages if the object stretches over multiple lanes.
        ///
        /// \note OSI uses singular instead of plural for repeated field names.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<double> AssignedLanePercentage {
          get { return assignedLanePercentage_; }
        }

        /// <summary>Field number for the "logical_lane_assignment" field.</summary>
        public const int LogicalLaneAssignmentFieldNumber = 8;
        private static readonly pb::FieldCodec<global::Osi3.LogicalLaneAssignment> _repeated_logicalLaneAssignment_codec
            = pb::FieldCodec.ForMessage(66, global::Osi3.LogicalLaneAssignment.Parser);
        private readonly pbc::RepeatedField<global::Osi3.LogicalLaneAssignment> logicalLaneAssignment_ = new pbc::RepeatedField<global::Osi3.LogicalLaneAssignment>();
        /// <summary>
        /// Assignment of this object to logical lanes.
        ///
        /// \note OSI uses singular instead of plural for repeated field names.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Osi3.LogicalLaneAssignment> LogicalLaneAssignment {
          get { return logicalLaneAssignment_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Classification);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Classification other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Type != other.Type) return false;
          if (Material != other.Material) return false;
          if (Density != other.Density) return false;
          if (Color != other.Color) return false;
          if (!object.Equals(EmittingStructureAttribute, other.EmittingStructureAttribute)) return false;
          if(!assignedLaneId_.Equals(other.assignedLaneId_)) return false;
          if(!assignedLanePercentage_.Equals(other.assignedLanePercentage_)) return false;
          if(!logicalLaneAssignment_.Equals(other.logicalLaneAssignment_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Type != global::Osi3.StationaryObject.Types.Classification.Types.Type.Unknown) hash ^= Type.GetHashCode();
          if (Material != global::Osi3.StationaryObject.Types.Classification.Types.Material.Unknown) hash ^= Material.GetHashCode();
          if (Density != global::Osi3.StationaryObject.Types.Classification.Types.Density.Unknown) hash ^= Density.GetHashCode();
          if (Color != global::Osi3.StationaryObject.Types.Classification.Types.Color.Unknown) hash ^= Color.GetHashCode();
          if (emittingStructureAttribute_ != null) hash ^= EmittingStructureAttribute.GetHashCode();
          hash ^= assignedLaneId_.GetHashCode();
          hash ^= assignedLanePercentage_.GetHashCode();
          hash ^= logicalLaneAssignment_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Type != global::Osi3.StationaryObject.Types.Classification.Types.Type.Unknown) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Type);
          }
          if (Material != global::Osi3.StationaryObject.Types.Classification.Types.Material.Unknown) {
            output.WriteRawTag(16);
            output.WriteEnum((int) Material);
          }
          if (Density != global::Osi3.StationaryObject.Types.Classification.Types.Density.Unknown) {
            output.WriteRawTag(24);
            output.WriteEnum((int) Density);
          }
          if (Color != global::Osi3.StationaryObject.Types.Classification.Types.Color.Unknown) {
            output.WriteRawTag(32);
            output.WriteEnum((int) Color);
          }
          if (emittingStructureAttribute_ != null) {
            output.WriteRawTag(42);
            output.WriteMessage(EmittingStructureAttribute);
          }
          assignedLaneId_.WriteTo(output, _repeated_assignedLaneId_codec);
          assignedLanePercentage_.WriteTo(output, _repeated_assignedLanePercentage_codec);
          logicalLaneAssignment_.WriteTo(output, _repeated_logicalLaneAssignment_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Type != global::Osi3.StationaryObject.Types.Classification.Types.Type.Unknown) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Type);
          }
          if (Material != global::Osi3.StationaryObject.Types.Classification.Types.Material.Unknown) {
            output.WriteRawTag(16);
            output.WriteEnum((int) Material);
          }
          if (Density != global::Osi3.StationaryObject.Types.Classification.Types.Density.Unknown) {
            output.WriteRawTag(24);
            output.WriteEnum((int) Density);
          }
          if (Color != global::Osi3.StationaryObject.Types.Classification.Types.Color.Unknown) {
            output.WriteRawTag(32);
            output.WriteEnum((int) Color);
          }
          if (emittingStructureAttribute_ != null) {
            output.WriteRawTag(42);
            output.WriteMessage(EmittingStructureAttribute);
          }
          assignedLaneId_.WriteTo(ref output, _repeated_assignedLaneId_codec);
          assignedLanePercentage_.WriteTo(ref output, _repeated_assignedLanePercentage_codec);
          logicalLaneAssignment_.WriteTo(ref output, _repeated_logicalLaneAssignment_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Type != global::Osi3.StationaryObject.Types.Classification.Types.Type.Unknown) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
          }
          if (Material != global::Osi3.StationaryObject.Types.Classification.Types.Material.Unknown) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Material);
          }
          if (Density != global::Osi3.StationaryObject.Types.Classification.Types.Density.Unknown) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Density);
          }
          if (Color != global::Osi3.StationaryObject.Types.Classification.Types.Color.Unknown) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Color);
          }
          if (emittingStructureAttribute_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(EmittingStructureAttribute);
          }
          size += assignedLaneId_.CalculateSize(_repeated_assignedLaneId_codec);
          size += assignedLanePercentage_.CalculateSize(_repeated_assignedLanePercentage_codec);
          size += logicalLaneAssignment_.CalculateSize(_repeated_logicalLaneAssignment_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Classification other) {
          if (other == null) {
            return;
          }
          if (other.Type != global::Osi3.StationaryObject.Types.Classification.Types.Type.Unknown) {
            Type = other.Type;
          }
          if (other.Material != global::Osi3.StationaryObject.Types.Classification.Types.Material.Unknown) {
            Material = other.Material;
          }
          if (other.Density != global::Osi3.StationaryObject.Types.Classification.Types.Density.Unknown) {
            Density = other.Density;
          }
          if (other.Color != global::Osi3.StationaryObject.Types.Classification.Types.Color.Unknown) {
            Color = other.Color;
          }
          if (other.emittingStructureAttribute_ != null) {
            if (emittingStructureAttribute_ == null) {
              EmittingStructureAttribute = new global::Osi3.StationaryObject.Types.Classification.Types.EmittingStructureAttribute();
            }
            EmittingStructureAttribute.MergeFrom(other.EmittingStructureAttribute);
          }
          assignedLaneId_.Add(other.assignedLaneId_);
          assignedLanePercentage_.Add(other.assignedLanePercentage_);
          logicalLaneAssignment_.Add(other.logicalLaneAssignment_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Type = (global::Osi3.StationaryObject.Types.Classification.Types.Type) input.ReadEnum();
                break;
              }
              case 16: {
                Material = (global::Osi3.StationaryObject.Types.Classification.Types.Material) input.ReadEnum();
                break;
              }
              case 24: {
                Density = (global::Osi3.StationaryObject.Types.Classification.Types.Density) input.ReadEnum();
                break;
              }
              case 32: {
                Color = (global::Osi3.StationaryObject.Types.Classification.Types.Color) input.ReadEnum();
                break;
              }
              case 42: {
                if (emittingStructureAttribute_ == null) {
                  EmittingStructureAttribute = new global::Osi3.StationaryObject.Types.Classification.Types.EmittingStructureAttribute();
                }
                input.ReadMessage(EmittingStructureAttribute);
                break;
              }
              case 50: {
                assignedLaneId_.AddEntriesFrom(input, _repeated_assignedLaneId_codec);
                break;
              }
              case 58:
              case 57: {
                assignedLanePercentage_.AddEntriesFrom(input, _repeated_assignedLanePercentage_codec);
                break;
              }
              case 66: {
                logicalLaneAssignment_.AddEntriesFrom(input, _repeated_logicalLaneAssignment_codec);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                Type = (global::Osi3.StationaryObject.Types.Classification.Types.Type) input.ReadEnum();
                break;
              }
              case 16: {
                Material = (global::Osi3.StationaryObject.Types.Classification.Types.Material) input.ReadEnum();
                break;
              }
              case 24: {
                Density = (global::Osi3.StationaryObject.Types.Classification.Types.Density) input.ReadEnum();
                break;
              }
              case 32: {
                Color = (global::Osi3.StationaryObject.Types.Classification.Types.Color) input.ReadEnum();
                break;
              }
              case 42: {
                if (emittingStructureAttribute_ == null) {
                  EmittingStructureAttribute = new global::Osi3.StationaryObject.Types.Classification.Types.EmittingStructureAttribute();
                }
                input.ReadMessage(EmittingStructureAttribute);
                break;
              }
              case 50: {
                assignedLaneId_.AddEntriesFrom(ref input, _repeated_assignedLaneId_codec);
                break;
              }
              case 58:
              case 57: {
                assignedLanePercentage_.AddEntriesFrom(ref input, _repeated_assignedLanePercentage_codec);
                break;
              }
              case 66: {
                logicalLaneAssignment_.AddEntriesFrom(ref input, _repeated_logicalLaneAssignment_codec);
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the Classification message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          /// <summary>
          /// Definition of object types.
          /// </summary>
          public enum Type {
            /// <summary>
            /// Type of the object is unknown (must not be used in ground truth).
            /// </summary>
            [pbr::OriginalName("TYPE_UNKNOWN")] Unknown = 0,
            /// <summary>
            /// Other (unspecified but known) type of object.
            /// </summary>
            [pbr::OriginalName("TYPE_OTHER")] Other = 1,
            /// <summary>
            /// Object is a bridge.
            /// </summary>
            [pbr::OriginalName("TYPE_BRIDGE")] Bridge = 2,
            /// <summary>
            /// Object is a building.
            /// </summary>
            [pbr::OriginalName("TYPE_BUILDING")] Building = 3,
            /// <summary>
            /// Object is a pole (e.g. from a traffic light).
            /// </summary>
            [pbr::OriginalName("TYPE_POLE")] Pole = 4,
            /// <summary>
            /// Object is a pylon.
            /// </summary>
            [pbr::OriginalName("TYPE_PYLON")] Pylon = 5,
            /// <summary>
            /// Object is a delineator (e.g. at a construction site).
            /// </summary>
            [pbr::OriginalName("TYPE_DELINEATOR")] Delineator = 6,
            /// <summary>
            /// Object is a tree.
            /// </summary>
            [pbr::OriginalName("TYPE_TREE")] Tree = 7,
            /// <summary>
            /// Object is a barrier.
            /// </summary>
            [pbr::OriginalName("TYPE_BARRIER")] Barrier = 8,
            /// <summary>
            /// Object is vegetation.
            /// </summary>
            [pbr::OriginalName("TYPE_VEGETATION")] Vegetation = 9,
            /// <summary>
            /// Object is a curbstone.
            /// </summary>
            [pbr::OriginalName("TYPE_CURBSTONE")] Curbstone = 10,
            /// <summary>
            /// Object is a wall.
            /// </summary>
            [pbr::OriginalName("TYPE_WALL")] Wall = 11,
            /// <summary>
            /// Landmarks corresponding to vertical structures in the
            /// environment.
            /// </summary>
            [pbr::OriginalName("TYPE_VERTICAL_STRUCTURE")] VerticalStructure = 12,
            /// <summary>
            /// Landmarks corresponding to rectangular structures in the
            /// environment, like walls.
            /// </summary>
            [pbr::OriginalName("TYPE_RECTANGULAR_STRUCTURE")] RectangularStructure = 13,
            /// <summary>
            /// Landmarks corresponding to overhead structures in the
            /// environment, like sign bridges.
            /// </summary>
            [pbr::OriginalName("TYPE_OVERHEAD_STRUCTURE")] OverheadStructure = 14,
            /// <summary>
            /// Landmarks corresponding to reflective structures
            /// in the environment, like reflective poles on the
            /// road boarder.
            /// </summary>
            [pbr::OriginalName("TYPE_REFLECTIVE_STRUCTURE")] ReflectiveStructure = 15,
            /// <summary>
            /// Landmarks corresponding to construction site elements in the
            /// environment, like beacons.
            /// </summary>
            [pbr::OriginalName("TYPE_CONSTRUCTION_SITE_ELEMENT")] ConstructionSiteElement = 16,
            /// <summary>
            /// Object is a speed bump.
            /// </summary>
            [pbr::OriginalName("TYPE_SPEED_BUMP")] SpeedBump = 17,
            /// <summary>
            /// Landmarks corresponding to sources of electromagnetic waves
            /// in the environment, like street lights.
            /// </summary>
            [pbr::OriginalName("TYPE_EMITTING_STRUCTURE")] EmittingStructure = 18,
          }

          /// <summary>
          /// Definition of material types.
          /// </summary>
          public enum Material {
            /// <summary>
            /// Type of the material is unknown (must not be used in ground
            /// truth).
            /// </summary>
            [pbr::OriginalName("MATERIAL_UNKNOWN")] Unknown = 0,
            /// <summary>
            /// Other (unspecified but known) type of material.
            /// </summary>
            [pbr::OriginalName("MATERIAL_OTHER")] Other = 1,
            /// <summary>
            /// Wooden structure.
            /// </summary>
            [pbr::OriginalName("MATERIAL_WOOD")] Wood = 2,
            /// <summary>
            /// Plastic structure.
            /// </summary>
            [pbr::OriginalName("MATERIAL_PLASTIC")] Plastic = 3,
            /// <summary>
            /// Concrete structure.
            /// </summary>
            [pbr::OriginalName("MATERIAL_CONCRETE")] Concrete = 4,
            /// <summary>
            /// Metal structure.
            /// </summary>
            [pbr::OriginalName("MATERIAL_METAL")] Metal = 5,
            /// <summary>
            /// Natural stone structure.
            /// </summary>
            [pbr::OriginalName("MATERIAL_STONE")] Stone = 6,
            /// <summary>
            /// Glas structure.
            /// </summary>
            [pbr::OriginalName("MATERIAL_GLAS")] Glas = 7,
            /// <summary>
            /// Mud structure.
            /// </summary>
            [pbr::OriginalName("MATERIAL_MUD")] Mud = 8,
          }

          /// <summary>
          /// Definition of material density types.
          /// </summary>
          public enum Density {
            /// <summary>
            /// Type of the material density is unknown (must not be used in
            /// ground truth).
            /// </summary>
            [pbr::OriginalName("DENSITY_UNKNOWN")] Unknown = 0,
            /// <summary>
            /// Other (unspecified but known) type of material density.
            /// </summary>
            [pbr::OriginalName("DENSITY_OTHER")] Other = 1,
            /// <summary>
            /// No perforation - solid;
            /// </summary>
            [pbr::OriginalName("DENSITY_SOLID")] Solid = 2,
            /// <summary>
            /// Perforation max. ]0; 100] mm
            /// </summary>
            [pbr::OriginalName("DENSITY_SMALL_MESH")] SmallMesh = 3,
            /// <summary>
            /// Perforation max. ]100; 500] mm
            /// </summary>
            [pbr::OriginalName("DENSITY_MEDIAN_MESH")] MedianMesh = 4,
            /// <summary>
            /// Perforation max. ]500; 5000] mm
            /// </summary>
            [pbr::OriginalName("DENSITY_LARGE_MESH")] LargeMesh = 5,
            /// <summary>
            /// Perforation max. ]5000; infinity[ mm
            /// </summary>
            [pbr::OriginalName("DENSITY_OPEN")] Open = 6,
          }

          /// <summary>
          /// Definition of colors for structures.
          ///
          /// \attention DEPRECATED: This color enum will be removed in version
          /// 4.0.0. Use \c ColorDescription instead.
          /// </summary>
          public enum Color {
            /// <summary>
            /// Color is unknown (must not be used in ground truth).
            /// </summary>
            [pbr::OriginalName("COLOR_UNKNOWN")] Unknown = 0,
            /// <summary>
            /// Other (unspecified but known) color.
            /// </summary>
            [pbr::OriginalName("COLOR_OTHER")] Other = 1,
            /// <summary>
            /// Yellow.
            /// </summary>
            [pbr::OriginalName("COLOR_YELLOW")] Yellow = 2,
            /// <summary>
            /// Green.
            /// </summary>
            [pbr::OriginalName("COLOR_GREEN")] Green = 3,
            /// <summary>
            /// Blue.
            /// </summary>
            [pbr::OriginalName("COLOR_BLUE")] Blue = 4,
            /// <summary>
            /// Violet.
            /// </summary>
            [pbr::OriginalName("COLOR_VIOLET")] Violet = 5,
            /// <summary>
            /// Red.
            /// </summary>
            [pbr::OriginalName("COLOR_RED")] Red = 6,
            /// <summary>
            /// Orange.
            /// </summary>
            [pbr::OriginalName("COLOR_ORANGE")] Orange = 7,
            /// <summary>
            /// Black.
            /// </summary>
            [pbr::OriginalName("COLOR_BLACK")] Black = 8,
            /// <summary>
            /// GREY.
            /// </summary>
            [pbr::OriginalName("COLOR_GREY")] Grey = 9,
            /// <summary>
            /// White.
            /// </summary>
            [pbr::OriginalName("COLOR_WHITE")] White = 10,
          }

          /// <summary>
          ///
          /// \brief Attributes of type emitting structure. The horizontal_angle and the vertical_angle in
          /// emitted_spatial_intensity are symmetrical across the normal, which is defined by the mounting position
          /// of the emitting structure.
          /// </summary>
          public sealed partial class EmittingStructureAttribute : pb::IMessage<EmittingStructureAttribute>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<EmittingStructureAttribute> _parser = new pb::MessageParser<EmittingStructureAttribute>(() => new EmittingStructureAttribute());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<EmittingStructureAttribute> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Osi3.StationaryObject.Types.Classification.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public EmittingStructureAttribute() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public EmittingStructureAttribute(EmittingStructureAttribute other) : this() {
              wavelengthData_ = other.wavelengthData_.Clone();
              emittedSpatialSignalStrength_ = other.emittedSpatialSignalStrength_.Clone();
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public EmittingStructureAttribute Clone() {
              return new EmittingStructureAttribute(this);
            }

            /// <summary>Field number for the "wavelength_data" field.</summary>
            public const int WavelengthDataFieldNumber = 1;
            private static readonly pb::FieldCodec<global::Osi3.WavelengthData> _repeated_wavelengthData_codec
                = pb::FieldCodec.ForMessage(10, global::Osi3.WavelengthData.Parser);
            private readonly pbc::RepeatedField<global::Osi3.WavelengthData> wavelengthData_ = new pbc::RepeatedField<global::Osi3.WavelengthData>();
            /// <summary>
            /// This message determines the range of the emitted wavelength and its
            /// desired number of samples.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public pbc::RepeatedField<global::Osi3.WavelengthData> WavelengthData {
              get { return wavelengthData_; }
            }

            /// <summary>Field number for the "emitted_spatial_signal_strength" field.</summary>
            public const int EmittedSpatialSignalStrengthFieldNumber = 3;
            private static readonly pb::FieldCodec<global::Osi3.SpatialSignalStrength> _repeated_emittedSpatialSignalStrength_codec
                = pb::FieldCodec.ForMessage(26, global::Osi3.SpatialSignalStrength.Parser);
            private readonly pbc::RepeatedField<global::Osi3.SpatialSignalStrength> emittedSpatialSignalStrength_ = new pbc::RepeatedField<global::Osi3.SpatialSignalStrength>();
            /// <summary>
            /// Spatial signal strength distribution of the emitted electromagnetic wave.
            /// For every sample in wavelength_data an emitted_spatial_signal_strength has to be defined.
            ///
            /// \note emitted_spatial_signal_strength.size() = WavelengthData.samples_number.size()
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public pbc::RepeatedField<global::Osi3.SpatialSignalStrength> EmittedSpatialSignalStrength {
              get { return emittedSpatialSignalStrength_; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as EmittingStructureAttribute);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(EmittingStructureAttribute other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if(!wavelengthData_.Equals(other.wavelengthData_)) return false;
              if(!emittedSpatialSignalStrength_.Equals(other.emittedSpatialSignalStrength_)) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              hash ^= wavelengthData_.GetHashCode();
              hash ^= emittedSpatialSignalStrength_.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              wavelengthData_.WriteTo(output, _repeated_wavelengthData_codec);
              emittedSpatialSignalStrength_.WriteTo(output, _repeated_emittedSpatialSignalStrength_codec);
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              wavelengthData_.WriteTo(ref output, _repeated_wavelengthData_codec);
              emittedSpatialSignalStrength_.WriteTo(ref output, _repeated_emittedSpatialSignalStrength_codec);
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              size += wavelengthData_.CalculateSize(_repeated_wavelengthData_codec);
              size += emittedSpatialSignalStrength_.CalculateSize(_repeated_emittedSpatialSignalStrength_codec);
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(EmittingStructureAttribute other) {
              if (other == null) {
                return;
              }
              wavelengthData_.Add(other.wavelengthData_);
              emittedSpatialSignalStrength_.Add(other.emittedSpatialSignalStrength_);
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    wavelengthData_.AddEntriesFrom(input, _repeated_wavelengthData_codec);
                    break;
                  }
                  case 26: {
                    emittedSpatialSignalStrength_.AddEntriesFrom(input, _repeated_emittedSpatialSignalStrength_codec);
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 10: {
                    wavelengthData_.AddEntriesFrom(ref input, _repeated_wavelengthData_codec);
                    break;
                  }
                  case 26: {
                    emittedSpatialSignalStrength_.AddEntriesFrom(ref input, _repeated_emittedSpatialSignalStrength_codec);
                    break;
                  }
                }
              }
            }
            #endif

          }

        }
        #endregion

      }

    }
    #endregion

  }

  /// <summary>
  ///
  /// \brief A simulated object that is either a vehicle or another
  /// moving object (animal, pedestrian, etc), but not a stationary
  /// object (\c TrafficLight, \c TrafficSign, or \c StationaryObject).
  ///
  /// \image html OSI_MovingObject.svg
  ///
  /// \image html OSI_HostVehicle.svg
  ///
  /// \note The field \c MovingObject::vehicle_extension has to be
  /// filled if the \c MovingObject::Type is a vehicle.
  /// </summary>
  public sealed partial class MovingObject : pb::IMessage<MovingObject>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<MovingObject> _parser = new pb::MessageParser<MovingObject>(() => new MovingObject());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<MovingObject> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Osi3.OsiObjectReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MovingObject() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MovingObject(MovingObject other) : this() {
      id_ = other.id_ != null ? other.id_.Clone() : null;
      base_ = other.base_ != null ? other.base_.Clone() : null;
      type_ = other.type_;
      assignedLaneId_ = other.assignedLaneId_.Clone();
      vehicleAttributes_ = other.vehicleAttributes_ != null ? other.vehicleAttributes_.Clone() : null;
      vehicleClassification_ = other.vehicleClassification_ != null ? other.vehicleClassification_.Clone() : null;
      modelReference_ = other.modelReference_;
      futureTrajectory_ = other.futureTrajectory_.Clone();
      movingObjectClassification_ = other.movingObjectClassification_ != null ? other.movingObjectClassification_.Clone() : null;
      sourceReference_ = other.sourceReference_.Clone();
      colorDescription_ = other.colorDescription_ != null ? other.colorDescription_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MovingObject Clone() {
      return new MovingObject(this);
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private global::Osi3.Identifier id_;
    /// <summary>
    /// The ID of the object.
    ///
    /// \rules
    /// is_globally_unique
    /// \endrules
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.Identifier Id {
      get { return id_; }
      set {
        id_ = value;
      }
    }

    /// <summary>Field number for the "base" field.</summary>
    public const int BaseFieldNumber = 2;
    private global::Osi3.BaseMoving base_;
    /// <summary>
    /// The base parameters of the vehicle.
    ///
    /// \note The bounding box does NOT include side mirrors for vehicles.
    /// \note The height includes the ground_clearance. It always goes from the
    /// top to the ground.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.BaseMoving Base {
      get { return base_; }
      set {
        base_ = value;
      }
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 3;
    private global::Osi3.MovingObject.Types.Type type_ = global::Osi3.MovingObject.Types.Type.Unknown;
    /// <summary>
    /// The type of the object.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.MovingObject.Types.Type Type {
      get { return type_; }
      set {
        type_ = value;
      }
    }

    /// <summary>Field number for the "assigned_lane_id" field.</summary>
    public const int AssignedLaneIdFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Osi3.Identifier> _repeated_assignedLaneId_codec
        = pb::FieldCodec.ForMessage(34, global::Osi3.Identifier.Parser);
    private readonly pbc::RepeatedField<global::Osi3.Identifier> assignedLaneId_ = new pbc::RepeatedField<global::Osi3.Identifier>();
    /// <summary>
    /// The IDs of the lanes that this object is assigned to.
    ///
    /// \note Might be multiple if the object is switching lanes or moving from
    /// one lane into another following lane.
    ///
    /// \note DEPRECATED: Use assigned_lane_id in MovingObjectClassification
    /// instead.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Osi3.Identifier> AssignedLaneId {
      get { return assignedLaneId_; }
    }

    /// <summary>Field number for the "vehicle_attributes" field.</summary>
    public const int VehicleAttributesFieldNumber = 5;
    private global::Osi3.MovingObject.Types.VehicleAttributes vehicleAttributes_;
    /// <summary>
    /// Specific information about the vehicle.
    ///
    /// \note This field is mandatory if the \c #type is
    /// #TYPE_VEHICLE .
    ///
    /// \rules
    /// check_if this.type is_equal_to 2 else do_check is_set
    /// \endrules
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.MovingObject.Types.VehicleAttributes VehicleAttributes {
      get { return vehicleAttributes_; }
      set {
        vehicleAttributes_ = value;
      }
    }

    /// <summary>Field number for the "vehicle_classification" field.</summary>
    public const int VehicleClassificationFieldNumber = 6;
    private global::Osi3.MovingObject.Types.VehicleClassification vehicleClassification_;
    /// <summary>
    /// Specific information about the classification of the vehicle.
    ///
    /// \note This field is mandatory if the \c #type is
    /// #TYPE_VEHICLE .
    ///
    /// \rules
    /// check_if this.type is_equal_to 2 else do_check is_set
    /// \endrules
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.MovingObject.Types.VehicleClassification VehicleClassification {
      get { return vehicleClassification_; }
      set {
        vehicleClassification_ = value;
      }
    }

    /// <summary>Field number for the "model_reference" field.</summary>
    public const int ModelReferenceFieldNumber = 7;
    private string modelReference_ = "";
    /// <summary>
    /// Opaque reference of an associated 3D model of the moving object.
    ///
    /// \note It is implementation-specific how model_references are resolved to
    /// 3d models.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ModelReference {
      get { return modelReference_; }
      set {
        modelReference_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "future_trajectory" field.</summary>
    public const int FutureTrajectoryFieldNumber = 8;
    private static readonly pb::FieldCodec<global::Osi3.StatePoint> _repeated_futureTrajectory_codec
        = pb::FieldCodec.ForMessage(66, global::Osi3.StatePoint.Parser);
    private readonly pbc::RepeatedField<global::Osi3.StatePoint> futureTrajectory_ = new pbc::RepeatedField<global::Osi3.StatePoint>();
    /// <summary>
    /// The trajectory that this moving object expects to follow in the future.
    ///
    /// This is not externally perceivable information, rather this is to aid
    /// realistic simulation of traffic participants that are not under test.
    /// This information should not be made available to the stack under test.
    ///
    /// \note Moving objects are not required to stick to this trajectory, it is
    /// indicative, and equivalent to the output of a perception + prediction
    /// system.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Osi3.StatePoint> FutureTrajectory {
      get { return futureTrajectory_; }
    }

    /// <summary>Field number for the "moving_object_classification" field.</summary>
    public const int MovingObjectClassificationFieldNumber = 9;
    private global::Osi3.MovingObject.Types.MovingObjectClassification movingObjectClassification_;
    /// <summary>
    /// Specific information about the classification of the vehicle.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.MovingObject.Types.MovingObjectClassification MovingObjectClassification {
      get { return movingObjectClassification_; }
      set {
        movingObjectClassification_ = value;
      }
    }

    /// <summary>Field number for the "source_reference" field.</summary>
    public const int SourceReferenceFieldNumber = 10;
    private static readonly pb::FieldCodec<global::Osi3.ExternalReference> _repeated_sourceReference_codec
        = pb::FieldCodec.ForMessage(82, global::Osi3.ExternalReference.Parser);
    private readonly pbc::RepeatedField<global::Osi3.ExternalReference> sourceReference_ = new pbc::RepeatedField<global::Osi3.ExternalReference>();
    /// <summary>
    /// Optional external reference to the moving-object source
    ///
    /// The external reference points to the source of an moving object, if it
    /// is derived from an external sources like OpenSCENARIO.
    ///
    /// For example, to reference OpenSCENARIO entities of the type Vehicle or
    /// Pedestrian, which describe moving objects, the items should be set as
    /// follows:
    /// * reference = URI to the OpenSCENARIO File
    /// * type = "net.asam.openscenario"
    /// * identifier[0] = Entity-Type ("Vehicle" or "Pedestrian")
    /// * identifier[1] = name of Vehicle/Pedestrian in Entity
    ///
    /// \todo OpenSCENARIO currently does not provide an animal type.
    ///
    /// \note For non-ASAM Standards, it is implementation-specific how
    ///       source_reference is resolved.
    ///
    /// \note The value has to be repeated because one object may be derived
    ///       from more than one origin source, for example, from a scenario file
    ///       and from sensors.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Osi3.ExternalReference> SourceReference {
      get { return sourceReference_; }
    }

    /// <summary>Field number for the "color_description" field.</summary>
    public const int ColorDescriptionFieldNumber = 11;
    private global::Osi3.ColorDescription colorDescription_;
    /// <summary>
    /// The dominating color of the material of the moving object.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.ColorDescription ColorDescription {
      get { return colorDescription_; }
      set {
        colorDescription_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as MovingObject);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(MovingObject other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Id, other.Id)) return false;
      if (!object.Equals(Base, other.Base)) return false;
      if (Type != other.Type) return false;
      if(!assignedLaneId_.Equals(other.assignedLaneId_)) return false;
      if (!object.Equals(VehicleAttributes, other.VehicleAttributes)) return false;
      if (!object.Equals(VehicleClassification, other.VehicleClassification)) return false;
      if (ModelReference != other.ModelReference) return false;
      if(!futureTrajectory_.Equals(other.futureTrajectory_)) return false;
      if (!object.Equals(MovingObjectClassification, other.MovingObjectClassification)) return false;
      if(!sourceReference_.Equals(other.sourceReference_)) return false;
      if (!object.Equals(ColorDescription, other.ColorDescription)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (id_ != null) hash ^= Id.GetHashCode();
      if (base_ != null) hash ^= Base.GetHashCode();
      if (Type != global::Osi3.MovingObject.Types.Type.Unknown) hash ^= Type.GetHashCode();
      hash ^= assignedLaneId_.GetHashCode();
      if (vehicleAttributes_ != null) hash ^= VehicleAttributes.GetHashCode();
      if (vehicleClassification_ != null) hash ^= VehicleClassification.GetHashCode();
      if (ModelReference.Length != 0) hash ^= ModelReference.GetHashCode();
      hash ^= futureTrajectory_.GetHashCode();
      if (movingObjectClassification_ != null) hash ^= MovingObjectClassification.GetHashCode();
      hash ^= sourceReference_.GetHashCode();
      if (colorDescription_ != null) hash ^= ColorDescription.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (id_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Id);
      }
      if (base_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Base);
      }
      if (Type != global::Osi3.MovingObject.Types.Type.Unknown) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Type);
      }
      assignedLaneId_.WriteTo(output, _repeated_assignedLaneId_codec);
      if (vehicleAttributes_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(VehicleAttributes);
      }
      if (vehicleClassification_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(VehicleClassification);
      }
      if (ModelReference.Length != 0) {
        output.WriteRawTag(58);
        output.WriteString(ModelReference);
      }
      futureTrajectory_.WriteTo(output, _repeated_futureTrajectory_codec);
      if (movingObjectClassification_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(MovingObjectClassification);
      }
      sourceReference_.WriteTo(output, _repeated_sourceReference_codec);
      if (colorDescription_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(ColorDescription);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (id_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Id);
      }
      if (base_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Base);
      }
      if (Type != global::Osi3.MovingObject.Types.Type.Unknown) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Type);
      }
      assignedLaneId_.WriteTo(ref output, _repeated_assignedLaneId_codec);
      if (vehicleAttributes_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(VehicleAttributes);
      }
      if (vehicleClassification_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(VehicleClassification);
      }
      if (ModelReference.Length != 0) {
        output.WriteRawTag(58);
        output.WriteString(ModelReference);
      }
      futureTrajectory_.WriteTo(ref output, _repeated_futureTrajectory_codec);
      if (movingObjectClassification_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(MovingObjectClassification);
      }
      sourceReference_.WriteTo(ref output, _repeated_sourceReference_codec);
      if (colorDescription_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(ColorDescription);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (id_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Id);
      }
      if (base_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Base);
      }
      if (Type != global::Osi3.MovingObject.Types.Type.Unknown) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      size += assignedLaneId_.CalculateSize(_repeated_assignedLaneId_codec);
      if (vehicleAttributes_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(VehicleAttributes);
      }
      if (vehicleClassification_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(VehicleClassification);
      }
      if (ModelReference.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ModelReference);
      }
      size += futureTrajectory_.CalculateSize(_repeated_futureTrajectory_codec);
      if (movingObjectClassification_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(MovingObjectClassification);
      }
      size += sourceReference_.CalculateSize(_repeated_sourceReference_codec);
      if (colorDescription_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ColorDescription);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(MovingObject other) {
      if (other == null) {
        return;
      }
      if (other.id_ != null) {
        if (id_ == null) {
          Id = new global::Osi3.Identifier();
        }
        Id.MergeFrom(other.Id);
      }
      if (other.base_ != null) {
        if (base_ == null) {
          Base = new global::Osi3.BaseMoving();
        }
        Base.MergeFrom(other.Base);
      }
      if (other.Type != global::Osi3.MovingObject.Types.Type.Unknown) {
        Type = other.Type;
      }
      assignedLaneId_.Add(other.assignedLaneId_);
      if (other.vehicleAttributes_ != null) {
        if (vehicleAttributes_ == null) {
          VehicleAttributes = new global::Osi3.MovingObject.Types.VehicleAttributes();
        }
        VehicleAttributes.MergeFrom(other.VehicleAttributes);
      }
      if (other.vehicleClassification_ != null) {
        if (vehicleClassification_ == null) {
          VehicleClassification = new global::Osi3.MovingObject.Types.VehicleClassification();
        }
        VehicleClassification.MergeFrom(other.VehicleClassification);
      }
      if (other.ModelReference.Length != 0) {
        ModelReference = other.ModelReference;
      }
      futureTrajectory_.Add(other.futureTrajectory_);
      if (other.movingObjectClassification_ != null) {
        if (movingObjectClassification_ == null) {
          MovingObjectClassification = new global::Osi3.MovingObject.Types.MovingObjectClassification();
        }
        MovingObjectClassification.MergeFrom(other.MovingObjectClassification);
      }
      sourceReference_.Add(other.sourceReference_);
      if (other.colorDescription_ != null) {
        if (colorDescription_ == null) {
          ColorDescription = new global::Osi3.ColorDescription();
        }
        ColorDescription.MergeFrom(other.ColorDescription);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (id_ == null) {
              Id = new global::Osi3.Identifier();
            }
            input.ReadMessage(Id);
            break;
          }
          case 18: {
            if (base_ == null) {
              Base = new global::Osi3.BaseMoving();
            }
            input.ReadMessage(Base);
            break;
          }
          case 24: {
            Type = (global::Osi3.MovingObject.Types.Type) input.ReadEnum();
            break;
          }
          case 34: {
            assignedLaneId_.AddEntriesFrom(input, _repeated_assignedLaneId_codec);
            break;
          }
          case 42: {
            if (vehicleAttributes_ == null) {
              VehicleAttributes = new global::Osi3.MovingObject.Types.VehicleAttributes();
            }
            input.ReadMessage(VehicleAttributes);
            break;
          }
          case 50: {
            if (vehicleClassification_ == null) {
              VehicleClassification = new global::Osi3.MovingObject.Types.VehicleClassification();
            }
            input.ReadMessage(VehicleClassification);
            break;
          }
          case 58: {
            ModelReference = input.ReadString();
            break;
          }
          case 66: {
            futureTrajectory_.AddEntriesFrom(input, _repeated_futureTrajectory_codec);
            break;
          }
          case 74: {
            if (movingObjectClassification_ == null) {
              MovingObjectClassification = new global::Osi3.MovingObject.Types.MovingObjectClassification();
            }
            input.ReadMessage(MovingObjectClassification);
            break;
          }
          case 82: {
            sourceReference_.AddEntriesFrom(input, _repeated_sourceReference_codec);
            break;
          }
          case 90: {
            if (colorDescription_ == null) {
              ColorDescription = new global::Osi3.ColorDescription();
            }
            input.ReadMessage(ColorDescription);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (id_ == null) {
              Id = new global::Osi3.Identifier();
            }
            input.ReadMessage(Id);
            break;
          }
          case 18: {
            if (base_ == null) {
              Base = new global::Osi3.BaseMoving();
            }
            input.ReadMessage(Base);
            break;
          }
          case 24: {
            Type = (global::Osi3.MovingObject.Types.Type) input.ReadEnum();
            break;
          }
          case 34: {
            assignedLaneId_.AddEntriesFrom(ref input, _repeated_assignedLaneId_codec);
            break;
          }
          case 42: {
            if (vehicleAttributes_ == null) {
              VehicleAttributes = new global::Osi3.MovingObject.Types.VehicleAttributes();
            }
            input.ReadMessage(VehicleAttributes);
            break;
          }
          case 50: {
            if (vehicleClassification_ == null) {
              VehicleClassification = new global::Osi3.MovingObject.Types.VehicleClassification();
            }
            input.ReadMessage(VehicleClassification);
            break;
          }
          case 58: {
            ModelReference = input.ReadString();
            break;
          }
          case 66: {
            futureTrajectory_.AddEntriesFrom(ref input, _repeated_futureTrajectory_codec);
            break;
          }
          case 74: {
            if (movingObjectClassification_ == null) {
              MovingObjectClassification = new global::Osi3.MovingObject.Types.MovingObjectClassification();
            }
            input.ReadMessage(MovingObjectClassification);
            break;
          }
          case 82: {
            sourceReference_.AddEntriesFrom(ref input, _repeated_sourceReference_codec);
            break;
          }
          case 90: {
            if (colorDescription_ == null) {
              ColorDescription = new global::Osi3.ColorDescription();
            }
            input.ReadMessage(ColorDescription);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the MovingObject message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Definition of object types.
      /// </summary>
      public enum Type {
        /// <summary>
        /// Type of the object is unknown (must not be used in ground truth).
        /// </summary>
        [pbr::OriginalName("TYPE_UNKNOWN")] Unknown = 0,
        /// <summary>
        /// Other (unspecified but known) type of moving object.
        /// </summary>
        [pbr::OriginalName("TYPE_OTHER")] Other = 1,
        /// <summary>
        /// Object is a vehicle.
        /// </summary>
        [pbr::OriginalName("TYPE_VEHICLE")] Vehicle = 2,
        /// <summary>
        /// Object is a pedestrian.
        /// </summary>
        [pbr::OriginalName("TYPE_PEDESTRIAN")] Pedestrian = 3,
        /// <summary>
        /// Object is an animal.
        /// </summary>
        [pbr::OriginalName("TYPE_ANIMAL")] Animal = 4,
      }

      /// <summary>
      ///
      /// \brief The vehicle attributes for \c MovingObject (host or other).
      ///
      /// This is an extension to the \c MovingObject with additional attributes,
      /// such as type and lights. The origin of the rear (front) axis coordinate
      /// system in global coordinates is calculated as:
      /// \c MovingObject::base . \c BaseMoving::position + R * \c
      /// MovingObject::VehicleAttributes::bbcenter_to_rear (front) for the host
      /// vehicle (R rotates from vehicle to world frame, i.e. inverse orientation
      /// of \c MovingObject::base . \c BaseMoving::orientation).
      ///
      /// For all vehicles, including host vehicles, the position given in
      ///  \c MovingObject::base . \c BaseMoving::position points to the center of
      ///  the vehicle's bounding box.
      ///
      /// The vehicle object coordinates are defined as x-axis is the direction
      /// from rear to front of the vehicle, y-axis corresponds to rear axle and
      /// z-axis points to vehicle ceiling [1]. The coordinate system is
      /// right-handed. Therefore the positive y-axis points to the left of the
      /// vehicle.
      ///
      /// \par Reference:
      /// [1] DIN Deutsches Institut fuer Normung e. V. (2013). &lt;em>DIN ISO 8855 Strassenfahrzeuge - Fahrzeugdynamik und Fahrverhalten - Begriffe&lt;/em>. (DIN ISO 8855:2013-11). Berlin, Germany.
      /// </summary>
      public sealed partial class VehicleAttributes : pb::IMessage<VehicleAttributes>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<VehicleAttributes> _parser = new pb::MessageParser<VehicleAttributes>(() => new VehicleAttributes());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<VehicleAttributes> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Osi3.MovingObject.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public VehicleAttributes() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public VehicleAttributes(VehicleAttributes other) : this() {
          driverId_ = other.driverId_ != null ? other.driverId_.Clone() : null;
          radiusWheel_ = other.radiusWheel_;
          numberWheels_ = other.numberWheels_;
          bbcenterToRear_ = other.bbcenterToRear_ != null ? other.bbcenterToRear_.Clone() : null;
          bbcenterToFront_ = other.bbcenterToFront_ != null ? other.bbcenterToFront_.Clone() : null;
          groundClearance_ = other.groundClearance_;
          wheelData_ = other.wheelData_.Clone();
          steeringWheelAngle_ = other.steeringWheelAngle_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public VehicleAttributes Clone() {
          return new VehicleAttributes(this);
        }

        /// <summary>Field number for the "driver_id" field.</summary>
        public const int DriverIdFieldNumber = 1;
        private global::Osi3.Identifier driverId_;
        /// <summary>
        /// The ID of the driver of the (host) vehicle.
        ///
        /// \note Field need not be set if host_vehicle is set to false or use
        /// value for non valid id.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Osi3.Identifier DriverId {
          get { return driverId_; }
          set {
            driverId_ = value;
          }
        }

        /// <summary>Field number for the "radius_wheel" field.</summary>
        public const int RadiusWheelFieldNumber = 2;
        private double radiusWheel_;
        /// <summary>
        /// Deprecated: Will be removed in next major release. Moved to WheelData.
        /// Median radius of the wheels measured from a center of the wheel
        /// including tire.
        ///
        /// Unit: m
        ///
        /// \rules
        /// is_greater_than_or_equal_to: 0
        /// \endrules
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public double RadiusWheel {
          get { return radiusWheel_; }
          set {
            radiusWheel_ = value;
          }
        }

        /// <summary>Field number for the "number_wheels" field.</summary>
        public const int NumberWheelsFieldNumber = 3;
        private uint numberWheels_;
        /// <summary>
        /// Number of independent wheels.
        ///
        /// \rules
        /// is_greater_than_or_equal_to: 1
        /// \endrules
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public uint NumberWheels {
          get { return numberWheels_; }
          set {
            numberWheels_ = value;
          }
        }

        /// <summary>Field number for the "bbcenter_to_rear" field.</summary>
        public const int BbcenterToRearFieldNumber = 4;
        private global::Osi3.Vector3d bbcenterToRear_;
        /// <summary>
        /// The vector pointing from the bounding box center point (\c
        /// MovingObject::base . \c BaseMoving::position) to the middle (in x, y
        /// and z) of the rear axle under neutral load conditions. In object
        /// coordinates.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Osi3.Vector3d BbcenterToRear {
          get { return bbcenterToRear_; }
          set {
            bbcenterToRear_ = value;
          }
        }

        /// <summary>Field number for the "bbcenter_to_front" field.</summary>
        public const int BbcenterToFrontFieldNumber = 5;
        private global::Osi3.Vector3d bbcenterToFront_;
        /// <summary>
        /// The vector pointing from the bounding box center point (\c
        /// MovingObject::base . \c BaseMoving::position) to the middle (in x, y
        /// and z) of the front axle under neutral load conditions. In object
        /// coordinates.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Osi3.Vector3d BbcenterToFront {
          get { return bbcenterToFront_; }
          set {
            bbcenterToFront_ = value;
          }
        }

        /// <summary>Field number for the "ground_clearance" field.</summary>
        public const int GroundClearanceFieldNumber = 6;
        private double groundClearance_;
        /// <summary>
        /// Static minimal distance or space from the lowest point of the vehicle's
        /// body to the surface plane below it under neutral load conditions. This
        /// distance disregards, for example, driving-dynamic effects or
        /// road-surface effects. Can be useful to approximate the clearance area
        /// under a vehicle that a sensor can see through.
        /// \note \c ground_clearance is included in the bounding box height.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public double GroundClearance {
          get { return groundClearance_; }
          set {
            groundClearance_ = value;
          }
        }

        /// <summary>Field number for the "wheel_data" field.</summary>
        public const int WheelDataFieldNumber = 7;
        private static readonly pb::FieldCodec<global::Osi3.MovingObject.Types.VehicleAttributes.Types.WheelData> _repeated_wheelData_codec
            = pb::FieldCodec.ForMessage(58, global::Osi3.MovingObject.Types.VehicleAttributes.Types.WheelData.Parser);
        private readonly pbc::RepeatedField<global::Osi3.MovingObject.Types.VehicleAttributes.Types.WheelData> wheelData_ = new pbc::RepeatedField<global::Osi3.MovingObject.Types.VehicleAttributes.Types.WheelData>();
        /// <summary>
        /// Description of each wheel.
        ///
        /// \note OSI uses singular instead of plural for repeated field names.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Osi3.MovingObject.Types.VehicleAttributes.Types.WheelData> WheelData {
          get { return wheelData_; }
        }

        /// <summary>Field number for the "steering_wheel_angle" field.</summary>
        public const int SteeringWheelAngleFieldNumber = 8;
        private double steeringWheelAngle_;
        /// <summary>
        /// Angle of the steering wheel.
        /// Zero means the steering wheel is in its center postion, a positive value
        /// means the steering wheel is turned to the left and a negative value
        /// means the steering wheel is turned to the right of the center position.
        ///
        /// Unit: rad
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public double SteeringWheelAngle {
          get { return steeringWheelAngle_; }
          set {
            steeringWheelAngle_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as VehicleAttributes);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(VehicleAttributes other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(DriverId, other.DriverId)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(RadiusWheel, other.RadiusWheel)) return false;
          if (NumberWheels != other.NumberWheels) return false;
          if (!object.Equals(BbcenterToRear, other.BbcenterToRear)) return false;
          if (!object.Equals(BbcenterToFront, other.BbcenterToFront)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(GroundClearance, other.GroundClearance)) return false;
          if(!wheelData_.Equals(other.wheelData_)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(SteeringWheelAngle, other.SteeringWheelAngle)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (driverId_ != null) hash ^= DriverId.GetHashCode();
          if (RadiusWheel != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(RadiusWheel);
          if (NumberWheels != 0) hash ^= NumberWheels.GetHashCode();
          if (bbcenterToRear_ != null) hash ^= BbcenterToRear.GetHashCode();
          if (bbcenterToFront_ != null) hash ^= BbcenterToFront.GetHashCode();
          if (GroundClearance != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(GroundClearance);
          hash ^= wheelData_.GetHashCode();
          if (SteeringWheelAngle != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(SteeringWheelAngle);
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (driverId_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(DriverId);
          }
          if (RadiusWheel != 0D) {
            output.WriteRawTag(17);
            output.WriteDouble(RadiusWheel);
          }
          if (NumberWheels != 0) {
            output.WriteRawTag(24);
            output.WriteUInt32(NumberWheels);
          }
          if (bbcenterToRear_ != null) {
            output.WriteRawTag(34);
            output.WriteMessage(BbcenterToRear);
          }
          if (bbcenterToFront_ != null) {
            output.WriteRawTag(42);
            output.WriteMessage(BbcenterToFront);
          }
          if (GroundClearance != 0D) {
            output.WriteRawTag(49);
            output.WriteDouble(GroundClearance);
          }
          wheelData_.WriteTo(output, _repeated_wheelData_codec);
          if (SteeringWheelAngle != 0D) {
            output.WriteRawTag(65);
            output.WriteDouble(SteeringWheelAngle);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (driverId_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(DriverId);
          }
          if (RadiusWheel != 0D) {
            output.WriteRawTag(17);
            output.WriteDouble(RadiusWheel);
          }
          if (NumberWheels != 0) {
            output.WriteRawTag(24);
            output.WriteUInt32(NumberWheels);
          }
          if (bbcenterToRear_ != null) {
            output.WriteRawTag(34);
            output.WriteMessage(BbcenterToRear);
          }
          if (bbcenterToFront_ != null) {
            output.WriteRawTag(42);
            output.WriteMessage(BbcenterToFront);
          }
          if (GroundClearance != 0D) {
            output.WriteRawTag(49);
            output.WriteDouble(GroundClearance);
          }
          wheelData_.WriteTo(ref output, _repeated_wheelData_codec);
          if (SteeringWheelAngle != 0D) {
            output.WriteRawTag(65);
            output.WriteDouble(SteeringWheelAngle);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (driverId_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(DriverId);
          }
          if (RadiusWheel != 0D) {
            size += 1 + 8;
          }
          if (NumberWheels != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(NumberWheels);
          }
          if (bbcenterToRear_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(BbcenterToRear);
          }
          if (bbcenterToFront_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(BbcenterToFront);
          }
          if (GroundClearance != 0D) {
            size += 1 + 8;
          }
          size += wheelData_.CalculateSize(_repeated_wheelData_codec);
          if (SteeringWheelAngle != 0D) {
            size += 1 + 8;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(VehicleAttributes other) {
          if (other == null) {
            return;
          }
          if (other.driverId_ != null) {
            if (driverId_ == null) {
              DriverId = new global::Osi3.Identifier();
            }
            DriverId.MergeFrom(other.DriverId);
          }
          if (other.RadiusWheel != 0D) {
            RadiusWheel = other.RadiusWheel;
          }
          if (other.NumberWheels != 0) {
            NumberWheels = other.NumberWheels;
          }
          if (other.bbcenterToRear_ != null) {
            if (bbcenterToRear_ == null) {
              BbcenterToRear = new global::Osi3.Vector3d();
            }
            BbcenterToRear.MergeFrom(other.BbcenterToRear);
          }
          if (other.bbcenterToFront_ != null) {
            if (bbcenterToFront_ == null) {
              BbcenterToFront = new global::Osi3.Vector3d();
            }
            BbcenterToFront.MergeFrom(other.BbcenterToFront);
          }
          if (other.GroundClearance != 0D) {
            GroundClearance = other.GroundClearance;
          }
          wheelData_.Add(other.wheelData_);
          if (other.SteeringWheelAngle != 0D) {
            SteeringWheelAngle = other.SteeringWheelAngle;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (driverId_ == null) {
                  DriverId = new global::Osi3.Identifier();
                }
                input.ReadMessage(DriverId);
                break;
              }
              case 17: {
                RadiusWheel = input.ReadDouble();
                break;
              }
              case 24: {
                NumberWheels = input.ReadUInt32();
                break;
              }
              case 34: {
                if (bbcenterToRear_ == null) {
                  BbcenterToRear = new global::Osi3.Vector3d();
                }
                input.ReadMessage(BbcenterToRear);
                break;
              }
              case 42: {
                if (bbcenterToFront_ == null) {
                  BbcenterToFront = new global::Osi3.Vector3d();
                }
                input.ReadMessage(BbcenterToFront);
                break;
              }
              case 49: {
                GroundClearance = input.ReadDouble();
                break;
              }
              case 58: {
                wheelData_.AddEntriesFrom(input, _repeated_wheelData_codec);
                break;
              }
              case 65: {
                SteeringWheelAngle = input.ReadDouble();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                if (driverId_ == null) {
                  DriverId = new global::Osi3.Identifier();
                }
                input.ReadMessage(DriverId);
                break;
              }
              case 17: {
                RadiusWheel = input.ReadDouble();
                break;
              }
              case 24: {
                NumberWheels = input.ReadUInt32();
                break;
              }
              case 34: {
                if (bbcenterToRear_ == null) {
                  BbcenterToRear = new global::Osi3.Vector3d();
                }
                input.ReadMessage(BbcenterToRear);
                break;
              }
              case 42: {
                if (bbcenterToFront_ == null) {
                  BbcenterToFront = new global::Osi3.Vector3d();
                }
                input.ReadMessage(BbcenterToFront);
                break;
              }
              case 49: {
                GroundClearance = input.ReadDouble();
                break;
              }
              case 58: {
                wheelData_.AddEntriesFrom(ref input, _repeated_wheelData_codec);
                break;
              }
              case 65: {
                SteeringWheelAngle = input.ReadDouble();
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the VehicleAttributes message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          /// <summary>
          /// \brief Detailed wheel data.
          /// The focus is on the description of a wheel regarding the perceivable
          /// information from the outside.
          /// It is not intended to be used for dynamic calculations, for example.
          /// </summary>
          public sealed partial class WheelData : pb::IMessage<WheelData>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<WheelData> _parser = new pb::MessageParser<WheelData>(() => new WheelData());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<WheelData> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Osi3.MovingObject.Types.VehicleAttributes.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public WheelData() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public WheelData(WheelData other) : this() {
              axle_ = other.axle_;
              index_ = other.index_;
              position_ = other.position_ != null ? other.position_.Clone() : null;
              wheelRadius_ = other.wheelRadius_;
              rimRadius_ = other.rimRadius_;
              width_ = other.width_;
              orientation_ = other.orientation_ != null ? other.orientation_.Clone() : null;
              rotationRate_ = other.rotationRate_;
              modelReference_ = other.modelReference_;
              frictionCoefficient_ = other.frictionCoefficient_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public WheelData Clone() {
              return new WheelData(this);
            }

            /// <summary>Field number for the "axle" field.</summary>
            public const int AxleFieldNumber = 1;
            private uint axle_;
            /// <summary>
            /// The axle which contains this wheel. A value of 0 represents the
            /// front-most axle of the vehicle with higher numbers incrementing
            /// towards the rear-most axle.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public uint Axle {
              get { return axle_; }
              set {
                axle_ = value;
              }
            }

            /// <summary>Field number for the "index" field.</summary>
            public const int IndexFieldNumber = 2;
            private uint index_;
            /// <summary>
            /// The index of the wheel on the axle, counting in the direction
            /// of positive-y, that is, right-to-left.
            ///
            /// For example, on a standard 2-axle, 4-wheel car, the rear-right
            /// wheel would be (axle=1, index=0).
            /// This concept works also for twin tires.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public uint Index {
              get { return index_; }
              set {
                index_ = value;
              }
            }

            /// <summary>Field number for the "position" field.</summary>
            public const int PositionFieldNumber = 3;
            private global::Osi3.Vector3d position_;
            /// <summary>
            /// A vector pointing from the vehicle's reference system (center of bounding
            /// box) to the geometric center of the wheel.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public global::Osi3.Vector3d Position {
              get { return position_; }
              set {
                position_ = value;
              }
            }

            /// <summary>Field number for the "wheel_radius" field.</summary>
            public const int WheelRadiusFieldNumber = 4;
            private double wheelRadius_;
            /// <summary>
            /// Median radius of the wheel measured from the center of the wheel to
            /// the outer part of the tire.
            ///
            /// Unit: m
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public double WheelRadius {
              get { return wheelRadius_; }
              set {
                wheelRadius_ = value;
              }
            }

            /// <summary>Field number for the "rim_radius" field.</summary>
            public const int RimRadiusFieldNumber = 5;
            private double rimRadius_;
            /// <summary>
            /// Median radius of the rim measured from the center to the outer, visible part of the rim.
            ///
            /// Unit: m
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public double RimRadius {
              get { return rimRadius_; }
              set {
                rimRadius_ = value;
              }
            }

            /// <summary>Field number for the "width" field.</summary>
            public const int WidthFieldNumber = 6;
            private double width_;
            /// <summary>
            /// Median width of the tire.
            ///
            /// Unit: m
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public double Width {
              get { return width_; }
              set {
                width_ = value;
              }
            }

            /// <summary>Field number for the "orientation" field.</summary>
            public const int OrientationFieldNumber = 7;
            private global::Osi3.Orientation3d orientation_;
            /// <summary>
            /// Orientation of the wheel.
            ///
            /// The reference system is the vehicle frame (center of bounding box).
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public global::Osi3.Orientation3d Orientation {
              get { return orientation_; }
              set {
                orientation_ = value;
              }
            }

            /// <summary>Field number for the "rotation_rate" field.</summary>
            public const int RotationRateFieldNumber = 8;
            private double rotationRate_;
            /// <summary>
            /// Rotation rate of the wheel.
            /// The rotation rate around the y-axis with respect to the wheel's coordinate system.
            ///
            /// Unit: rad/s.
            ///
            /// The sign convention is defined using the right-hand rule.
            /// It is applied on the y-axis of the vehicle's reference system (center of bounding box).
            /// Counterclockwise is positive and clockwise is negative.
            ///
            /// \image html OSI_RotationRate.svg
            /// \note The vehicle's reference coordinate system is only used to determine the sign convention of the rotation rate.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public double RotationRate {
              get { return rotationRate_; }
              set {
                rotationRate_ = value;
              }
            }

            /// <summary>Field number for the "model_reference" field.</summary>
            public const int ModelReferenceFieldNumber = 9;
            private string modelReference_ = "";
            /// <summary>
            /// Opaque reference of an associated 3D model of the wheel.
            ///
            /// \note It is implementation-specific how model_references are resolved to
            /// 3d models.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public string ModelReference {
              get { return modelReference_; }
              set {
                modelReference_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            /// <summary>Field number for the "friction_coefficient" field.</summary>
            public const int FrictionCoefficientFieldNumber = 10;
            private double frictionCoefficient_;
            /// <summary>
            /// The value describes the kinetic friction of the tyre's contact point.
            /// If different friction coefficients due to more than one contact points are available,
            /// this value contains the average.
            ///
            /// Unit: Dimensionless
            ///
            /// \par References:
            /// [1] Britannica, T. Editors of Encyclopaedia. (2020, June 24). &lt;em>coefficient of friction&lt;/em>. Retrieved May 18, 2022, from https://www.britannica.com/science/coefficient-of-friction
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public double FrictionCoefficient {
              get { return frictionCoefficient_; }
              set {
                frictionCoefficient_ = value;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as WheelData);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(WheelData other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (Axle != other.Axle) return false;
              if (Index != other.Index) return false;
              if (!object.Equals(Position, other.Position)) return false;
              if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(WheelRadius, other.WheelRadius)) return false;
              if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(RimRadius, other.RimRadius)) return false;
              if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Width, other.Width)) return false;
              if (!object.Equals(Orientation, other.Orientation)) return false;
              if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(RotationRate, other.RotationRate)) return false;
              if (ModelReference != other.ModelReference) return false;
              if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(FrictionCoefficient, other.FrictionCoefficient)) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (Axle != 0) hash ^= Axle.GetHashCode();
              if (Index != 0) hash ^= Index.GetHashCode();
              if (position_ != null) hash ^= Position.GetHashCode();
              if (WheelRadius != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(WheelRadius);
              if (RimRadius != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(RimRadius);
              if (Width != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Width);
              if (orientation_ != null) hash ^= Orientation.GetHashCode();
              if (RotationRate != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(RotationRate);
              if (ModelReference.Length != 0) hash ^= ModelReference.GetHashCode();
              if (FrictionCoefficient != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(FrictionCoefficient);
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (Axle != 0) {
                output.WriteRawTag(8);
                output.WriteUInt32(Axle);
              }
              if (Index != 0) {
                output.WriteRawTag(16);
                output.WriteUInt32(Index);
              }
              if (position_ != null) {
                output.WriteRawTag(26);
                output.WriteMessage(Position);
              }
              if (WheelRadius != 0D) {
                output.WriteRawTag(33);
                output.WriteDouble(WheelRadius);
              }
              if (RimRadius != 0D) {
                output.WriteRawTag(41);
                output.WriteDouble(RimRadius);
              }
              if (Width != 0D) {
                output.WriteRawTag(49);
                output.WriteDouble(Width);
              }
              if (orientation_ != null) {
                output.WriteRawTag(58);
                output.WriteMessage(Orientation);
              }
              if (RotationRate != 0D) {
                output.WriteRawTag(65);
                output.WriteDouble(RotationRate);
              }
              if (ModelReference.Length != 0) {
                output.WriteRawTag(74);
                output.WriteString(ModelReference);
              }
              if (FrictionCoefficient != 0D) {
                output.WriteRawTag(81);
                output.WriteDouble(FrictionCoefficient);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (Axle != 0) {
                output.WriteRawTag(8);
                output.WriteUInt32(Axle);
              }
              if (Index != 0) {
                output.WriteRawTag(16);
                output.WriteUInt32(Index);
              }
              if (position_ != null) {
                output.WriteRawTag(26);
                output.WriteMessage(Position);
              }
              if (WheelRadius != 0D) {
                output.WriteRawTag(33);
                output.WriteDouble(WheelRadius);
              }
              if (RimRadius != 0D) {
                output.WriteRawTag(41);
                output.WriteDouble(RimRadius);
              }
              if (Width != 0D) {
                output.WriteRawTag(49);
                output.WriteDouble(Width);
              }
              if (orientation_ != null) {
                output.WriteRawTag(58);
                output.WriteMessage(Orientation);
              }
              if (RotationRate != 0D) {
                output.WriteRawTag(65);
                output.WriteDouble(RotationRate);
              }
              if (ModelReference.Length != 0) {
                output.WriteRawTag(74);
                output.WriteString(ModelReference);
              }
              if (FrictionCoefficient != 0D) {
                output.WriteRawTag(81);
                output.WriteDouble(FrictionCoefficient);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (Axle != 0) {
                size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Axle);
              }
              if (Index != 0) {
                size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Index);
              }
              if (position_ != null) {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Position);
              }
              if (WheelRadius != 0D) {
                size += 1 + 8;
              }
              if (RimRadius != 0D) {
                size += 1 + 8;
              }
              if (Width != 0D) {
                size += 1 + 8;
              }
              if (orientation_ != null) {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Orientation);
              }
              if (RotationRate != 0D) {
                size += 1 + 8;
              }
              if (ModelReference.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(ModelReference);
              }
              if (FrictionCoefficient != 0D) {
                size += 1 + 8;
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(WheelData other) {
              if (other == null) {
                return;
              }
              if (other.Axle != 0) {
                Axle = other.Axle;
              }
              if (other.Index != 0) {
                Index = other.Index;
              }
              if (other.position_ != null) {
                if (position_ == null) {
                  Position = new global::Osi3.Vector3d();
                }
                Position.MergeFrom(other.Position);
              }
              if (other.WheelRadius != 0D) {
                WheelRadius = other.WheelRadius;
              }
              if (other.RimRadius != 0D) {
                RimRadius = other.RimRadius;
              }
              if (other.Width != 0D) {
                Width = other.Width;
              }
              if (other.orientation_ != null) {
                if (orientation_ == null) {
                  Orientation = new global::Osi3.Orientation3d();
                }
                Orientation.MergeFrom(other.Orientation);
              }
              if (other.RotationRate != 0D) {
                RotationRate = other.RotationRate;
              }
              if (other.ModelReference.Length != 0) {
                ModelReference = other.ModelReference;
              }
              if (other.FrictionCoefficient != 0D) {
                FrictionCoefficient = other.FrictionCoefficient;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 8: {
                    Axle = input.ReadUInt32();
                    break;
                  }
                  case 16: {
                    Index = input.ReadUInt32();
                    break;
                  }
                  case 26: {
                    if (position_ == null) {
                      Position = new global::Osi3.Vector3d();
                    }
                    input.ReadMessage(Position);
                    break;
                  }
                  case 33: {
                    WheelRadius = input.ReadDouble();
                    break;
                  }
                  case 41: {
                    RimRadius = input.ReadDouble();
                    break;
                  }
                  case 49: {
                    Width = input.ReadDouble();
                    break;
                  }
                  case 58: {
                    if (orientation_ == null) {
                      Orientation = new global::Osi3.Orientation3d();
                    }
                    input.ReadMessage(Orientation);
                    break;
                  }
                  case 65: {
                    RotationRate = input.ReadDouble();
                    break;
                  }
                  case 74: {
                    ModelReference = input.ReadString();
                    break;
                  }
                  case 81: {
                    FrictionCoefficient = input.ReadDouble();
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 8: {
                    Axle = input.ReadUInt32();
                    break;
                  }
                  case 16: {
                    Index = input.ReadUInt32();
                    break;
                  }
                  case 26: {
                    if (position_ == null) {
                      Position = new global::Osi3.Vector3d();
                    }
                    input.ReadMessage(Position);
                    break;
                  }
                  case 33: {
                    WheelRadius = input.ReadDouble();
                    break;
                  }
                  case 41: {
                    RimRadius = input.ReadDouble();
                    break;
                  }
                  case 49: {
                    Width = input.ReadDouble();
                    break;
                  }
                  case 58: {
                    if (orientation_ == null) {
                      Orientation = new global::Osi3.Orientation3d();
                    }
                    input.ReadMessage(Orientation);
                    break;
                  }
                  case 65: {
                    RotationRate = input.ReadDouble();
                    break;
                  }
                  case 74: {
                    ModelReference = input.ReadString();
                    break;
                  }
                  case 81: {
                    FrictionCoefficient = input.ReadDouble();
                    break;
                  }
                }
              }
            }
            #endif

          }

        }
        #endregion

      }

      /// <summary>
      ///
      /// \brief Information for the classification of moving objects regarding
      /// \c MovingObject (host or other).
      /// </summary>
      public sealed partial class MovingObjectClassification : pb::IMessage<MovingObjectClassification>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<MovingObjectClassification> _parser = new pb::MessageParser<MovingObjectClassification>(() => new MovingObjectClassification());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<MovingObjectClassification> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Osi3.MovingObject.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public MovingObjectClassification() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public MovingObjectClassification(MovingObjectClassification other) : this() {
          assignedLaneId_ = other.assignedLaneId_.Clone();
          assignedLanePercentage_ = other.assignedLanePercentage_.Clone();
          logicalLaneAssignment_ = other.logicalLaneAssignment_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public MovingObjectClassification Clone() {
          return new MovingObjectClassification(this);
        }

        /// <summary>Field number for the "assigned_lane_id" field.</summary>
        public const int AssignedLaneIdFieldNumber = 1;
        private static readonly pb::FieldCodec<global::Osi3.Identifier> _repeated_assignedLaneId_codec
            = pb::FieldCodec.ForMessage(10, global::Osi3.Identifier.Parser);
        private readonly pbc::RepeatedField<global::Osi3.Identifier> assignedLaneId_ = new pbc::RepeatedField<global::Osi3.Identifier>();
        /// <summary>
        /// The IDs of the lanes that this object is assigned to.
        ///
        /// \note Might be multiple if the object is switching lanes or moving from
        /// one lane into another following lane.
        ///
        /// \note OSI uses singular instead of plural for repeated field names.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Osi3.Identifier> AssignedLaneId {
          get { return assignedLaneId_; }
        }

        /// <summary>Field number for the "assigned_lane_percentage" field.</summary>
        public const int AssignedLanePercentageFieldNumber = 2;
        private static readonly pb::FieldCodec<double> _repeated_assignedLanePercentage_codec
            = pb::FieldCodec.ForDouble(18);
        private readonly pbc::RepeatedField<double> assignedLanePercentage_ = new pbc::RepeatedField<double>();
        /// <summary>
        /// Percentage value of the object width in the corresponding lane.
        ///
        /// \note Might be multiple if the object is switching lanes or moving from
        /// one lane into another following lane.
        ///
        /// \note OSI uses singular instead of plural for repeated field names.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<double> AssignedLanePercentage {
          get { return assignedLanePercentage_; }
        }

        /// <summary>Field number for the "logical_lane_assignment" field.</summary>
        public const int LogicalLaneAssignmentFieldNumber = 3;
        private static readonly pb::FieldCodec<global::Osi3.LogicalLaneAssignment> _repeated_logicalLaneAssignment_codec
            = pb::FieldCodec.ForMessage(26, global::Osi3.LogicalLaneAssignment.Parser);
        private readonly pbc::RepeatedField<global::Osi3.LogicalLaneAssignment> logicalLaneAssignment_ = new pbc::RepeatedField<global::Osi3.LogicalLaneAssignment>();
        /// <summary>
        /// Assignment of this object to logical lanes.
        ///
        /// \note OSI uses singular instead of plural for repeated field names.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Osi3.LogicalLaneAssignment> LogicalLaneAssignment {
          get { return logicalLaneAssignment_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as MovingObjectClassification);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(MovingObjectClassification other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!assignedLaneId_.Equals(other.assignedLaneId_)) return false;
          if(!assignedLanePercentage_.Equals(other.assignedLanePercentage_)) return false;
          if(!logicalLaneAssignment_.Equals(other.logicalLaneAssignment_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= assignedLaneId_.GetHashCode();
          hash ^= assignedLanePercentage_.GetHashCode();
          hash ^= logicalLaneAssignment_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          assignedLaneId_.WriteTo(output, _repeated_assignedLaneId_codec);
          assignedLanePercentage_.WriteTo(output, _repeated_assignedLanePercentage_codec);
          logicalLaneAssignment_.WriteTo(output, _repeated_logicalLaneAssignment_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          assignedLaneId_.WriteTo(ref output, _repeated_assignedLaneId_codec);
          assignedLanePercentage_.WriteTo(ref output, _repeated_assignedLanePercentage_codec);
          logicalLaneAssignment_.WriteTo(ref output, _repeated_logicalLaneAssignment_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          size += assignedLaneId_.CalculateSize(_repeated_assignedLaneId_codec);
          size += assignedLanePercentage_.CalculateSize(_repeated_assignedLanePercentage_codec);
          size += logicalLaneAssignment_.CalculateSize(_repeated_logicalLaneAssignment_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(MovingObjectClassification other) {
          if (other == null) {
            return;
          }
          assignedLaneId_.Add(other.assignedLaneId_);
          assignedLanePercentage_.Add(other.assignedLanePercentage_);
          logicalLaneAssignment_.Add(other.logicalLaneAssignment_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                assignedLaneId_.AddEntriesFrom(input, _repeated_assignedLaneId_codec);
                break;
              }
              case 18:
              case 17: {
                assignedLanePercentage_.AddEntriesFrom(input, _repeated_assignedLanePercentage_codec);
                break;
              }
              case 26: {
                logicalLaneAssignment_.AddEntriesFrom(input, _repeated_logicalLaneAssignment_codec);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                assignedLaneId_.AddEntriesFrom(ref input, _repeated_assignedLaneId_codec);
                break;
              }
              case 18:
              case 17: {
                assignedLanePercentage_.AddEntriesFrom(ref input, _repeated_assignedLanePercentage_codec);
                break;
              }
              case 26: {
                logicalLaneAssignment_.AddEntriesFrom(ref input, _repeated_logicalLaneAssignment_codec);
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      ///
      /// \brief Information for the classification of vehicles regarding
      /// \c MovingObject (host or other).
      /// </summary>
      public sealed partial class VehicleClassification : pb::IMessage<VehicleClassification>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<VehicleClassification> _parser = new pb::MessageParser<VehicleClassification>(() => new VehicleClassification());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<VehicleClassification> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Osi3.MovingObject.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public VehicleClassification() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public VehicleClassification(VehicleClassification other) : this() {
          type_ = other.type_;
          lightState_ = other.lightState_ != null ? other.lightState_.Clone() : null;
          hasTrailer_ = other.hasTrailer_;
          trailerId_ = other.trailerId_ != null ? other.trailerId_.Clone() : null;
          role_ = other.role_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public VehicleClassification Clone() {
          return new VehicleClassification(this);
        }

        /// <summary>Field number for the "type" field.</summary>
        public const int TypeFieldNumber = 1;
        private global::Osi3.MovingObject.Types.VehicleClassification.Types.Type type_ = global::Osi3.MovingObject.Types.VehicleClassification.Types.Type.Unknown;
        /// <summary>
        /// The type of the vehicle.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Osi3.MovingObject.Types.VehicleClassification.Types.Type Type {
          get { return type_; }
          set {
            type_ = value;
          }
        }

        /// <summary>Field number for the "light_state" field.</summary>
        public const int LightStateFieldNumber = 2;
        private global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState lightState_;
        /// <summary>
        /// The light state of the vehicle.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState LightState {
          get { return lightState_; }
          set {
            lightState_ = value;
          }
        }

        /// <summary>Field number for the "has_trailer" field.</summary>
        public const int HasTrailerFieldNumber = 3;
        private bool hasTrailer_;
        /// <summary>
        /// Flag defining whether the vehicle has an attached trailer.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasTrailer {
          get { return hasTrailer_; }
          set {
            hasTrailer_ = value;
          }
        }

        /// <summary>Field number for the "trailer_id" field.</summary>
        public const int TrailerIdFieldNumber = 4;
        private global::Osi3.Identifier trailerId_;
        /// <summary>
        /// Id of the attached trailer.
        ///
        /// \note Field need not be set if has_Trailer is set to false or use
        /// value for non valid id.
        ///
        /// \rules
        /// check_if this.has_trailer is_equal_to true else do_check is_set
        /// \endrules
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Osi3.Identifier TrailerId {
          get { return trailerId_; }
          set {
            trailerId_ = value;
          }
        }

        /// <summary>Field number for the "role" field.</summary>
        public const int RoleFieldNumber = 5;
        private global::Osi3.MovingObject.Types.VehicleClassification.Types.Role role_ = global::Osi3.MovingObject.Types.VehicleClassification.Types.Role.Unknown;
        /// <summary>
        /// The role of the vehicle.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Osi3.MovingObject.Types.VehicleClassification.Types.Role Role {
          get { return role_; }
          set {
            role_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as VehicleClassification);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(VehicleClassification other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Type != other.Type) return false;
          if (!object.Equals(LightState, other.LightState)) return false;
          if (HasTrailer != other.HasTrailer) return false;
          if (!object.Equals(TrailerId, other.TrailerId)) return false;
          if (Role != other.Role) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Type != global::Osi3.MovingObject.Types.VehicleClassification.Types.Type.Unknown) hash ^= Type.GetHashCode();
          if (lightState_ != null) hash ^= LightState.GetHashCode();
          if (HasTrailer != false) hash ^= HasTrailer.GetHashCode();
          if (trailerId_ != null) hash ^= TrailerId.GetHashCode();
          if (Role != global::Osi3.MovingObject.Types.VehicleClassification.Types.Role.Unknown) hash ^= Role.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Type != global::Osi3.MovingObject.Types.VehicleClassification.Types.Type.Unknown) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Type);
          }
          if (lightState_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(LightState);
          }
          if (HasTrailer != false) {
            output.WriteRawTag(24);
            output.WriteBool(HasTrailer);
          }
          if (trailerId_ != null) {
            output.WriteRawTag(34);
            output.WriteMessage(TrailerId);
          }
          if (Role != global::Osi3.MovingObject.Types.VehicleClassification.Types.Role.Unknown) {
            output.WriteRawTag(40);
            output.WriteEnum((int) Role);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Type != global::Osi3.MovingObject.Types.VehicleClassification.Types.Type.Unknown) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Type);
          }
          if (lightState_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(LightState);
          }
          if (HasTrailer != false) {
            output.WriteRawTag(24);
            output.WriteBool(HasTrailer);
          }
          if (trailerId_ != null) {
            output.WriteRawTag(34);
            output.WriteMessage(TrailerId);
          }
          if (Role != global::Osi3.MovingObject.Types.VehicleClassification.Types.Role.Unknown) {
            output.WriteRawTag(40);
            output.WriteEnum((int) Role);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Type != global::Osi3.MovingObject.Types.VehicleClassification.Types.Type.Unknown) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
          }
          if (lightState_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(LightState);
          }
          if (HasTrailer != false) {
            size += 1 + 1;
          }
          if (trailerId_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(TrailerId);
          }
          if (Role != global::Osi3.MovingObject.Types.VehicleClassification.Types.Role.Unknown) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Role);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(VehicleClassification other) {
          if (other == null) {
            return;
          }
          if (other.Type != global::Osi3.MovingObject.Types.VehicleClassification.Types.Type.Unknown) {
            Type = other.Type;
          }
          if (other.lightState_ != null) {
            if (lightState_ == null) {
              LightState = new global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState();
            }
            LightState.MergeFrom(other.LightState);
          }
          if (other.HasTrailer != false) {
            HasTrailer = other.HasTrailer;
          }
          if (other.trailerId_ != null) {
            if (trailerId_ == null) {
              TrailerId = new global::Osi3.Identifier();
            }
            TrailerId.MergeFrom(other.TrailerId);
          }
          if (other.Role != global::Osi3.MovingObject.Types.VehicleClassification.Types.Role.Unknown) {
            Role = other.Role;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Type = (global::Osi3.MovingObject.Types.VehicleClassification.Types.Type) input.ReadEnum();
                break;
              }
              case 18: {
                if (lightState_ == null) {
                  LightState = new global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState();
                }
                input.ReadMessage(LightState);
                break;
              }
              case 24: {
                HasTrailer = input.ReadBool();
                break;
              }
              case 34: {
                if (trailerId_ == null) {
                  TrailerId = new global::Osi3.Identifier();
                }
                input.ReadMessage(TrailerId);
                break;
              }
              case 40: {
                Role = (global::Osi3.MovingObject.Types.VehicleClassification.Types.Role) input.ReadEnum();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                Type = (global::Osi3.MovingObject.Types.VehicleClassification.Types.Type) input.ReadEnum();
                break;
              }
              case 18: {
                if (lightState_ == null) {
                  LightState = new global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState();
                }
                input.ReadMessage(LightState);
                break;
              }
              case 24: {
                HasTrailer = input.ReadBool();
                break;
              }
              case 34: {
                if (trailerId_ == null) {
                  TrailerId = new global::Osi3.Identifier();
                }
                input.ReadMessage(TrailerId);
                break;
              }
              case 40: {
                Role = (global::Osi3.MovingObject.Types.VehicleClassification.Types.Role) input.ReadEnum();
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the VehicleClassification message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          /// <summary>
          /// Definition of vehicle types.
          ///
          /// \note OSI provides a richer set of vehicle types than is supported by some
          /// other OpenX standards (in particular, OpenScenario 1.x and 2.x, and OpenLabel).
          /// This is primarily for historical reasons.  Where a single type from a
          /// different standard can map to multiple OSI types it is left up to the
          /// discretion of the OSI implementor how that mapping is achieved.  For example,
          /// a simulator may use the dimensions of a provided 3d model of a vehicle with type
          /// "car" in OpenScenario, to determine whether it should be a TYPE_SMALL_CAR or
          /// TYPE_MEDIUM_CAR in OSI.
          ///
          /// \note Vehicle type classification is a complex area and there are no
          /// universally recognised standards.  As such, the boundaries between some of the
          /// OSI vehicle types are not well-defined.  It is left to the implementor to
          /// decide how to distinguish between them and agree that with any applications which
          /// make use of that specific interface instance.  For example, how to distinguish
          /// between a HEAVY_TRUCK and a DELIVERY_VAN, or a TRAILER and a SEMITRAILER.
          /// </summary>
          public enum Type {
            /// <summary>
            /// Type of vehicle is unknown (must not be used in ground truth).
            /// </summary>
            [pbr::OriginalName("TYPE_UNKNOWN")] Unknown = 0,
            /// <summary>
            /// Other (unspecified but known) type of vehicle.
            /// </summary>
            [pbr::OriginalName("TYPE_OTHER")] Other = 1,
            /// <summary>
            /// Vehicle is a small car.
            ///
            /// Definition: Hatchback car with maximum length 4 m.
            /// </summary>
            [pbr::OriginalName("TYPE_SMALL_CAR")] SmallCar = 2,
            /// <summary>
            /// Vehicle is a compact car.
            ///
            /// Definition: Hatchback car with length between 4 and 4.5 m.
            /// </summary>
            [pbr::OriginalName("TYPE_COMPACT_CAR")] CompactCar = 3,
            /// <summary>
            /// Vehicle is a medium car.
            ///
            /// Definition: Hatchback or sedan with lenght between 4.5 and 5 m.
            /// </summary>
            [pbr::OriginalName("TYPE_MEDIUM_CAR")] MediumCar = 4,
            /// <summary>
            /// Vehicle is a luxury  car.
            ///
            /// Definition: Sedan or coupe that is longer then 5 m.
            /// </summary>
            [pbr::OriginalName("TYPE_LUXURY_CAR")] LuxuryCar = 5,
            /// <summary>
            /// Vehicle is a delivery van.
            ///
            /// \image html OSI_TYPE_DELIVERY_VAN.svg
            /// </summary>
            [pbr::OriginalName("TYPE_DELIVERY_VAN")] DeliveryVan = 6,
            /// <summary>
            /// Vehicle is a (heavy) truck.
            ///
            /// \image html OSI_TYPE_HEAVY_TRUCK.svg
            /// </summary>
            [pbr::OriginalName("TYPE_HEAVY_TRUCK")] HeavyTruck = 7,
            /// <summary>
            /// Vehicle is a tractor capable of pulling a semi-trailer.
            ///
            /// \image html OSI_TYPE_SEMITRACTOR.svg
            /// </summary>
            [pbr::OriginalName("TYPE_SEMITRACTOR")] Semitractor = 16,
            /// <summary>
            /// This vehicle is a semi-trailer that can be pulled by a
            /// semi-tractor.
            ///
            /// \note The vehicle can be, but doesn't need to be,
            /// attached to another vehicle.
            ///
            /// \image html OSI_TYPE_SEMITRAILER.svg
            /// </summary>
            [pbr::OriginalName("TYPE_SEMITRAILER")] Semitrailer = 8,
            /// <summary>
            /// Vehicle is a trailer.
            ///
            /// \note The vehicle can be, but doesn't need to be,
            /// attached to another vehicle.
            ///
            /// \image html OSI_TYPE_TRAILER.svg
            /// </summary>
            [pbr::OriginalName("TYPE_TRAILER")] Trailer = 9,
            /// <summary>
            /// Vehicle is a motorbike or moped.
            /// </summary>
            [pbr::OriginalName("TYPE_MOTORBIKE")] Motorbike = 10,
            /// <summary>
            /// Vehicle is a bicycle (without motor and specific lights).
            /// </summary>
            [pbr::OriginalName("TYPE_BICYCLE")] Bicycle = 11,
            /// <summary>
            /// Vehicle is a bus.
            /// </summary>
            [pbr::OriginalName("TYPE_BUS")] Bus = 12,
            /// <summary>
            /// Vehicle is a tram.
            /// </summary>
            [pbr::OriginalName("TYPE_TRAM")] Tram = 13,
            /// <summary>
            /// Vehicle is a train.
            /// </summary>
            [pbr::OriginalName("TYPE_TRAIN")] Train = 14,
            /// <summary>
            /// Vehicle is a wheelchair.
            /// </summary>
            [pbr::OriginalName("TYPE_WHEELCHAIR")] Wheelchair = 15,
          }

          /// <summary>
          /// Definition of vehicle roles. 
          ///
          /// The role specifies the perceived role of a vehicle. Therefore, a 
          /// civil police car is set to ROLE_CIVIL as long as it cannot be 
          /// perceived as a ROLE_POLICE. 
          /// The normal use case will consist of 99% ROLE_CIVIL, as this role is 
          /// used for normal vehicles.
          /// These roles may influence the behavior in traffic of the surrounding vehicles.
          /// To check whether a role is "active" (e.g. blue flashing light of an 
          /// ambulance or an amber flashing light of a sweeper) can be looked up 
          /// in message LightState.
          /// 
          /// </summary>
          public enum Role {
            /// <summary>
            /// Role of vehicle is unknown (must not be used in ground truth).
            /// </summary>
            [pbr::OriginalName("ROLE_UNKNOWN")] Unknown = 0,
            /// <summary>
            /// Other (unspecified but known) role of vehicle.
            /// </summary>
            [pbr::OriginalName("ROLE_OTHER")] Other = 1,
            /// <summary>
            /// The vehicle role is civil, e.g. a "normal" car.
            /// </summary>
            [pbr::OriginalName("ROLE_CIVIL")] Civil = 2,
            /// <summary>
            /// The vehicle role is ambulance.
            /// </summary>
            [pbr::OriginalName("ROLE_AMBULANCE")] Ambulance = 3,
            /// <summary>
            /// The vehicle role is fire fighting, e.g. fire engine.
            /// </summary>
            [pbr::OriginalName("ROLE_FIRE")] Fire = 4,
            /// <summary>
            /// The vehicle role is police.
            /// </summary>
            [pbr::OriginalName("ROLE_POLICE")] Police = 5,
            /// <summary>
            /// The vehicle role is public transport, e.g. a school bus.
            /// </summary>
            [pbr::OriginalName("ROLE_PUBLIC_TRANSPORT")] PublicTransport = 6,
            /// <summary>
            /// The vehicle role is roadside assistance, e.g. tow truck.
            /// </summary>
            [pbr::OriginalName("ROLE_ROAD_ASSISTANCE")] RoadAssistance = 7,
            /// <summary>
            /// The vehicle role is garbage collection, e.g. a garbage truck or sweeper.
            /// </summary>
            [pbr::OriginalName("ROLE_GARBAGE_COLLECTION")] GarbageCollection = 8,
            /// <summary>
            /// The vehicle role is road construction, e.g. a excavator or tipper truck.
            /// </summary>
            [pbr::OriginalName("ROLE_ROAD_CONSTRUCTION")] RoadConstruction = 9,
            /// <summary>
            /// The vehicle role is military, e.g. camouflaged truck.
            /// </summary>
            [pbr::OriginalName("ROLE_MILITARY")] Military = 10,
          }

          /// <summary>
          ///
          /// \brief The state of the lights of a vehicle.
          /// </summary>
          public sealed partial class LightState : pb::IMessage<LightState>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<LightState> _parser = new pb::MessageParser<LightState>(() => new LightState());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<LightState> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Osi3.MovingObject.Types.VehicleClassification.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public LightState() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public LightState(LightState other) : this() {
              indicatorState_ = other.indicatorState_;
              frontFogLight_ = other.frontFogLight_;
              rearFogLight_ = other.rearFogLight_;
              headLight_ = other.headLight_;
              highBeam_ = other.highBeam_;
              reversingLight_ = other.reversingLight_;
              brakeLightState_ = other.brakeLightState_;
              licensePlateIlluminationRear_ = other.licensePlateIlluminationRear_;
              emergencyVehicleIllumination_ = other.emergencyVehicleIllumination_;
              serviceVehicleIllumination_ = other.serviceVehicleIllumination_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public LightState Clone() {
              return new LightState(this);
            }

            /// <summary>Field number for the "indicator_state" field.</summary>
            public const int IndicatorStateFieldNumber = 1;
            private global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.IndicatorState indicatorState_ = global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.IndicatorState.Unknown;
            /// <summary>
            /// State of the object's indicators.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.IndicatorState IndicatorState {
              get { return indicatorState_; }
              set {
                indicatorState_ = value;
              }
            }

            /// <summary>Field number for the "front_fog_light" field.</summary>
            public const int FrontFogLightFieldNumber = 2;
            private global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState frontFogLight_ = global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown;
            /// <summary>
            /// State of the front fog light.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState FrontFogLight {
              get { return frontFogLight_; }
              set {
                frontFogLight_ = value;
              }
            }

            /// <summary>Field number for the "rear_fog_light" field.</summary>
            public const int RearFogLightFieldNumber = 3;
            private global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState rearFogLight_ = global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown;
            /// <summary>
            /// State of the rear fog light.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState RearFogLight {
              get { return rearFogLight_; }
              set {
                rearFogLight_ = value;
              }
            }

            /// <summary>Field number for the "head_light" field.</summary>
            public const int HeadLightFieldNumber = 4;
            private global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState headLight_ = global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown;
            /// <summary>
            /// State of the head lights.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState HeadLight {
              get { return headLight_; }
              set {
                headLight_ = value;
              }
            }

            /// <summary>Field number for the "high_beam" field.</summary>
            public const int HighBeamFieldNumber = 5;
            private global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState highBeam_ = global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown;
            /// <summary>
            /// State of the high beam.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState HighBeam {
              get { return highBeam_; }
              set {
                highBeam_ = value;
              }
            }

            /// <summary>Field number for the "reversing_light" field.</summary>
            public const int ReversingLightFieldNumber = 6;
            private global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState reversingLight_ = global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown;
            /// <summary>
            /// State of the reversing light.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState ReversingLight {
              get { return reversingLight_; }
              set {
                reversingLight_ = value;
              }
            }

            /// <summary>Field number for the "brake_light_state" field.</summary>
            public const int BrakeLightStateFieldNumber = 7;
            private global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.BrakeLightState brakeLightState_ = global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.BrakeLightState.Unknown;
            /// <summary>
            /// State of the brake lights.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.BrakeLightState BrakeLightState {
              get { return brakeLightState_; }
              set {
                brakeLightState_ = value;
              }
            }

            /// <summary>Field number for the "license_plate_illumination_rear" field.</summary>
            public const int LicensePlateIlluminationRearFieldNumber = 8;
            private global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState licensePlateIlluminationRear_ = global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown;
            /// <summary>
            /// State of the (rear) license plate illumination.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState LicensePlateIlluminationRear {
              get { return licensePlateIlluminationRear_; }
              set {
                licensePlateIlluminationRear_ = value;
              }
            }

            /// <summary>Field number for the "emergency_vehicle_illumination" field.</summary>
            public const int EmergencyVehicleIlluminationFieldNumber = 9;
            private global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState emergencyVehicleIllumination_ = global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown;
            /// <summary>
            /// Lighting of emergency vehicles (ambulance, fire engine, police
            /// car, etc.). Must be set only if a vehicle is allowed to use this
            /// illumination type.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState EmergencyVehicleIllumination {
              get { return emergencyVehicleIllumination_; }
              set {
                emergencyVehicleIllumination_ = value;
              }
            }

            /// <summary>Field number for the "service_vehicle_illumination" field.</summary>
            public const int ServiceVehicleIlluminationFieldNumber = 10;
            private global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState serviceVehicleIllumination_ = global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown;
            /// <summary>
            /// Lighting of service vehicles (snow removal, garbage truck, towing
            /// vehicle, slow or wide vehicle, etc.). Must be set only if a
            /// vehicle is allowed to use this illumination type.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState ServiceVehicleIllumination {
              get { return serviceVehicleIllumination_; }
              set {
                serviceVehicleIllumination_ = value;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as LightState);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(LightState other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (IndicatorState != other.IndicatorState) return false;
              if (FrontFogLight != other.FrontFogLight) return false;
              if (RearFogLight != other.RearFogLight) return false;
              if (HeadLight != other.HeadLight) return false;
              if (HighBeam != other.HighBeam) return false;
              if (ReversingLight != other.ReversingLight) return false;
              if (BrakeLightState != other.BrakeLightState) return false;
              if (LicensePlateIlluminationRear != other.LicensePlateIlluminationRear) return false;
              if (EmergencyVehicleIllumination != other.EmergencyVehicleIllumination) return false;
              if (ServiceVehicleIllumination != other.ServiceVehicleIllumination) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (IndicatorState != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.IndicatorState.Unknown) hash ^= IndicatorState.GetHashCode();
              if (FrontFogLight != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown) hash ^= FrontFogLight.GetHashCode();
              if (RearFogLight != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown) hash ^= RearFogLight.GetHashCode();
              if (HeadLight != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown) hash ^= HeadLight.GetHashCode();
              if (HighBeam != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown) hash ^= HighBeam.GetHashCode();
              if (ReversingLight != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown) hash ^= ReversingLight.GetHashCode();
              if (BrakeLightState != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.BrakeLightState.Unknown) hash ^= BrakeLightState.GetHashCode();
              if (LicensePlateIlluminationRear != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown) hash ^= LicensePlateIlluminationRear.GetHashCode();
              if (EmergencyVehicleIllumination != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown) hash ^= EmergencyVehicleIllumination.GetHashCode();
              if (ServiceVehicleIllumination != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown) hash ^= ServiceVehicleIllumination.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (IndicatorState != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.IndicatorState.Unknown) {
                output.WriteRawTag(8);
                output.WriteEnum((int) IndicatorState);
              }
              if (FrontFogLight != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown) {
                output.WriteRawTag(16);
                output.WriteEnum((int) FrontFogLight);
              }
              if (RearFogLight != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown) {
                output.WriteRawTag(24);
                output.WriteEnum((int) RearFogLight);
              }
              if (HeadLight != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown) {
                output.WriteRawTag(32);
                output.WriteEnum((int) HeadLight);
              }
              if (HighBeam != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown) {
                output.WriteRawTag(40);
                output.WriteEnum((int) HighBeam);
              }
              if (ReversingLight != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown) {
                output.WriteRawTag(48);
                output.WriteEnum((int) ReversingLight);
              }
              if (BrakeLightState != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.BrakeLightState.Unknown) {
                output.WriteRawTag(56);
                output.WriteEnum((int) BrakeLightState);
              }
              if (LicensePlateIlluminationRear != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown) {
                output.WriteRawTag(64);
                output.WriteEnum((int) LicensePlateIlluminationRear);
              }
              if (EmergencyVehicleIllumination != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown) {
                output.WriteRawTag(72);
                output.WriteEnum((int) EmergencyVehicleIllumination);
              }
              if (ServiceVehicleIllumination != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown) {
                output.WriteRawTag(80);
                output.WriteEnum((int) ServiceVehicleIllumination);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (IndicatorState != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.IndicatorState.Unknown) {
                output.WriteRawTag(8);
                output.WriteEnum((int) IndicatorState);
              }
              if (FrontFogLight != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown) {
                output.WriteRawTag(16);
                output.WriteEnum((int) FrontFogLight);
              }
              if (RearFogLight != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown) {
                output.WriteRawTag(24);
                output.WriteEnum((int) RearFogLight);
              }
              if (HeadLight != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown) {
                output.WriteRawTag(32);
                output.WriteEnum((int) HeadLight);
              }
              if (HighBeam != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown) {
                output.WriteRawTag(40);
                output.WriteEnum((int) HighBeam);
              }
              if (ReversingLight != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown) {
                output.WriteRawTag(48);
                output.WriteEnum((int) ReversingLight);
              }
              if (BrakeLightState != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.BrakeLightState.Unknown) {
                output.WriteRawTag(56);
                output.WriteEnum((int) BrakeLightState);
              }
              if (LicensePlateIlluminationRear != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown) {
                output.WriteRawTag(64);
                output.WriteEnum((int) LicensePlateIlluminationRear);
              }
              if (EmergencyVehicleIllumination != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown) {
                output.WriteRawTag(72);
                output.WriteEnum((int) EmergencyVehicleIllumination);
              }
              if (ServiceVehicleIllumination != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown) {
                output.WriteRawTag(80);
                output.WriteEnum((int) ServiceVehicleIllumination);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (IndicatorState != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.IndicatorState.Unknown) {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) IndicatorState);
              }
              if (FrontFogLight != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown) {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) FrontFogLight);
              }
              if (RearFogLight != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown) {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) RearFogLight);
              }
              if (HeadLight != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown) {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) HeadLight);
              }
              if (HighBeam != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown) {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) HighBeam);
              }
              if (ReversingLight != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown) {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ReversingLight);
              }
              if (BrakeLightState != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.BrakeLightState.Unknown) {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) BrakeLightState);
              }
              if (LicensePlateIlluminationRear != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown) {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) LicensePlateIlluminationRear);
              }
              if (EmergencyVehicleIllumination != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown) {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) EmergencyVehicleIllumination);
              }
              if (ServiceVehicleIllumination != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown) {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ServiceVehicleIllumination);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(LightState other) {
              if (other == null) {
                return;
              }
              if (other.IndicatorState != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.IndicatorState.Unknown) {
                IndicatorState = other.IndicatorState;
              }
              if (other.FrontFogLight != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown) {
                FrontFogLight = other.FrontFogLight;
              }
              if (other.RearFogLight != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown) {
                RearFogLight = other.RearFogLight;
              }
              if (other.HeadLight != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown) {
                HeadLight = other.HeadLight;
              }
              if (other.HighBeam != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown) {
                HighBeam = other.HighBeam;
              }
              if (other.ReversingLight != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown) {
                ReversingLight = other.ReversingLight;
              }
              if (other.BrakeLightState != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.BrakeLightState.Unknown) {
                BrakeLightState = other.BrakeLightState;
              }
              if (other.LicensePlateIlluminationRear != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown) {
                LicensePlateIlluminationRear = other.LicensePlateIlluminationRear;
              }
              if (other.EmergencyVehicleIllumination != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown) {
                EmergencyVehicleIllumination = other.EmergencyVehicleIllumination;
              }
              if (other.ServiceVehicleIllumination != global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState.Unknown) {
                ServiceVehicleIllumination = other.ServiceVehicleIllumination;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 8: {
                    IndicatorState = (global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.IndicatorState) input.ReadEnum();
                    break;
                  }
                  case 16: {
                    FrontFogLight = (global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState) input.ReadEnum();
                    break;
                  }
                  case 24: {
                    RearFogLight = (global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState) input.ReadEnum();
                    break;
                  }
                  case 32: {
                    HeadLight = (global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState) input.ReadEnum();
                    break;
                  }
                  case 40: {
                    HighBeam = (global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState) input.ReadEnum();
                    break;
                  }
                  case 48: {
                    ReversingLight = (global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState) input.ReadEnum();
                    break;
                  }
                  case 56: {
                    BrakeLightState = (global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.BrakeLightState) input.ReadEnum();
                    break;
                  }
                  case 64: {
                    LicensePlateIlluminationRear = (global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState) input.ReadEnum();
                    break;
                  }
                  case 72: {
                    EmergencyVehicleIllumination = (global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState) input.ReadEnum();
                    break;
                  }
                  case 80: {
                    ServiceVehicleIllumination = (global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState) input.ReadEnum();
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 8: {
                    IndicatorState = (global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.IndicatorState) input.ReadEnum();
                    break;
                  }
                  case 16: {
                    FrontFogLight = (global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState) input.ReadEnum();
                    break;
                  }
                  case 24: {
                    RearFogLight = (global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState) input.ReadEnum();
                    break;
                  }
                  case 32: {
                    HeadLight = (global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState) input.ReadEnum();
                    break;
                  }
                  case 40: {
                    HighBeam = (global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState) input.ReadEnum();
                    break;
                  }
                  case 48: {
                    ReversingLight = (global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState) input.ReadEnum();
                    break;
                  }
                  case 56: {
                    BrakeLightState = (global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.BrakeLightState) input.ReadEnum();
                    break;
                  }
                  case 64: {
                    LicensePlateIlluminationRear = (global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState) input.ReadEnum();
                    break;
                  }
                  case 72: {
                    EmergencyVehicleIllumination = (global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState) input.ReadEnum();
                    break;
                  }
                  case 80: {
                    ServiceVehicleIllumination = (global::Osi3.MovingObject.Types.VehicleClassification.Types.LightState.Types.GenericLightState) input.ReadEnum();
                    break;
                  }
                }
              }
            }
            #endif

            #region Nested types
            /// <summary>Container for nested types declared in the LightState message type.</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static partial class Types {
              /// <summary>
              /// Definition of indicator states.
              /// </summary>
              public enum IndicatorState {
                /// <summary>
                /// Indicator state is unknown (must not be used in ground
                /// truth).
                /// </summary>
                [pbr::OriginalName("INDICATOR_STATE_UNKNOWN")] Unknown = 0,
                /// <summary>
                /// Other (unspecified but known) state of indicator.
                /// </summary>
                [pbr::OriginalName("INDICATOR_STATE_OTHER")] Other = 1,
                /// <summary>
                /// Indicators are off.
                /// </summary>
                [pbr::OriginalName("INDICATOR_STATE_OFF")] Off = 2,
                /// <summary>
                /// Left indicator is on.
                /// </summary>
                [pbr::OriginalName("INDICATOR_STATE_LEFT")] Left = 3,
                /// <summary>
                /// Right indicator is on.
                /// </summary>
                [pbr::OriginalName("INDICATOR_STATE_RIGHT")] Right = 4,
                /// <summary>
                /// Hazard/warning light, i.e. both indicators, are on.
                /// </summary>
                [pbr::OriginalName("INDICATOR_STATE_WARNING")] Warning = 5,
              }

              /// <summary>
              /// Definition of generic light states for light that may be on or
              /// off.
              /// </summary>
              public enum GenericLightState {
                /// <summary>
                /// Light state is unknown (must not be used in ground truth).
                /// </summary>
                [pbr::OriginalName("GENERIC_LIGHT_STATE_UNKNOWN")] Unknown = 0,
                /// <summary>
                /// Other (unspecified but known) state of light.
                /// </summary>
                [pbr::OriginalName("GENERIC_LIGHT_STATE_OTHER")] Other = 1,
                /// <summary>
                /// Light is off.
                /// </summary>
                [pbr::OriginalName("GENERIC_LIGHT_STATE_OFF")] Off = 2,
                /// <summary>
                /// Light is on.
                /// </summary>
                [pbr::OriginalName("GENERIC_LIGHT_STATE_ON")] On = 3,
                /// <summary>
                /// Light is flashing blue.
                /// To be used for emergency vehicles.
                /// </summary>
                [pbr::OriginalName("GENERIC_LIGHT_STATE_FLASHING_BLUE")] FlashingBlue = 4,
                /// <summary>
                /// Light is flashing blue and red.
                /// To be used for emergency vehicles.
                /// </summary>
                [pbr::OriginalName("GENERIC_LIGHT_STATE_FLASHING_BLUE_AND_RED")] FlashingBlueAndRed = 5,
                /// <summary>
                /// Light is flashing amber.
                /// To be used for service vehicles.
                /// </summary>
                [pbr::OriginalName("GENERIC_LIGHT_STATE_FLASHING_AMBER")] FlashingAmber = 6,
              }

              /// <summary>
              /// Definition of brake light states.
              /// </summary>
              public enum BrakeLightState {
                /// <summary>
                /// Brake light state is unknown (must not be used in ground
                /// truth).
                /// </summary>
                [pbr::OriginalName("BRAKE_LIGHT_STATE_UNKNOWN")] Unknown = 0,
                /// <summary>
                /// Other (unspecified but known) state of brake light.
                /// </summary>
                [pbr::OriginalName("BRAKE_LIGHT_STATE_OTHER")] Other = 1,
                /// <summary>
                /// Brake lights are off.
                /// </summary>
                [pbr::OriginalName("BRAKE_LIGHT_STATE_OFF")] Off = 2,
                /// <summary>
                /// Brake lights are on with normal intensity.
                /// </summary>
                [pbr::OriginalName("BRAKE_LIGHT_STATE_NORMAL")] Normal = 3,
                /// <summary>
                /// Brake lights are on with extra bright intensity (indicating
                /// stronger braking).
                /// </summary>
                [pbr::OriginalName("BRAKE_LIGHT_STATE_STRONG")] Strong = 4,
              }

            }
            #endregion

          }

        }
        #endregion

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
