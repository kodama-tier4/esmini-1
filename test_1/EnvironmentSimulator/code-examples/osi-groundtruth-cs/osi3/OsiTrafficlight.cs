// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: osi_trafficlight.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Osi3 {

  /// <summary>Holder for reflection information generated from osi_trafficlight.proto</summary>
  public static partial class OsiTrafficlightReflection {

    #region Descriptor
    /// <summary>File descriptor for osi_trafficlight.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static OsiTrafficlightReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChZvc2lfdHJhZmZpY2xpZ2h0LnByb3RvEgRvc2kzGhBvc2lfY29tbW9uLnBy",
            "b3RvIpwLCgxUcmFmZmljTGlnaHQSHAoCaWQYASABKAsyEC5vc2kzLklkZW50",
            "aWZpZXISIgoEYmFzZRgCIAEoCzIULm9zaTMuQmFzZVN0YXRpb25hcnkSOQoO",
            "Y2xhc3NpZmljYXRpb24YAyABKAsyIS5vc2kzLlRyYWZmaWNMaWdodC5DbGFz",
            "c2lmaWNhdGlvbhIXCg9tb2RlbF9yZWZlcmVuY2UYBCABKAkSMQoQc291cmNl",
            "X3JlZmVyZW5jZRgFIAMoCzIXLm9zaTMuRXh0ZXJuYWxSZWZlcmVuY2USMQoR",
            "Y29sb3JfZGVzY3JpcHRpb24YBiABKAsyFi5vc2kzLkNvbG9yRGVzY3JpcHRp",
            "b24ajwkKDkNsYXNzaWZpY2F0aW9uEjYKBWNvbG9yGAEgASgOMicub3NpMy5U",
            "cmFmZmljTGlnaHQuQ2xhc3NpZmljYXRpb24uQ29sb3ISNAoEaWNvbhgCIAEo",
            "DjImLm9zaTMuVHJhZmZpY0xpZ2h0LkNsYXNzaWZpY2F0aW9uLkljb24SNAoE",
            "bW9kZRgDIAEoDjImLm9zaTMuVHJhZmZpY0xpZ2h0LkNsYXNzaWZpY2F0aW9u",
            "Lk1vZGUSDwoHY291bnRlchgEIAEoARIqChBhc3NpZ25lZF9sYW5lX2lkGAUg",
            "AygLMhAub3NpMy5JZGVudGlmaWVyEhkKEWlzX291dF9vZl9zZXJ2aWNlGAYg",
            "ASgIEjwKF2xvZ2ljYWxfbGFuZV9hc3NpZ25tZW50GAcgAygLMhsub3NpMy5M",
            "b2dpY2FsTGFuZUFzc2lnbm1lbnQifgoFQ29sb3ISEQoNQ09MT1JfVU5LTk9X",
            "ThAAEg8KC0NPTE9SX09USEVSEAESDQoJQ09MT1JfUkVEEAISEAoMQ09MT1Jf",
            "WUVMTE9XEAMSDwoLQ09MT1JfR1JFRU4QBBIOCgpDT0xPUl9CTFVFEAUSDwoL",
            "Q09MT1JfV0hJVEUQBiLRBAoESWNvbhIQCgxJQ09OX1VOS05PV04QABIOCgpJ",
            "Q09OX09USEVSEAESDQoJSUNPTl9OT05FEAISHQoZSUNPTl9BUlJPV19TVFJB",
            "SUdIVF9BSEVBRBADEhMKD0lDT05fQVJST1dfTEVGVBAEEhgKFElDT05fQVJS",
            "T1dfRElBR19MRUZUEAUSIgoeSUNPTl9BUlJPV19TVFJBSUdIVF9BSEVBRF9M",
            "RUZUEAYSFAoQSUNPTl9BUlJPV19SSUdIVBAHEhkKFUlDT05fQVJST1dfRElB",
            "R19SSUdIVBAIEiMKH0lDT05fQVJST1dfU1RSQUlHSFRfQUhFQURfUklHSFQQ",
            "CRIZChVJQ09OX0FSUk9XX0xFRlRfUklHSFQQChITCg9JQ09OX0FSUk9XX0RP",
            "V04QCxIYChRJQ09OX0FSUk9XX0RPV05fTEVGVBAMEhkKFUlDT05fQVJST1df",
            "RE9XTl9SSUdIVBANEhQKEElDT05fQVJST1dfQ1JPU1MQDhITCg9JQ09OX1BF",
            "REVTVFJJQU4QDxINCglJQ09OX1dBTEsQEBISCg5JQ09OX0RPTlRfV0FMSxAR",
            "EhAKDElDT05fQklDWUNMRRASEh8KG0lDT05fUEVERVNUUklBTl9BTkRfQklD",
            "WUNMRRATEhoKFklDT05fQ09VTlRET1dOX1NFQ09ORFMQFBIaChZJQ09OX0NP",
            "VU5URE9XTl9QRVJDRU5UEBUSDQoJSUNPTl9UUkFNEBYSDAoISUNPTl9CVVMQ",
            "FxIVChFJQ09OX0JVU19BTkRfVFJBTRAYIm8KBE1vZGUSEAoMTU9ERV9VTktO",
            "T1dOEAASDgoKTU9ERV9PVEhFUhABEgwKCE1PREVfT0ZGEAISEQoNTU9ERV9D",
            "T05TVEFOVBADEhEKDU1PREVfRkxBU0hJTkcQBBIRCg1NT0RFX0NPVU5USU5H",
            "EAVCAkgBYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Osi3.OsiCommonReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Osi3.TrafficLight), global::Osi3.TrafficLight.Parser, new[]{ "Id", "Base", "Classification", "ModelReference", "SourceReference", "ColorDescription" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Osi3.TrafficLight.Types.Classification), global::Osi3.TrafficLight.Types.Classification.Parser, new[]{ "Color", "Icon", "Mode", "Counter", "AssignedLaneId", "IsOutOfService", "LogicalLaneAssignment" }, null, new[]{ typeof(global::Osi3.TrafficLight.Types.Classification.Types.Color), typeof(global::Osi3.TrafficLight.Types.Classification.Types.Icon), typeof(global::Osi3.TrafficLight.Types.Classification.Types.Mode) }, null, null)})
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  ///
  /// \brief A traffic light.
  ///
  /// \image html OSI_TrafficLight.svg
  ///
  /// One traffic light message defines a single 'bulb' and not a box of several
  /// bulbs, e.g. red, yellow, green are three separate traffic lights.
  /// </summary>
  public sealed partial class TrafficLight : pb::IMessage<TrafficLight>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TrafficLight> _parser = new pb::MessageParser<TrafficLight>(() => new TrafficLight());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TrafficLight> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Osi3.OsiTrafficlightReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TrafficLight() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TrafficLight(TrafficLight other) : this() {
      id_ = other.id_ != null ? other.id_.Clone() : null;
      base_ = other.base_ != null ? other.base_.Clone() : null;
      classification_ = other.classification_ != null ? other.classification_.Clone() : null;
      modelReference_ = other.modelReference_;
      sourceReference_ = other.sourceReference_.Clone();
      colorDescription_ = other.colorDescription_ != null ? other.colorDescription_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TrafficLight Clone() {
      return new TrafficLight(this);
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private global::Osi3.Identifier id_;
    /// <summary>
    /// The ID of the traffic light.
    ///
    /// \rules
    /// is_globally_unique
    /// \endrules
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.Identifier Id {
      get { return id_; }
      set {
        id_ = value;
      }
    }

    /// <summary>Field number for the "base" field.</summary>
    public const int BaseFieldNumber = 2;
    private global::Osi3.BaseStationary base_;
    /// <summary>
    /// The base parameters of the traffic light.
    ///
    /// \c BaseStationary::orientation x-axis is view normal of the traffic
    /// light's icon.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.BaseStationary Base {
      get { return base_; }
      set {
        base_ = value;
      }
    }

    /// <summary>Field number for the "classification" field.</summary>
    public const int ClassificationFieldNumber = 3;
    private global::Osi3.TrafficLight.Types.Classification classification_;
    /// <summary>
    /// The classification data for the traffic light.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.TrafficLight.Types.Classification Classification {
      get { return classification_; }
      set {
        classification_ = value;
      }
    }

    /// <summary>Field number for the "model_reference" field.</summary>
    public const int ModelReferenceFieldNumber = 4;
    private string modelReference_ = "";
    /// <summary>
    /// Opaque reference of an associated 3D model of the traffic light.
    ///
    /// \note It is implementation-specific how model_references are resolved to
    /// 3d models.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ModelReference {
      get { return modelReference_; }
      set {
        modelReference_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "source_reference" field.</summary>
    public const int SourceReferenceFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Osi3.ExternalReference> _repeated_sourceReference_codec
        = pb::FieldCodec.ForMessage(42, global::Osi3.ExternalReference.Parser);
    private readonly pbc::RepeatedField<global::Osi3.ExternalReference> sourceReference_ = new pbc::RepeatedField<global::Osi3.ExternalReference>();
    /// <summary>
    /// Optional external reference to the traffic light source.
    ///
    /// The external reference points to the source of the traffic light, if it 
    /// is derived from one or more objects or external references.
    ///
    /// For example, to reference a signal defined in an OpenDRIVE map
    /// the items should be set as follows:
    /// * reference = URI to map, can remain empty if identical with definition
    ///               in \c GroundTruth::map_reference
    /// * type = "net.asam.opendrive"
    /// * identifier[0] = id of t_road_signals_signal
    ///
    /// \note For non-ASAM Standards, it is implementation-specific how
    ///       source_reference is resolved.
    ///
    /// \note The value has to be repeated, because one lane segment may be
    ///       derived from more than one origin segment. Multiple sources
    ///       may be added as reference as well, for example, a map and sensors.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Osi3.ExternalReference> SourceReference {
      get { return sourceReference_; }
    }

    /// <summary>Field number for the "color_description" field.</summary>
    public const int ColorDescriptionFieldNumber = 6;
    private global::Osi3.ColorDescription colorDescription_;
    /// <summary>
    /// The visual color of the traffic light.
    ///
    /// \note This does not represent the semantic classification but the visual
    /// appearance.  For semantic classification of the traffic light use the color
    /// field in \c Classification.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Osi3.ColorDescription ColorDescription {
      get { return colorDescription_; }
      set {
        colorDescription_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TrafficLight);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TrafficLight other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Id, other.Id)) return false;
      if (!object.Equals(Base, other.Base)) return false;
      if (!object.Equals(Classification, other.Classification)) return false;
      if (ModelReference != other.ModelReference) return false;
      if(!sourceReference_.Equals(other.sourceReference_)) return false;
      if (!object.Equals(ColorDescription, other.ColorDescription)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (id_ != null) hash ^= Id.GetHashCode();
      if (base_ != null) hash ^= Base.GetHashCode();
      if (classification_ != null) hash ^= Classification.GetHashCode();
      if (ModelReference.Length != 0) hash ^= ModelReference.GetHashCode();
      hash ^= sourceReference_.GetHashCode();
      if (colorDescription_ != null) hash ^= ColorDescription.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (id_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Id);
      }
      if (base_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Base);
      }
      if (classification_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Classification);
      }
      if (ModelReference.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(ModelReference);
      }
      sourceReference_.WriteTo(output, _repeated_sourceReference_codec);
      if (colorDescription_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(ColorDescription);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (id_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Id);
      }
      if (base_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Base);
      }
      if (classification_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Classification);
      }
      if (ModelReference.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(ModelReference);
      }
      sourceReference_.WriteTo(ref output, _repeated_sourceReference_codec);
      if (colorDescription_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(ColorDescription);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (id_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Id);
      }
      if (base_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Base);
      }
      if (classification_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Classification);
      }
      if (ModelReference.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ModelReference);
      }
      size += sourceReference_.CalculateSize(_repeated_sourceReference_codec);
      if (colorDescription_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ColorDescription);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TrafficLight other) {
      if (other == null) {
        return;
      }
      if (other.id_ != null) {
        if (id_ == null) {
          Id = new global::Osi3.Identifier();
        }
        Id.MergeFrom(other.Id);
      }
      if (other.base_ != null) {
        if (base_ == null) {
          Base = new global::Osi3.BaseStationary();
        }
        Base.MergeFrom(other.Base);
      }
      if (other.classification_ != null) {
        if (classification_ == null) {
          Classification = new global::Osi3.TrafficLight.Types.Classification();
        }
        Classification.MergeFrom(other.Classification);
      }
      if (other.ModelReference.Length != 0) {
        ModelReference = other.ModelReference;
      }
      sourceReference_.Add(other.sourceReference_);
      if (other.colorDescription_ != null) {
        if (colorDescription_ == null) {
          ColorDescription = new global::Osi3.ColorDescription();
        }
        ColorDescription.MergeFrom(other.ColorDescription);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (id_ == null) {
              Id = new global::Osi3.Identifier();
            }
            input.ReadMessage(Id);
            break;
          }
          case 18: {
            if (base_ == null) {
              Base = new global::Osi3.BaseStationary();
            }
            input.ReadMessage(Base);
            break;
          }
          case 26: {
            if (classification_ == null) {
              Classification = new global::Osi3.TrafficLight.Types.Classification();
            }
            input.ReadMessage(Classification);
            break;
          }
          case 34: {
            ModelReference = input.ReadString();
            break;
          }
          case 42: {
            sourceReference_.AddEntriesFrom(input, _repeated_sourceReference_codec);
            break;
          }
          case 50: {
            if (colorDescription_ == null) {
              ColorDescription = new global::Osi3.ColorDescription();
            }
            input.ReadMessage(ColorDescription);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (id_ == null) {
              Id = new global::Osi3.Identifier();
            }
            input.ReadMessage(Id);
            break;
          }
          case 18: {
            if (base_ == null) {
              Base = new global::Osi3.BaseStationary();
            }
            input.ReadMessage(Base);
            break;
          }
          case 26: {
            if (classification_ == null) {
              Classification = new global::Osi3.TrafficLight.Types.Classification();
            }
            input.ReadMessage(Classification);
            break;
          }
          case 34: {
            ModelReference = input.ReadString();
            break;
          }
          case 42: {
            sourceReference_.AddEntriesFrom(ref input, _repeated_sourceReference_codec);
            break;
          }
          case 50: {
            if (colorDescription_ == null) {
              ColorDescription = new global::Osi3.ColorDescription();
            }
            input.ReadMessage(ColorDescription);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the TrafficLight message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      ///
      /// \brief \c Classification data for a traffic light.
      /// </summary>
      public sealed partial class Classification : pb::IMessage<Classification>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Classification> _parser = new pb::MessageParser<Classification>(() => new Classification());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Classification> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Osi3.TrafficLight.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Classification() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Classification(Classification other) : this() {
          color_ = other.color_;
          icon_ = other.icon_;
          mode_ = other.mode_;
          counter_ = other.counter_;
          assignedLaneId_ = other.assignedLaneId_.Clone();
          isOutOfService_ = other.isOutOfService_;
          logicalLaneAssignment_ = other.logicalLaneAssignment_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Classification Clone() {
          return new Classification(this);
        }

        /// <summary>Field number for the "color" field.</summary>
        public const int ColorFieldNumber = 1;
        private global::Osi3.TrafficLight.Types.Classification.Types.Color color_ = global::Osi3.TrafficLight.Types.Classification.Types.Color.Unknown;
        /// <summary>
        /// The semantic color of the traffic light.
        ///
        /// \note The color types represent the semantic color classification of a 
        /// traffic light only. They do not represent an actual visual appearance.
        ///
        /// \note If the color of the traffic light is known (from history or
        /// geometrical arrangement) and the state \c #mode is
        /// \c #MODE_OFF then \c #color could remain unchanged.
        /// If traffic light displays images in different colors and traffic
        /// light is off ( \c #mode =  \c #MODE_OFF), then \c #color = \c
        /// #COLOR_OTHER .
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Osi3.TrafficLight.Types.Classification.Types.Color Color {
          get { return color_; }
          set {
            color_ = value;
          }
        }

        /// <summary>Field number for the "icon" field.</summary>
        public const int IconFieldNumber = 2;
        private global::Osi3.TrafficLight.Types.Classification.Types.Icon icon_ = global::Osi3.TrafficLight.Types.Classification.Types.Icon.Unknown;
        /// <summary>
        /// The icon of the traffic light.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Osi3.TrafficLight.Types.Classification.Types.Icon Icon {
          get { return icon_; }
          set {
            icon_ = value;
          }
        }

        /// <summary>Field number for the "mode" field.</summary>
        public const int ModeFieldNumber = 3;
        private global::Osi3.TrafficLight.Types.Classification.Types.Mode mode_ = global::Osi3.TrafficLight.Types.Classification.Types.Mode.Unknown;
        /// <summary>
        /// The operating mode of the traffic light.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Osi3.TrafficLight.Types.Classification.Types.Mode Mode {
          get { return mode_; }
          set {
            mode_ = value;
          }
        }

        /// <summary>Field number for the "counter" field.</summary>
        public const int CounterFieldNumber = 4;
        private double counter_;
        /// <summary>
        /// The value of the countdown counter.
        /// Unit: % or s
        ///
        /// \note Set value only if traffic light bulb is a countdown counter.
        ///
        /// \rules
        /// is_greater_than_or_equal_to: 0
        /// \endrules
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public double Counter {
          get { return counter_; }
          set {
            counter_ = value;
          }
        }

        /// <summary>Field number for the "assigned_lane_id" field.</summary>
        public const int AssignedLaneIdFieldNumber = 5;
        private static readonly pb::FieldCodec<global::Osi3.Identifier> _repeated_assignedLaneId_codec
            = pb::FieldCodec.ForMessage(42, global::Osi3.Identifier.Parser);
        private readonly pbc::RepeatedField<global::Osi3.Identifier> assignedLaneId_ = new pbc::RepeatedField<global::Osi3.Identifier>();
        /// <summary>
        /// The IDs of the lanes that the traffic light is assigned to.
        /// Might be multiple if the traffic light is valid for multiple driving
        /// lanes.
        ///
        /// \note OSI uses singular instead of plural for repeated field names.
        ///
        /// \rules
        /// refers_to: Lane
        /// \endrules
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Osi3.Identifier> AssignedLaneId {
          get { return assignedLaneId_; }
        }

        /// <summary>Field number for the "is_out_of_service" field.</summary>
        public const int IsOutOfServiceFieldNumber = 6;
        private bool isOutOfService_;
        /// <summary>
        /// Boolean flag to indicate that the traffic light is taken out of service.
        /// This can be achieved by visibly crossing the light, covering it completely
        /// or swiching the traffic light off.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool IsOutOfService {
          get { return isOutOfService_; }
          set {
            isOutOfService_ = value;
          }
        }

        /// <summary>Field number for the "logical_lane_assignment" field.</summary>
        public const int LogicalLaneAssignmentFieldNumber = 7;
        private static readonly pb::FieldCodec<global::Osi3.LogicalLaneAssignment> _repeated_logicalLaneAssignment_codec
            = pb::FieldCodec.ForMessage(58, global::Osi3.LogicalLaneAssignment.Parser);
        private readonly pbc::RepeatedField<global::Osi3.LogicalLaneAssignment> logicalLaneAssignment_ = new pbc::RepeatedField<global::Osi3.LogicalLaneAssignment>();
        /// <summary>
        /// Assignment of this object to logical lanes.
        ///
        /// \note OSI uses singular instead of plural for repeated field names.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Osi3.LogicalLaneAssignment> LogicalLaneAssignment {
          get { return logicalLaneAssignment_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Classification);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Classification other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Color != other.Color) return false;
          if (Icon != other.Icon) return false;
          if (Mode != other.Mode) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Counter, other.Counter)) return false;
          if(!assignedLaneId_.Equals(other.assignedLaneId_)) return false;
          if (IsOutOfService != other.IsOutOfService) return false;
          if(!logicalLaneAssignment_.Equals(other.logicalLaneAssignment_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Color != global::Osi3.TrafficLight.Types.Classification.Types.Color.Unknown) hash ^= Color.GetHashCode();
          if (Icon != global::Osi3.TrafficLight.Types.Classification.Types.Icon.Unknown) hash ^= Icon.GetHashCode();
          if (Mode != global::Osi3.TrafficLight.Types.Classification.Types.Mode.Unknown) hash ^= Mode.GetHashCode();
          if (Counter != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Counter);
          hash ^= assignedLaneId_.GetHashCode();
          if (IsOutOfService != false) hash ^= IsOutOfService.GetHashCode();
          hash ^= logicalLaneAssignment_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Color != global::Osi3.TrafficLight.Types.Classification.Types.Color.Unknown) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Color);
          }
          if (Icon != global::Osi3.TrafficLight.Types.Classification.Types.Icon.Unknown) {
            output.WriteRawTag(16);
            output.WriteEnum((int) Icon);
          }
          if (Mode != global::Osi3.TrafficLight.Types.Classification.Types.Mode.Unknown) {
            output.WriteRawTag(24);
            output.WriteEnum((int) Mode);
          }
          if (Counter != 0D) {
            output.WriteRawTag(33);
            output.WriteDouble(Counter);
          }
          assignedLaneId_.WriteTo(output, _repeated_assignedLaneId_codec);
          if (IsOutOfService != false) {
            output.WriteRawTag(48);
            output.WriteBool(IsOutOfService);
          }
          logicalLaneAssignment_.WriteTo(output, _repeated_logicalLaneAssignment_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Color != global::Osi3.TrafficLight.Types.Classification.Types.Color.Unknown) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Color);
          }
          if (Icon != global::Osi3.TrafficLight.Types.Classification.Types.Icon.Unknown) {
            output.WriteRawTag(16);
            output.WriteEnum((int) Icon);
          }
          if (Mode != global::Osi3.TrafficLight.Types.Classification.Types.Mode.Unknown) {
            output.WriteRawTag(24);
            output.WriteEnum((int) Mode);
          }
          if (Counter != 0D) {
            output.WriteRawTag(33);
            output.WriteDouble(Counter);
          }
          assignedLaneId_.WriteTo(ref output, _repeated_assignedLaneId_codec);
          if (IsOutOfService != false) {
            output.WriteRawTag(48);
            output.WriteBool(IsOutOfService);
          }
          logicalLaneAssignment_.WriteTo(ref output, _repeated_logicalLaneAssignment_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Color != global::Osi3.TrafficLight.Types.Classification.Types.Color.Unknown) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Color);
          }
          if (Icon != global::Osi3.TrafficLight.Types.Classification.Types.Icon.Unknown) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Icon);
          }
          if (Mode != global::Osi3.TrafficLight.Types.Classification.Types.Mode.Unknown) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Mode);
          }
          if (Counter != 0D) {
            size += 1 + 8;
          }
          size += assignedLaneId_.CalculateSize(_repeated_assignedLaneId_codec);
          if (IsOutOfService != false) {
            size += 1 + 1;
          }
          size += logicalLaneAssignment_.CalculateSize(_repeated_logicalLaneAssignment_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Classification other) {
          if (other == null) {
            return;
          }
          if (other.Color != global::Osi3.TrafficLight.Types.Classification.Types.Color.Unknown) {
            Color = other.Color;
          }
          if (other.Icon != global::Osi3.TrafficLight.Types.Classification.Types.Icon.Unknown) {
            Icon = other.Icon;
          }
          if (other.Mode != global::Osi3.TrafficLight.Types.Classification.Types.Mode.Unknown) {
            Mode = other.Mode;
          }
          if (other.Counter != 0D) {
            Counter = other.Counter;
          }
          assignedLaneId_.Add(other.assignedLaneId_);
          if (other.IsOutOfService != false) {
            IsOutOfService = other.IsOutOfService;
          }
          logicalLaneAssignment_.Add(other.logicalLaneAssignment_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Color = (global::Osi3.TrafficLight.Types.Classification.Types.Color) input.ReadEnum();
                break;
              }
              case 16: {
                Icon = (global::Osi3.TrafficLight.Types.Classification.Types.Icon) input.ReadEnum();
                break;
              }
              case 24: {
                Mode = (global::Osi3.TrafficLight.Types.Classification.Types.Mode) input.ReadEnum();
                break;
              }
              case 33: {
                Counter = input.ReadDouble();
                break;
              }
              case 42: {
                assignedLaneId_.AddEntriesFrom(input, _repeated_assignedLaneId_codec);
                break;
              }
              case 48: {
                IsOutOfService = input.ReadBool();
                break;
              }
              case 58: {
                logicalLaneAssignment_.AddEntriesFrom(input, _repeated_logicalLaneAssignment_codec);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                Color = (global::Osi3.TrafficLight.Types.Classification.Types.Color) input.ReadEnum();
                break;
              }
              case 16: {
                Icon = (global::Osi3.TrafficLight.Types.Classification.Types.Icon) input.ReadEnum();
                break;
              }
              case 24: {
                Mode = (global::Osi3.TrafficLight.Types.Classification.Types.Mode) input.ReadEnum();
                break;
              }
              case 33: {
                Counter = input.ReadDouble();
                break;
              }
              case 42: {
                assignedLaneId_.AddEntriesFrom(ref input, _repeated_assignedLaneId_codec);
                break;
              }
              case 48: {
                IsOutOfService = input.ReadBool();
                break;
              }
              case 58: {
                logicalLaneAssignment_.AddEntriesFrom(ref input, _repeated_logicalLaneAssignment_codec);
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the Classification message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          /// <summary>
          /// Definition of semantic colors for traffic lights.
          ///
          /// \note The color types represent the semantic classification of a traffic light
          /// only. They do not represent an actual visual appearance.
          /// </summary>
          public enum Color {
            /// <summary>
            /// Color is unknown (must not be used in ground truth).
            /// </summary>
            [pbr::OriginalName("COLOR_UNKNOWN")] Unknown = 0,
            /// <summary>
            /// Other (unspecified but known) color.
            /// </summary>
            [pbr::OriginalName("COLOR_OTHER")] Other = 1,
            /// <summary>
            /// Red light.
            /// </summary>
            [pbr::OriginalName("COLOR_RED")] Red = 2,
            /// <summary>
            /// Orange-yellow light.
            /// </summary>
            [pbr::OriginalName("COLOR_YELLOW")] Yellow = 3,
            /// <summary>
            /// Green light.
            /// </summary>
            [pbr::OriginalName("COLOR_GREEN")] Green = 4,
            /// <summary>
            /// Blue light.
            /// </summary>
            [pbr::OriginalName("COLOR_BLUE")] Blue = 5,
            /// <summary>
            /// White light.
            /// </summary>
            [pbr::OriginalName("COLOR_WHITE")] White = 6,
          }

          /// <summary>
          /// Definition of traffic light bulb icon.
          /// </summary>
          public enum Icon {
            /// <summary>
            /// Unknown icon of traffic light (must not be used in ground truth).
            /// </summary>
            [pbr::OriginalName("ICON_UNKNOWN")] Unknown = 0,
            /// <summary>
            /// Other (unspecified but known) icon of traffic light.
            /// </summary>
            [pbr::OriginalName("ICON_OTHER")] Other = 1,
            /// <summary>
            /// This is a normal traffic light without specification of e.g.
            /// direction.
            /// </summary>
            [pbr::OriginalName("ICON_NONE")] None = 2,
            /// <summary>
            /// This traffic light applies to the lane straight ahead.
            /// </summary>
            [pbr::OriginalName("ICON_ARROW_STRAIGHT_AHEAD")] ArrowStraightAhead = 3,
            /// <summary>
            /// This traffic light applies to left turns.
            /// </summary>
            [pbr::OriginalName("ICON_ARROW_LEFT")] ArrowLeft = 4,
            /// <summary>
            /// This traffic light applies to diagonal left turns.
            /// </summary>
            [pbr::OriginalName("ICON_ARROW_DIAG_LEFT")] ArrowDiagLeft = 5,
            /// <summary>
            /// This traffic light applies to a lane allowing to drive straight
            /// ahead or to turn left.
            /// </summary>
            [pbr::OriginalName("ICON_ARROW_STRAIGHT_AHEAD_LEFT")] ArrowStraightAheadLeft = 6,
            /// <summary>
            /// This traffic light applies to right turns.
            /// </summary>
            [pbr::OriginalName("ICON_ARROW_RIGHT")] ArrowRight = 7,
            /// <summary>
            /// This traffic light applies to diagonal right turns.
            /// </summary>
            [pbr::OriginalName("ICON_ARROW_DIAG_RIGHT")] ArrowDiagRight = 8,
            /// <summary>
            /// This traffic light applies to a lane allowing to drive straight
            /// ahead or to turn right.
            /// </summary>
            [pbr::OriginalName("ICON_ARROW_STRAIGHT_AHEAD_RIGHT")] ArrowStraightAheadRight = 9,
            /// <summary>
            /// This traffic light applies to a lane allowing to turn left or
            /// right.
            /// </summary>
            [pbr::OriginalName("ICON_ARROW_LEFT_RIGHT")] ArrowLeftRight = 10,
            /// <summary>
            /// This traffic light indicates that the assigned lane is open for
            /// driving.
            /// </summary>
            [pbr::OriginalName("ICON_ARROW_DOWN")] ArrowDown = 11,
            /// <summary>
            /// This traffic light indicates a necessary lane change to the left
            /// ahead.
            /// </summary>
            [pbr::OriginalName("ICON_ARROW_DOWN_LEFT")] ArrowDownLeft = 12,
            /// <summary>
            /// This traffic light indicates a necessary lane change to the right
            /// ahead.
            /// </summary>
            [pbr::OriginalName("ICON_ARROW_DOWN_RIGHT")] ArrowDownRight = 13,
            /// <summary>
            /// This traffic light indicates that the assigned lane is not open
            /// for driving.
            /// </summary>
            [pbr::OriginalName("ICON_ARROW_CROSS")] ArrowCross = 14,
            /// <summary>
            /// This traffic light is valid for pedestrians.
            /// </summary>
            [pbr::OriginalName("ICON_PEDESTRIAN")] Pedestrian = 15,
            /// <summary>
            /// This traffic light is valid for pedestrians with letters 'walk'.
            /// </summary>
            [pbr::OriginalName("ICON_WALK")] Walk = 16,
            /// <summary>
            /// This traffic light is valid for pedestrians with letters 'don't
            /// walk'.
            /// </summary>
            [pbr::OriginalName("ICON_DONT_WALK")] DontWalk = 17,
            /// <summary>
            /// This traffic light is valid for bicyclists.
            /// </summary>
            [pbr::OriginalName("ICON_BICYCLE")] Bicycle = 18,
            /// <summary>
            /// This traffic light is valid for pedestrians and bicyclists.
            /// </summary>
            [pbr::OriginalName("ICON_PEDESTRIAN_AND_BICYCLE")] PedestrianAndBicycle = 19,
            /// <summary>
            /// This traffic light counter in second.
            /// </summary>
            [pbr::OriginalName("ICON_COUNTDOWN_SECONDS")] CountdownSeconds = 20,
            /// <summary>
            /// This traffic light counter in percent.
            /// </summary>
            [pbr::OriginalName("ICON_COUNTDOWN_PERCENT")] CountdownPercent = 21,
            /// <summary>
            /// This traffic light is valid for
            /// trams.
            ///
            /// \note There is no detailed traffic light specification for trams
            /// and buses at the moment.
            /// </summary>
            [pbr::OriginalName("ICON_TRAM")] Tram = 22,
            /// <summary>
            /// This traffic light is valid for
            /// buses.
            ///
            /// \note There is no detailed traffic light specification for trams
            /// and buses at the moment.
            /// </summary>
            [pbr::OriginalName("ICON_BUS")] Bus = 23,
            /// <summary>
            /// This traffic light is valid for
            /// buses and trams.
            ///
            /// \note There is no detailed traffic light specification for trams
            /// and buses at the moment.
            /// </summary>
            [pbr::OriginalName("ICON_BUS_AND_TRAM")] BusAndTram = 24,
          }

          /// <summary>
          /// Definition of light modes for traffic lights.
          /// </summary>
          public enum Mode {
            /// <summary>
            /// Mode is unknown (must not be used in ground truth).
            /// </summary>
            [pbr::OriginalName("MODE_UNKNOWN")] Unknown = 0,
            /// <summary>
            /// Other (unspecified but known) mode.
            /// </summary>
            [pbr::OriginalName("MODE_OTHER")] Other = 1,
            /// <summary>
            /// Traffic light is off.
            /// </summary>
            [pbr::OriginalName("MODE_OFF")] Off = 2,
            /// <summary>
            /// Light is on and not flashing.
            /// </summary>
            [pbr::OriginalName("MODE_CONSTANT")] Constant = 3,
            /// <summary>
            /// Light is flashing.
            /// </summary>
            [pbr::OriginalName("MODE_FLASHING")] Flashing = 4,
            /// <summary>
            /// Light is counting.
            /// </summary>
            [pbr::OriginalName("MODE_COUNTING")] Counting = 5,
          }

        }
        #endregion

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
