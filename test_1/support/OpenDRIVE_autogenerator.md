
# OpenDRIVE C++ autogenerator:

Through the use of the python interface, esmini now has support for autogenerating C++ header files based on the standard OpenDRIVE. These autogenerated files will be used as the base of esmini's implementation of OpenDRIVE. The goal is to simplify updating to newer version or having the capability of switching between version. This, as the implementation of the standards, will be decoupled from the implementation of functionality in esmini.

These files can be generated using the python command:

`python3 main.py generate opendrive`

The generation works by parsing the OpenDRIVE schema files (.xsd) and converting them into the corresponding C++ data types. The parsed OpenDRIVE schema files are then generated as .hpp files using the python library jinja2.

## The steps of OpenDRIVE autogenerator:
The OpenDRIVE autogenerator is divided in to two parts, the parser and the generator.
### OpenDRIVE schema parser:
The parser create python dictionaries for all OpenDRIVE schema files, these dictionaries are then feed to the generator to generate the corresponding C++ header files.

1. Parse all OpenDRIVE schema files (.xsd) in to separate dictionaries:
    - Recursively parses the xml from the XSD schema file.
        - Translates XSD types to C++ types.
        - Replaces *illegal* variable names or enums.
    - Converts union classes to C++ structs.
    - Create a reference list containing the full namespaces for each class/enum, this to solve compile issues (**Step 2**).
    - Orders the dictionary to fix any issues where a class has a reference to another class.
    - Create correct inheritances between classes.

2. Fixes incorrect declaration/references to classes/enums from the other files:
    - By looping through the corresponding dictionary for each file and replacing the incorrect declarations of classes/enums to have the correct full namespace. The namespace is fetched from the reference list created during parsing.

### Generation with jinja2:
The python library jinja2 is the templating engine used to autogenerated the files for the python dictionary created by the parser in **Step 1 & 2**. It takes the dictionaries created by the parser as input and uses predefined templates to generate the  C++ header files.

3. Generates the corresponding files to each dictionary:
    - For Road.hpp, it's necessary to create another file, named Shared.hpp, it only contains the struct *e_countryCode*. This due to mutual inclusion compile issue between Road.hpp and Signal.hpp.


## OpenDRIVE schema keywords:
These OpenDRIVE schema keywords are used to define the datastructure in the OpenDRIVE standard. They are displayed in the order they appear in the OpenDRIVE schemas.
* **simpleType** or **complexType**
    *   **restriction** , **extension** or **union**
        *   **enumeration**, **sequence**, **attribute** or **choice**
            *   **sequence** contains one or more **element** or **choice**

### XSD keywords to C++ data types:
The keywords are interpreted as the following C++ data structures or types during the parsing of OpenDRIVE standard files:
- **simpleType** -> Enum or Struct, subelements is used to determine what type.
- **complexType** -> Class.
    - **union** -> Struct, interpreted as a struct, due to the **C++ union**  is not being used in esmini.
    - **restriction** or **extension** -> Keyword is parsed but not translated to a corresponding C++ type.
        - **enumeration** -> Element in enum.
        - **sequence** -> Containing *public* variables.
            - **element** -> Definition of a variable under sequence.
            - **choice** -> If found under **sequence**, keyword is discarded and its elements are added to **sequence**.
                - **element** -> Definition of a variable.
        - **attribute** -> Definition of a *protected* variable.
        - **choice** -> If found under **extension**, interpreted as showing what classes inherits the class.
            - **element** -> definition of class inheritance.